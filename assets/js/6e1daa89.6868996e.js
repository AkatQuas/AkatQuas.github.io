"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7401],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>d});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},h=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=i,d=u["".concat(l,".").concat(m)]||u[m]||p[m]||r;return n?a.createElement(d,o(o({ref:t},h),{},{components:n})):a.createElement(d,o({ref:t},h))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},96873:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=n(87462),i=(n(67294),n(3905));const r={title:"Computing with Register Machines",tags:["sicp"]},o=void 0,s={unversionedId:"sicp/computing-with-register-machines",id:"sicp/computing-with-register-machines",title:"Computing with Register Machines",description:"In this chapter we will describe processes in terms of the step-by-step operation of a traditional computer. Such a computer, or register machine, sequentially executes instructions that manipulate the contents of a fixed set of storage elements called registers.",source:"@site/docs/sicp/05-computing-with-register-machines.md",sourceDirName:"sicp",slug:"/sicp/computing-with-register-machines",permalink:"/docs/sicp/computing-with-register-machines",draft:!1,tags:[{label:"sicp",permalink:"/docs/tags/sicp"}],version:"current",sidebarPosition:5,frontMatter:{title:"Computing with Register Machines",tags:["sicp"]},sidebar:"tutorialSidebar",previous:{title:"Metalinguistic Abstraction",permalink:"/docs/sicp/metalinguistic-abstraction"},next:{title:"Go Concurrency Again",permalink:"/docs/concurrency-in-go/"}},l={},c=[{value:"Designing Register Machines",id:"designing-register-machines",level:2},{value:"A Language for Describing Register Machines",id:"a-language-for-describing-register-machines",level:3},{value:"Abstraction in Machine Design",id:"abstraction-in-machine-design",level:3},{value:"Subroutines",id:"subroutines",level:3},{value:"Using a Stack to Implement Recursion",id:"using-a-stack-to-implement-recursion",level:3},{value:"A Register-Machine Simulator",id:"a-register-machine-simulator",level:2},{value:"The Machine Model",id:"the-machine-model",level:3},{value:"The Assembler",id:"the-assembler",level:3},{value:"Generating Execution Procedures for Instructions",id:"generating-execution-procedures-for-instructions",level:3},{value:"Monitoring Machine Performance",id:"monitoring-machine-performance",level:3},{value:"Storage Allocation and Garbage Collection",id:"storage-allocation-and-garbage-collection",level:2},{value:"Memory as Vectors",id:"memory-as-vectors",level:3},{value:"Maintaining the Illusion of Infinite Memory",id:"maintaining-the-illusion-of-infinite-memory",level:3},{value:"The Explicit-Control Evaluator",id:"the-explicit-control-evaluator",level:2},{value:"The Core of the Explicit-Control Evaluator",id:"the-core-of-the-explicit-control-evaluator",level:3},{value:"Sequence Evaluation and Tail Recursion",id:"sequence-evaluation-and-tail-recursion",level:3},{value:"Conditionals, Assignments, and Definitions",id:"conditionals-assignments-and-definitions",level:3},{value:"Running the Evaluator",id:"running-the-evaluator",level:3},{value:"Compilation",id:"compilation",level:2},{value:"Structure of the Compiler",id:"structure-of-the-compiler",level:3},{value:"Compiling Expressions",id:"compiling-expressions",level:3},{value:"Compiling Combinations",id:"compiling-combinations",level:3},{value:"Combining Instruction Sequences",id:"combining-instruction-sequences",level:3},{value:"An Example of Compiled Code",id:"an-example-of-compiled-code",level:3},{value:"Lexical Addressing",id:"lexical-addressing",level:3},{value:"Interfacing Compiled Code to the Evaluator",id:"interfacing-compiled-code-to-the-evaluator",level:3}],h={toc:c};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In this chapter we will describe processes in terms of the step-by-step operation of a traditional computer. Such a computer, or ",(0,i.kt)("em",{parentName:"p"},"register machine"),", sequentially executes ",(0,i.kt)("em",{parentName:"p"},"instructions")," that manipulate the contents of a fixed set of storage elements called ",(0,i.kt)("em",{parentName:"p"},"registers"),"."),(0,i.kt)("p",null,"A typical register machine instruction applies a primitive operation to the contents of some registers and assigns the result to another register. The descriptions of processes executed by register machines will look very much like ",(0,i.kt)("em",{parentName:"p"},"machine-language")," programs for traditional computers."),(0,i.kt)("h2",{id:"designing-register-machines"},"Designing Register Machines"),(0,i.kt)("p",null,"To design a register machine, we must design its ",(0,i.kt)("em",{parentName:"p"},"data paths")," (registers and operations) and the ",(0,i.kt)("em",{parentName:"p"},"controller")," that sequences these operations."),(0,i.kt)("p",null,"An operation that computes a value from constants and the contents of registers is represented in a data-path diagram by a trapezoid containing a name for the operation."),(0,i.kt)("p",null,"Overall, the data-path diagram shows the registers and operations that are required for the machine and how they must be connected."),(0,i.kt)("h3",{id:"a-language-for-describing-register-machines"},"A Language for Describing Register Machines"),(0,i.kt)("p",null,"To make it possible to deal with complex machines, we will create a language that presents, in textual form, all the information given by the data-path and controller diagrams."),(0,i.kt)("p",null,"We define the data paths of a machine by describing the registers and the operations:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To describe a register, we give it a name and specify the buttons that control assignment to it. We give each of the buttons a name and specify the source of the data that enters the register under the button's control. (The source is a register, a constant, or an operation.)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To describe an operation, we give it a name and specify its inputs (registers or constants)."))),(0,i.kt)("p",null,"We define the controller of a machine as a sequence of ",(0,i.kt)("em",{parentName:"p"},"instructions")," together with ",(0,i.kt)("em",{parentName:"p"},"labels")," that identify ",(0,i.kt)("em",{parentName:"p"},"entry points")," in the sequence. An instruction is one of the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The name of a data-path button to push to assign a value to a register.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A ",(0,i.kt)("em",{parentName:"p"},"test")," instruction to perform a specified test, or assertion.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A conditional branch to location indicated by a controller label, based on the result of the previous test. If the test is false, the controller should continue with the next instruction in the sequence. Otherwise, the controller should continue with the instruction after the label."))),(0,i.kt)("p",null,"The machine starts at the beginning of the controller instruction sequence and stops when execution reaches the end of the sequence. Except when a branch changes the flow of control, instructions are executed in the order in which they are listed."),(0,i.kt)("p",null,"Unfortunately, it is difficult to read such a description. In order to understand the controller instructions we must constantly refer back to the definitions of the button names and the operation names, and to understand what the buttons do we may have to refer to the definitions of the operation names. We will thus transform our notation to combine the information from the data-path and controller descriptions so that we see it all together."),(0,i.kt)("p",null,"We will omit the data-path description, leaving only the controller sequence."),(0,i.kt)("p",null,"This form of description is easier to read, but it also has disadvantages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It is more verbose for large machines, because complete descriptions of the data-path elements are repeated whenever the elements are mentioned in the controller instruction sequence. Moreover, repeating the data-path descriptions obscures the actual data-path structure of the machine; it is not obvious for a large machine how many registers, operations, and buttons there are how they are interconnected.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Because the controller instructions in a machine definition look like Lisp expressions, it is easy to forget that they are not arbitrary Lisp expressions. They can notate only legal machine operations. For example, operations can operate directly only on constants and the contents of registers, not on the results of other operations."))),(0,i.kt)("p",null,"In spite of these disadvantages, we will use this register-machine language throughout this chapter, because we will be more concerned with understanding controllers than with understanding the elements and connections in data paths."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"However, that data-path design is crucial in designing real machines.")),(0,i.kt)("h3",{id:"abstraction-in-machine-design"},"Abstraction in Machine Design"),(0,i.kt)("p",null,"We will often define a machine to include ",(0,i.kt)("em",{parentName:"p"},"primitive")," operations that are actually very complex. The fact that we have swept a lot of complexity under the rug, however, does not mean that a machine design is unrealistic. We can always replace the complex ",(0,i.kt)("em",{parentName:"p"},"primitives")," by simpler primitive operations."),(0,i.kt)("h3",{id:"subroutines"},"Subroutines"),(0,i.kt)("p",null,"When designing a machine to perform a computation, we would often prefer to arrange for components to be shared by different parts of the computation rather than duplicate the components."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Something looks like interrupts, sub-procedure invocation, etc.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"This might be useful in compiler optimization.")),(0,i.kt)("p",null,"A more powerful method for implementing subroutines is to have the continue register hold the label of the entry point in the controller sequence at which execution should continue when the subroutine is finished. Implementing this strategy requires a new kind of connection between the data paths and the controller of a register machine: there must be a way to assign to a register a label in the controller sequence in such a way that this value can be fetched from the register and used to continue execution at the designated entry point. However, it might lead to some problem if we assign different value to the same continue register in every subroutine, just think about nested subroutine calls, which is recursion."),(0,i.kt)("h3",{id:"using-a-stack-to-implement-recursion"},"Using a Stack to Implement Recursion"),(0,i.kt)("p",null,"With the ideas illustrated so far, we can implement any iterative process by specifying a register machine that has a register corresponding to each state variable of the process. The machine repeatedly executes a controller loop, changing the contents of the registers, until some termination condition is satisfied. At each point in the controller sequence, the state of the machine (representing the state of the iterative process) is completely determined by the contents of the registers (the values of the state variables)."),(0,i.kt)("p",null,"Implementing recursive processes, however, requires an additional mechanism."),(0,i.kt)("p",null,"Nevertheless, we can implement the recursive process as a register machine if we can arrange to use the same components for each nested instance of the machine. This is plausible because, ",(0,i.kt)("em",{parentName:"p"},"although the recursive process dictates that an unbounded number of copies of the same machine are needed to perform a computation, only one of these copies needs to be active at any given time"),". So when the machine encounters a recursive subproblem, it can suspend work on the main problem, reuse the same physical parts to work on the subproblem, then continue the suspended computation."),(0,i.kt)("p",null,"In the subproblem, the contents of the registers will be different from they were in the main problem. (In this case the n register is decremented.) In order to be able to continue the suspended computation, the machine must save the contents of any registers that will be needed after the subproblem is solved so that these can be restored to continue the suspended computation."),(0,i.kt)("p",null,"Since there is no a ",(0,i.kt)("em",{parentName:"p"},"priori")," limit on the depth of nested recursive calls, we may need to save an arbitrary number of register values. These values must be restored in the reverse of the order in which they were saved, since in a nest of recursions the last subproblem to be entered is the first to be finished."),(0,i.kt)("p",null,"This dictates the use of a stack, or ",(0,i.kt)("em",{parentName:"p"},"last in, first out")," data structure, to save register values. We can extend the register-machine language to include a stack by adding two kinds of instructions: Values are placed on the stack using a ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," instruction and restored from the stack using a ",(0,i.kt)("inlineCode",{parentName:"p"},"restore")," instruction. After a sequence of values has been ",(0,i.kt)("inlineCode",{parentName:"p"},"saved")," on the stack, a sequence of ",(0,i.kt)("inlineCode",{parentName:"p"},"restores")," will retrieve these values in reverse order."),(0,i.kt)("h2",{id:"a-register-machine-simulator"},"A Register-Machine Simulator"),(0,i.kt)("p",null,"The simulator is a Scheme program with four interface procedures. The first uses a description of a register machine to construct a model of the machine (a data structure whose parts correspond to the parts of the machine to be simulated), and the other three allow us to simulate the machine by manipulating the model:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"(make-machine \u27e8register-names\u27e9 \u27e8operations\u27e9 \u27e8controller\u27e9)")," constructs and returns a model of the machine with the given registers, operations, and controller.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"(set-register-contents! \u27e8machine-model\u27e9 \u27e8register-name\u27e9 \u27e8value\u27e9)")," stores a value in a simulated register in the given machine.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"(get-register-contents \u27e8machine-model\u27e9 \u27e8register-name\u27e9)")," returns the contents of a simulated register in the given machine.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"(start \u27e8machine-model\u27e9)")," simulates the execution of the given machine, starting from the beginning of the controller sequence and stopping when it reaches the end of the sequence."))),(0,i.kt)("h3",{id:"the-machine-model"},"The Machine Model"),(0,i.kt)("p",null,"To build this model, ",(0,i.kt)("inlineCode",{parentName:"p"},"make-machine")," begins by calling the procedure ",(0,i.kt)("inlineCode",{parentName:"p"},"make-new-machine")," to construct the parts of the machine model that are common to all register machines. This basic machine model constructed by ",(0,i.kt)("inlineCode",{parentName:"p"},"make-new-machine")," is essentially a container for ",(0,i.kt)("em",{parentName:"p"},"some registers")," and ",(0,i.kt)("em",{parentName:"p"},"a stack"),", together with ",(0,i.kt)("em",{parentName:"p"},"an execution mechanism")," that processes the controller instructions one by one."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"make-machine")," then extends this basic model (by sending it messages) to include the registers, operations, and controller of the particular machine being defined. First it allocates a register in the new machine for each of the supplied register names and installs the designated operations in the machine. Then it uses an ",(0,i.kt)("em",{parentName:"p"},"assembler")," to transform the controller list into instructions for the new machine and installs these as the machine\u2019s instruction sequence. ",(0,i.kt)("inlineCode",{parentName:"p"},"make-machine")," returns as its value the modified machine model."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Registers")),(0,i.kt)("p",null,"Register would be a procedure with local state, which is used to hold a value that can be accessed or changed."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The stack")),(0,i.kt)("p",null,"Stack would be a procedure with local state, whose local state consists of a list of the items on the stack."),(0,i.kt)("p",null,"A stack accepts requests to ",(0,i.kt)("inlineCode",{parentName:"p"},"push")," and item onto the stack, to ",(0,i.kt)("inlineCode",{parentName:"p"},"pop")," the top item off the stack and return it, and to ",(0,i.kt)("inlineCode",{parentName:"p"},"initialize")," the stack to empty."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The basic machine")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"make-new-machine")," procedure constructs an object whose local state consists of a stack, an initially empty instruction sequence, a list of operations that initially contains an operation to initialize the stack, and a register table that initially contains two registers, named ",(0,i.kt)("inlineCode",{parentName:"p"},"flag")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"pc")," (for ",(0,i.kt)("em",{parentName:"p"},"program counter"),")."),(0,i.kt)("p",null,"The internal procedure ",(0,i.kt)("inlineCode",{parentName:"p"},"allocate-register")," adds new entries to the register table, and the internal procedure ",(0,i.kt)("inlineCode",{parentName:"p"},"lookup-register")," looks up registers in the table."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"flag")," register is used to control branching in the simulated machine."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"pc")," register determines the sequencing of instructions as the machine runs. In the simulation model, each machine instruction is a data structure that includes a procedure of no arguments, called the ",(0,i.kt)("inlineCode",{parentName:"p"},"instruction execution procedure"),", such that calling this procedure simulates executing the instruction. As the simulation runs, ",(0,i.kt)("inlineCode",{parentName:"p"},"pc")," points to the place in the instruction sequence beginning with the next instruction to be executed. ",(0,i.kt)("inlineCode",{parentName:"p"},"execute")," gets that instruction, executes it by calling the instruction execution procedure, and repeats this cycle until there are no more instructions to execute."),(0,i.kt)("p",null,"Notice that starting the machine is accomplished by setting ",(0,i.kt)("inlineCode",{parentName:"p"},"pc")," to the beginning of the instruction sequence and calling ",(0,i.kt)("inlineCode",{parentName:"p"},"execute"),"."),(0,i.kt)("h3",{id:"the-assembler"},"The Assembler"),(0,i.kt)("p",null,"The assembler transforms the sequence of controller expressions for a machine into a corresponding list of machine instructions, each with its execution procedure."),(0,i.kt)("p",null,"To speed up the execution procedure, we could separate the analysis from runtime execution, aka AOT compilation."),(0,i.kt)("p",null,"Before it can generate the instruction execution procedures, the assembler must know what all the labels refer to, so it begins by scanning the controller text to separate the labels from the instructions. As it scans the text, it constructs both a list of instructions and a table that associates each label with a pointer into that list. Then the assembler augments the instruction list by inserting the execution procedure for each instruction."),(0,i.kt)("p",null,"The machine instruction data structure simply pairs the instruction text with the corresponding execution procedure."),(0,i.kt)("h3",{id:"generating-execution-procedures-for-instructions"},"Generating Execution Procedures for Instructions"),(0,i.kt)("p",null,"The assembler calls ",(0,i.kt)("inlineCode",{parentName:"p"},"make-execution-procedure")," to generate the execution procedure for an instruction. This dispatches on the type of instruction to generate the appropriate execution procedure."),(0,i.kt)("p",null,"For each type of instruction in the register-machine language, there is a generator that builds an appropriate execution procedure. The details of these procedures determine both the syntax and meaning of the individual instructions in the register-machine language."),(0,i.kt)("h3",{id:"monitoring-machine-performance"},"Monitoring Machine Performance"),(0,i.kt)("p",null,"Simulation is useful not only for verifying the correctness of a proposed machine design but also for measuring the machine's performance."),(0,i.kt)("p",null,"To do this, we modify our simulated stack to keep track of the number of times registers are saved on the stack and the maximum depth reached by the stack, and add a message to the stack's interface that prints the statistics."),(0,i.kt)("h2",{id:"storage-allocation-and-garbage-collection"},"Storage Allocation and Garbage Collection"),(0,i.kt)("p",null,"We will assume that our register machines can be equipped with a ",(0,i.kt)("em",{parentName:"p"},"list-structured memory"),", in which the basic operations for manipulating list-structured data are primitive."),(0,i.kt)("p",null,"There are two considerations in implementation list structure."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"how to represent the ",(0,i.kt)("em",{parentName:"p"},"box-and-pointer")," structure of Lisp pairs, using only the storage and addressing capabilities of typical computer memories")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"the management of memory as the computation proceeds, such as storage allocation and recycling."))),(0,i.kt)("h3",{id:"memory-as-vectors"},"Memory as Vectors"),(0,i.kt)("p",null,"A conventional computer memory can be thought of as an array of cubbyholes, each of which can contain a piece of information. Each cubbyhole has a unique name, called its ",(0,i.kt)("em",{parentName:"p"},"address")," or ",(0,i.kt)("em",{parentName:"p"},"location"),"."),(0,i.kt)("p",null,"Typical memory systems provide two primitive operations: one that fetches the data stored in a specified location and one that assigns new data to a specified location. Memory addresses can be incremented to support sequential access to some set of the cubbyholes. More generally, many important data operations require that memory addresses be treated as data, which can be stored in memory locations and manipulated in machine registers. The representation of list structure is one application of such ",(0,i.kt)("em",{parentName:"p"},"address arithmetic"),"."),(0,i.kt)("p",null,"To model computer memory, we use a new kind of data structure called ",(0,i.kt)("em",{parentName:"p"},"vector"),"."),(0,i.kt)("p",null,"Abstractly, a vector is a compound data object whose individual elements can be accessed by means of an integer index in an amount of time that is independent of the index."),(0,i.kt)("p",null,"For computer memory, this access can be implemented through the use of address arithmetic to combine a ",(0,i.kt)("em",{parentName:"p"},"base address")," that specifies the beginning location of a vector in memory with an ",(0,i.kt)("em",{parentName:"p"},"index")," that specifies the offset of a particular element of the vector."),(0,i.kt)("p",null,"We also need a representation for objects and a way to distinguish one kind of data from another. There are many methods of accomplishing this, but they all reduce to using ",(0,i.kt)("em",{parentName:"p"},"typed pointers"),", that is, to extending the notion of pointer to include information on data type. Two data objects are considered to be the same if their pointers are identical."),(0,i.kt)("h3",{id:"maintaining-the-illusion-of-infinite-memory"},"Maintaining the Illusion of Infinite Memory"),(0,i.kt)("p",null,"With a real computer we will eventually run out of free space in which to construct new dat objects. However, most of the data objects generated in a typical computation are used only to hold intermediate results. After these results are accessed, the data objects are no longer needed -- they are ",(0,i.kt)("em",{parentName:"p"},"garbage"),"."),(0,i.kt)("p",null,"If we can arrange to collect all the garbage periodically, and if this turns out to recycle memory at about the same rate at which we construct new data objects, we will have preserved the illusion that there is an infinite amount of memory."),(0,i.kt)("p",null,"Garbage collection is based on the observation that, at any moment in procedure execution, the only objects that can affect the future of the computation are those that can be reached by some operations starting from the pointers that are currently in the machine registers. Any memory cell that this not so accessible may be recycled."),(0,i.kt)("p",null,"The method used here to perform garbage collection is called ",(0,i.kt)("em",{parentName:"p"},"stop-and-copy"),". When working memory is full, we perform garbage collection by locating all the useful pairs in working memory and copying these into consecutive locations in free memory. Since we do not copy the garbage, there will presumably be additional free memory that we can use to allocate new pairs. In addition, nothing in the working memory is needed, since all the useful pairs in it have been copied. Thus, if we interchange the roles of working memory and free memory, we can continue processing; new pairs will be allocated in the new working memory (which was the old free memory). When this is full, we can copy the useful pairs into the new free memory (which was the old working memory)."),(0,i.kt)("h2",{id:"the-explicit-control-evaluator"},"The Explicit-Control Evaluator"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"It's much like an interpreter for interpretive language, except the runtime is register-machine, rather than a VM such as V8/JVM.")),(0,i.kt)("h3",{id:"the-core-of-the-explicit-control-evaluator"},"The Core of the Explicit-Control Evaluator"),(0,i.kt)("h3",{id:"sequence-evaluation-and-tail-recursion"},"Sequence Evaluation and Tail Recursion"),(0,i.kt)("h3",{id:"conditionals-assignments-and-definitions"},"Conditionals, Assignments, and Definitions"),(0,i.kt)("h3",{id:"running-the-evaluator"},"Running the Evaluator"),(0,i.kt)("h2",{id:"compilation"},"Compilation"),(0,i.kt)("p",null,"The explicit-control evaluator machine is universal\u2014it can carry out any computational process that can be described in Scheme."),(0,i.kt)("p",null,"Thus, the evaluator\u2019s data paths are universal: they are sufficient to perform any computation we desire, given an appropriate controller."),(0,i.kt)("p",null,"Commercial general-purpose computers are register machines organized around a collection of registers and operations that constitute an efficient and convenient set of data paths. The controller for a general-purpose machine is an interpreter for a register-machine language like the one we have been using. This language is called the ",(0,i.kt)("em",{parentName:"p"},"native language")," of the machine, or simply ",(0,i.kt)("em",{parentName:"p"},"machine language"),". Programs written in machine language are sequences of instructions that use the machine's data paths."),(0,i.kt)("p",null,"There are two common strategies for bridging the gap between higher-level languages and register-machine languages. The explicit-control evaluator illustrates the strategy of interpretation. An interpreter written in the native language of a machine configures the machine to execute programs written in a language (called the ",(0,i.kt)("em",{parentName:"p"},"source language"),") that may differ from the native language of the machine performing the evaluation. The primitive procedures of the source language are implemented as a library of subroutines written in the native language of the given machine. A program to be interpreted (called the ",(0,i.kt)("em",{parentName:"p"},"source program"),") is represented as a data structure. The interpreter traverses this data structure, analyzing the source program. As it does so, it simulates the intended behavior of the source program by calling appropriate primitive subroutines from the library."),(0,i.kt)("p",null,"The alternative strategy is ",(0,i.kt)("em",{parentName:"p"},"compilation"),". A compiler for a given source language and machine translates a source program into an equivalent program (called the ",(0,i.kt)("em",{parentName:"p"},"object program"),") written in the machine\u2019s native language."),(0,i.kt)("p",null,"Compared with interpretation, compilation can provide a great increase in the efficiency of program execution."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"On the other hand, an interpreter provides a more powerful environment for interactive program development and debugging, because the source program being executed is available at run time to be examined and modified. In addition, because the entire library of primitives is present, new programs can be constructed and added to the system during debugging.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"An overview of the compiler")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"In general, the compiler translates a source program into an object program that performs essentially the same register operations as would the interpreter in evaluating the same source program.")),(0,i.kt)("p",null,"This description suggests a strategy for implementing a rudimentary compiler: We traverse the expression in the same way the interpreter does. When we encounter a register instruction that the interpreter would perform in evaluating the expression, we do not execute the instruction but instead accumulate it into a sequence. The resulting sequence of instructions will be the object code."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"With a compiler, the expression is analyzed only once, when the instruction sequence is generated at compile time.")),(0,i.kt)("p",null,"But there are further opportunities to gain efficiency in compiled code. As the interpreter runs, it follows a process that must be applicable to any expression in the language. In contrast, a given segment of compiled code is meant to execute some particular expression:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"This can make a big difference, for example in the use of the stack to save registers. When the interpreter evaluates an expression, it must be prepared for any contingency. Before evaluating a subexpression, the interpreter saves all registers that will be needed later, because the subexpression might require an arbitrary evaluation. A compiler, on the other hand, can exploit the structure of the particular expression it is processing to generate code that avoids unnecessary stack operations.\n")),(0,i.kt)("p",null,"A compiler can also optimize access to the environment. Having analyzed the code, the compiler can in many cases know in which frame a particular variable will be located and access that frame directly, rather than performing the ",(0,i.kt)("inlineCode",{parentName:"p"},"lookup-variable-value")," search."),(0,i.kt)("h3",{id:"structure-of-the-compiler"},"Structure of the Compiler"),(0,i.kt)("p",null,"In the compiler, we will do essentially the necessary analysis. Instead of producing execution procedures, however, we will generate ",(0,i.kt)("em",{parentName:"p"},"sequences of instructions")," to be run by our register machine."),(0,i.kt)("h3",{id:"compiling-expressions"},"Compiling Expressions"),(0,i.kt)("h3",{id:"compiling-combinations"},"Compiling Combinations"),(0,i.kt)("h3",{id:"combining-instruction-sequences"},"Combining Instruction Sequences"),(0,i.kt)("h3",{id:"an-example-of-compiled-code"},"An Example of Compiled Code"),(0,i.kt)("h3",{id:"lexical-addressing"},"Lexical Addressing"),(0,i.kt)("h3",{id:"interfacing-compiled-code-to-the-evaluator"},"Interfacing Compiled Code to the Evaluator"))}u.isMDXComponent=!0}}]);