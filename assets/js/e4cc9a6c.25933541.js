"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[599],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(n),k=r,d=u["".concat(l,".").concat(k)]||u[k]||m[k]||o;return n?a.createElement(d,s(s({ref:t},p),{},{components:n})):a.createElement(d,s({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=k;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[u]="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"},38501:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const o={title:"Security in Docker",sidebar_position:11},s=void 0,i={unversionedId:"docker/security",id:"docker/security",title:"Security in Docker",description:"Security is all about layers.",source:"@site/docs/docker/security.md",sourceDirName:"docker",slug:"/docker/security",permalink:"/docs/docker/security",draft:!1,tags:[],version:"current",sidebarPosition:11,frontMatter:{title:"Security in Docker",sidebar_position:11},sidebar:"tutorialSidebar",previous:{title:"Remote access",permalink:"/docs/docker/remote-engine"},next:{title:"Production Practices",permalink:"/docs/docker/production-practices"}},l={},c=[{value:"Linux security technologies",id:"linux-security-technologies",level:3},{value:"Docker platform security technologies",id:"docker-platform-security-technologies",level:3}],p={toc:c};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Security is all about layers."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# Docker Platform technologies\nSecrets Management\nDocker Content Trust\nImage Scanning\nSwarm Mode\n\n# OS (Linux) technologies\nseccomp\nMandatory Access Control\nCapabilities\nControl groups (cgroups)\nKernel namespaces\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Docker Swarm Mode")," is secure by default. You get all following with zero configuration required; ",(0,r.kt)("em",{parentName:"p"},"cryptographic node IDs"),", ",(0,r.kt)("em",{parentName:"p"},"mutual authentication"),", ",(0,r.kt)("em",{parentName:"p"},"automatic CA configuration"),", ",(0,r.kt)("em",{parentName:"p"},"automatic certificate rotation"),", ",(0,r.kt)("em",{parentName:"p"},"encrypted cluster store"),", ",(0,r.kt)("em",{parentName:"p"},"encrypted networks"),", and more.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Docker Content Trust (DCT)")," lets you sign your images and verify the integrity and publisher of images you consume.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Image security")," scanning analyses images, detects known vulnerabilities, and provides detailed reports.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Docker secrets")," are a way to securely share sensitive data and are first-class objects in Docker. They\u2019re stored in the encrypted cluster store, encrypted in-flight when delivered to containers, stored in in-memory filesystems when in use, and operate a least-privilege model."))),(0,r.kt)("h3",{id:"linux-security-technologies"},"Linux security technologies"),(0,r.kt)("p",null,"All good container platforms use ",(0,r.kt)("em",{parentName:"p"},"namespaces")," and ",(0,r.kt)("em",{parentName:"p"},"cgroups")," to build containers."),(0,r.kt)("p",null,"The best container platforms will also integrate with other Linux security technologies such as ",(0,r.kt)("em",{parentName:"p"},"capabilities"),", ",(0,r.kt)("em",{parentName:"p"},"Mandatory Access Control")," systems like SELinux and AppArmor, and seccomp."),(0,r.kt)("p",null,"Docker integrates with them all."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Namespaces")),(0,r.kt)("p",null,"Kernel namespaces are at the very heart of containers. They slice up an operating system (OS) so that it looks and feels like multiple ",(0,r.kt)("em",{parentName:"p"},"isolated")," operating systems."),(0,r.kt)("p",null,"This lets us do really cool things like run multiple web servers on the same OS without having port conflicts."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Namespaces let you run multiple web servers, each on port 443, on a single OS. To do this you just run each web server app inside of its own ",(0,r.kt)("em",{parentName:"p"},"network namespace"),". This works because each network namespace gets its own IP address and full range of ports."),(0,r.kt)("p",{parentName:"blockquote"},"You can run multiple applications, each requiring their own version of a shared library or configuration file. To do this you run each application inside of its own ",(0,r.kt)("em",{parentName:"p"},"mount namespace"),".")),(0,r.kt)("p",null,"Docker on Linux currenty utilizes the following kernel namespaces:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ProcessID(pid)"),(0,r.kt)("li",{parentName:"ul"},"Network(net)"),(0,r.kt)("li",{parentName:"ul"},"Filesystem/mount(mnt)"),(0,r.kt)("li",{parentName:"ul"},"Inter-process Communication(ipc)"),(0,r.kt)("li",{parentName:"ul"},"User(user)"),(0,r.kt)("li",{parentName:"ul"},"UTS(uts)")),(0,r.kt)("p",null,"Docker containers are an organized collection of namespaces. This means that you get all of this OS isolation for free with every container."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Every container has its own ",(0,r.kt)("em",{parentName:"p"},"pid"),", ",(0,r.kt)("em",{parentName:"p"},"net"),", ",(0,r.kt)("em",{parentName:"p"},"mnt"),", ",(0,r.kt)("em",{parentName:"p"},"ipc"),", ",(0,r.kt)("em",{parentName:"p"},"uts"),", and potentially ",(0,r.kt)("em",{parentName:"p"},"user")," namespace. In fact, an organized collection of these namespaces is what we call a ",(0,r.kt)("em",{parentName:"p"},"container"),".")),(0,r.kt)("p",null,"Let\u2019s briefly look at how Docker uses each namespace:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Process ID namespace"),": Docker uses the ",(0,r.kt)("em",{parentName:"li"},"pid")," namespace to provide isolated process trees for each container. This means every container gets its own PID 1. PID namespaces also mean that one container cannot see or access to the process tree of other containers. Nor can it see or access the process tree of the host it\u2019s running on."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Network namespace"),": Docker uses the ",(0,r.kt)("em",{parentName:"li"},"net")," namespace to provide each container its own isolated network stack. This stack includes; interfaces, IP addresses, port ranges, and routing tables. For example, every container gets its own ",(0,r.kt)("em",{parentName:"li"},"eth0")," interface with its own unique IP and range of ports."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Mount namespace"),": Every container gets its own unique isolated root (/) filesystem. This means every container can have its own ",(0,r.kt)("em",{parentName:"li"},"/etc"),", ",(0,r.kt)("em",{parentName:"li"},"/var"),", ",(0,r.kt)("em",{parentName:"li"},"/dev")," and other important filesystem constructs. Processes inside of a container cannot access the mount namespace of the Linux host or other containers \u2014 they can only see and access their own isolated filesystem."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Inter-process Communication namespace"),": Docker uses the ",(0,r.kt)("em",{parentName:"li"},"ipc")," namespace for shared memory access within a container. It also isolates the container from shared memory outside of the container."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"User namespace"),": Docker lets you use ",(0,r.kt)("em",{parentName:"li"},"user")," namespaces to map users inside of a container to different users on the Linux host. A common example is mapping a container\u2019s root user to a non-root user on the Linux host."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"UTS namespace"),": Docker uses the ",(0,r.kt)("em",{parentName:"li"},"uts")," namespace to provide each container with its own hostname.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Control Groups")),(0,r.kt)("p",null,"If namespaces are about isolation, control groups (cgroups) are about setting limits."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Think of containers as similar to rooms in a hotel. While each room might appear isolated, every room shares a common set of infrastructure resources \u2014 things like water supply, electricity supply, shared swimming pool, shared gym, shared breakfast bar etc. Cgroups let us set limits so that (sticking with the hotel analogy) no single container can use all water or eat everything at the breakfast bar.")),(0,r.kt)("p",null,"In the real world, not the hotel analogy, containers are isolated from each other but all share a common set of OS resources \u2014 things like CPU, RAM, network bandwidth, and disk I/O. Cgroups let us set limits on each of these so a single container cannot consume everything and cause a denial of service (DoS) attack."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Capabilities")),(0,r.kt)("p",null,"It\u2019s a bad idea to run containers as root \u2014 root is all-powerful and therefore very dangerous."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"capabilities")," is a technology that lets us pick and choose which root powers a container needs in order to run."),(0,r.kt)("p",null,"Under the hood, the Linux root user is a combination of a long list of ",(0,r.kt)("em",{parentName:"p"},"capabilities"),"."),(0,r.kt)("p",null,"Docker works with capabilities so that you can run containers as root, but strip out all the capabilities you don't need."),(0,r.kt)("p",null,"This is an excellent example of implementing least privilege \u2014 you get a container running with only the capabilities required. Docker also imposes restrictions so that containers cannot re-add the dropped capabilities."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Mandatory Access Control systems")),(0,r.kt)("p",null,"Docker works with major Linux MAC technologies such as AppArmor and SELinux."),(0,r.kt)("p",null,"Depending on your Linux distribution, Docker applies a default AppArmor profile to all new containers. According to the Docker documentation, this default profile is \u201cmoderately protective while providing wide application compatibility\u201d."),(0,r.kt)("p",null,"Docker also lets you start containers without a policy applied, as well as giving you the ability to customize policies to meet specific requirements. This is also very powerful, but can also be prohibitively complex."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"seccomp")),(0,r.kt)("p",null,"Docker uses seccomp, in filter mode, to limit the syscalls a container can make to the host\u2019s kernel."),(0,r.kt)("p",null,"As per the Docker security philosophy, all new containers get a default seccomp profile configured with sensible defaults. This is intended to provide moderate security without impacting application compatibility."),(0,r.kt)("p",null,"As always, you can customize seccomp profiles, and you can pass a flag to Docker so that containers can be started without a seccomp profile."),(0,r.kt)("h3",{id:"docker-platform-security-technologies"},"Docker platform security technologies"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Security in Swarm Mode")),(0,r.kt)("p",null,"Docker Swarm allows you to cluster multiple Docker hosts and deploy applications declaratively. Every Swarm is comprised of ",(0,r.kt)("em",{parentName:"p"},"managers")," and ",(0,r.kt)("em",{parentName:"p"},"workers")," that can be Linux or Windows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Managers host the control plane of the cluster and are responsible for configuring the cluster and dispatching work tasks."),(0,r.kt)("li",{parentName:"ul"},"Workers are the nodes that run your application code as containers.")),(0,r.kt)("p",null,"As expected, ",(0,r.kt)("em",{parentName:"p"},"swarm mode")," includes many security features that are enabled out-of-the-box with sensible defaults. These include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Cryptographic node IDs"),(0,r.kt)("li",{parentName:"ul"},"TLS for mutual authentication"),(0,r.kt)("li",{parentName:"ul"},"Secure join tokens"),(0,r.kt)("li",{parentName:"ul"},"CA configuration with automatic certificate rotation"),(0,r.kt)("li",{parentName:"ul"},"Encrypted cluster store(config DB)"),(0,r.kt)("li",{parentName:"ul"},"Encrypted networks")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Swarm join tokens"))),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://docs-stage.docker.com/engine/reference/commandline/swarm_join-token/"},"reference")),(0,r.kt)("p",null,"The only thing that is needed to join new managers and workers to an existing swarm is the relevant join token. Join tokens are stored in the cluster store which is encrypted by default."),(0,r.kt)("p",null,"Every swarm maintains two distinct join tokens:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"One for joining new managers"),(0,r.kt)("li",{parentName:"ul"},"One for joining new workers")),(0,r.kt)("p",null,"Every join token is comprised of 4 distinct fields separated by dashes (-):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"PREFIX - VERSION - SWARM ID - TOKEN\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"PREFIX")," is always ",(0,r.kt)("em",{parentName:"p"},"SWMTKN"),". This allows you to pattern-match against it and prevent people from accidentally posting it publicly."),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"VERSION")," field indicates the version of the swarm."),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"Swarm ID")," field is a hash of the swarm\u2019s certificate."),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"TOKEN")," field is the part that determines whether it can join nodes as managers or workers."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# revokes the existing manager join token and issues a new one.\ndocker swarm join-token --rotate worker\n\ndocker swarm join-token --rotate manager\n")),(0,r.kt)("p",null,"Existing managers do not need updating, however, you\u2019ll need to use the new token to add new managers."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"TLS and mutual authentication"))),(0,r.kt)("p",null,"Every manager and worker that joins a swarm is issued a client certificate. This certificate is used for mutual authentication. It identifies the node, the swarm that it\u2019s a member of, and role the node performs in the swarm (manager or worker)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# inspect a node's client certificate\nsudo openssl x509 \\\n  -in /var/lib/docker/swarm/certificates/swarm-node.cert \\\n  -text\n\ndocker system info\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"docker swarm update --cert-expiry 720h\n\ndocker swarm ca --help\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"The cluster store"))),(0,r.kt)("p",null,"The cluster store is the brains of a swarm and is where cluster config and state are stored."),(0,r.kt)("p",null,"The store is currently based on the popular ",(0,r.kt)("inlineCode",{parentName:"p"},"etcd")," distributed database and is automatically configured to replicate itself to all managers in the swarm. It is also encrypted by default."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Detecting vulnerabilities with image security scanning")),(0,r.kt)("p",null,"Image scanners work by inspecting images and searching for packages that have known vulnerabilities. Image scanning is focussed on images and does not detect security problems with networks, nodes, or orchestrators."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Signing and verifying images with Docker Content Trust")),(0,r.kt)("p",null,"Docker Content Trust (DCT) makes it simple and easy to verify the integrity and the publisher of images that you download and run."),(0,r.kt)("p",null,"At a high level, DCT allows developers to sign images when they are pushed to Docker Hub or other container registries. These images can then be verified when they are pulled and ran."),(0,r.kt)("p",null,"DCT can also be used to provide important ",(0,r.kt)("em",{parentName:"p"},"context"),". This includes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"whether an image has been signed for use in a particular environment such as \u201cprod\u201d or \u201cdev\u201d,"),(0,r.kt)("li",{parentName:"ul"},"whether an image has been superseded by a newer version and is therefore stale.")),(0,r.kt)("p",null,"You can force a Docker host to always sign and verify image push and pull operations by exporting the ",(0,r.kt)("inlineCode",{parentName:"p"},"DOCKER_CONTENT_TRUST "),"environment variable with a value of 1. Once DCT is enabled, you\u2019ll no longer be able to pull and work with unsigned images."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"export DOCKER_CONTENT_TRUST=1\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Docker Secrets")),(0,r.kt)("p",null,"Behind the scenes, secrets are encrypted at rest, encrypted in-flight, mounted in containers to in-memory filesystems, and operate under a least-privilege model where they are only made available to services that have been explicitly granted access to them."),(0,r.kt)("p",null,"The reason that secrets are surfaced in their un-encrypted form in running containers is so applications can use them without requiring methods to decrypt them."))}u.isMDXComponent=!0}}]);