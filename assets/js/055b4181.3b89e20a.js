"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5563],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>f});var i=t(67294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,i,l=function(e,n){if(null==e)return{};var t,i,l={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var s=i.createContext({}),u=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},p=function(e){var n=u(e.components);return i.createElement(s.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},m=i.forwardRef((function(e,n){var t=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=u(t),m=l,f=c["".concat(s,".").concat(m)]||c[m]||d[m]||r;return t?i.createElement(f,a(a({ref:n},p),{},{components:t})):i.createElement(f,a({ref:n},p))}));function f(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var r=t.length,a=new Array(r);a[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[c]="string"==typeof e?e:l,a[1]=o;for(var u=2;u<r;u++)a[u]=t[u];return i.createElement.apply(null,a)}return i.createElement.apply(null,t)}m.displayName="MDXCreateElement"},91571:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>a,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>u});var i=t(87462),l=(t(67294),t(3905));const r={title:"11 Conditionals",tags:["lisp","interpreter"]},a=void 0,o={unversionedId:"lisp-interpreter-in-c/conditionals",id:"lisp-interpreter-in-c/conditionals",title:"11 Conditionals",description:"document",source:"@site/docs/lisp-interpreter-in-c/11-conditionals.md",sourceDirName:"lisp-interpreter-in-c",slug:"/lisp-interpreter-in-c/conditionals",permalink:"/docs/lisp-interpreter-in-c/conditionals",draft:!1,tags:[{label:"lisp",permalink:"/docs/tags/lisp"},{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",sidebarPosition:11,frontMatter:{title:"11 Conditionals",tags:["lisp","interpreter"]},sidebar:"tutorialSidebar",previous:{title:"10 Functions",permalink:"/docs/lisp-interpreter-in-c/functions"},next:{title:"12 Strings",permalink:"/docs/lisp-interpreter-in-c/strings"}},s={},u=[{value:"Ordering",id:"ordering",level:2},{value:"Equality",id:"equality",level:2},{value:"If Function",id:"if-function",level:2},{value:"Recursive Functions",id:"recursive-functions",level:2}],p={toc:u};function c(e){let{components:n,...r}=e;return(0,l.kt)("wrapper",(0,i.Z)({},p,r,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"http://www.buildyourownlisp.com/chapter13_conditionals"},"document")),(0,l.kt)("p",null,"codes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{target:"_blank",href:t(59860).Z},"conditionals.c"))),(0,l.kt)("p",null,"This is a fairly short chapter and essentially consists of adding a couple of new builtin functions to deal with comparison and ordering."),(0,l.kt)("p",null,"Define some new builtin functions for ",(0,l.kt)("strong",{parentName:"p"},"greater than"),", ",(0,l.kt)("strong",{parentName:"p"},"less than"),", ",(0,l.kt)("strong",{parentName:"p"},"equal to")," and all the other comparison operators we use in C."),(0,l.kt)("p",null,"Try to define an ",(0,l.kt)("inlineCode",{parentName:"p"},"if")," function that tests for some condition and then either evaluate some code, or some other code, depending on the result."),(0,l.kt)("h2",{id:"ordering"},"Ordering"),(0,l.kt)("p",null,"For simplicity's sake I'm going to re-use the number data type to represent the result of comparisons. I'll make a rule similar to C, to say that any number that isn't ",(0,l.kt)("inlineCode",{parentName:"p"},"0")," evaluates to true in an ",(0,l.kt)("inlineCode",{parentName:"p"},"if")," statement, while ",(0,l.kt)("inlineCode",{parentName:"p"},"0")," always evaluates to false."),(0,l.kt)("p",null,"Therefore, our ordering functions are a little like a simplified version of the arithmetic functions. They'll only work on numbers, and we only want them to work on two arguments."),(0,l.kt)("p",null,"If these error conditions are met the maths is simple. We want to return a number ",(0,l.kt)("inlineCode",{parentName:"p"},"lval")," either ",(0,l.kt)("inlineCode",{parentName:"p"},"0")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"1")," depending on the equality comparison between the two input ",(0,l.kt)("inlineCode",{parentName:"p"},"lval"),". We can use C's comparison operators to do this. Like the arithmetic functions we'll make use of a single function to do all comparisons."),(0,l.kt)("p",null,"First we check the error conditions, then we compare the numbers in each of the arguments to get some result. Finally, we return this result as a number value."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},'lval* builtin_ord(lenv* e, lval* a, char* op) {\n    LASSERT_NUM(op, a, 2);\n    LASSERT_TYPE(op, a, 0, LVAL_NUM);\n    LASSERT_TYPE(op, a, 1, LVAL_NUM);\n\n    int r;\n    if (strcmp(op, ">") == 0) {\n        r = ( a->cell[0]->num > a->cell[1]->num );\n    }\n    if (strcmp(op, "<") == 0) {\n        r = ( a->cell[0]->num < a->cell[1]->num );\n    }\n    if (strcmp(op, ">=") == 0) {\n        r = ( a->cell[0]->num >= a->cell[1]->num );\n    }\n    if (strcmp(op, "<=") == 0) {\n        r = ( a->cell[0]->num <= a->cell[1]->num );\n    }\n\n    lval_del(a);\n    return lval_num(r);\n}\n\nlval* builtin_gt(lenv* e, lval* a) {\n    return builtin_ord(e, a, ">");\n}\n\nlval* builtin_lt(lenv* e, lval* a) {\n    return builtin_ord(e, a, "<");\n}\n\nlval* builtin_ge(lenv* e, lval* a) {\n    return builtin_ord(e, a, ">=");\n}\n\nlval* builtin_le(lenv* e, lval* a) {\n    return builtin_ord(e, a, "<=");\n}\n')),(0,l.kt)("h2",{id:"equality"},"Equality"),(0,l.kt)("p",null,"Equality is going to be different to ordering because we want it to work on more than number types. It will be useful to see if an input is equal to an empty list, or to see if two functions passed in are the same. Therefore, we need to define a function which can test for equality between two different types of ",(0,l.kt)("inlineCode",{parentName:"p"},"lval"),"."),(0,l.kt)("p",null,"This function essentially checks that all the field which make up the data for a particular ",(0,l.kt)("inlineCode",{parentName:"p"},"lval")," type are equal. If all the fields are equal, the whole thing is considered equal. Otherwise, if there are any differences the whole thing is considered unequal."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"int lval_eq(lval* x, lval* y) {\n    if (x->type != y->type) { return 0; }\n\n    switch (x->type) {\n        case LVAL_NUM: return (x->num == y->num);\n\n        case LVAL_ERR: return (strcmp(x->err, y->err) == 0);\n        case LVAL_SYM: return (strcmp(x->sym, y->sym) == 0);\n\n        case LVAL_FUN:\n            if (x->builtin || y->builtin) {\n                return (x->builtin == y->builtin);\n            } else {\n                return lval_eq(x->formals, y->formals) && lval_eq(x->body, y->body);\n            }\n\n        case LVAL_QEXPR:\n        case LVAL_SEXPR:\n            if (x->count != y->count) { return 0; }\n            for (int i=0; i < x->count; i++) {\n                if (!lval_eq(x->cell[i], y->cell[i])) { return 0; }\n            }\n            return 1;\n        break;\n    }\n\n    return 0;\n}\n")),(0,l.kt)("p",null,"Using this function the new builtin function for equality comparison is very simple to add. We simply ensure two arguments are input, and that they are equal. We store the result of the comparison into a new ",(0,l.kt)("inlineCode",{parentName:"p"},"lval")," and return it."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},'lval* builtin_cmp(lenv* e, lval* a, char* op) {\n    LASSERT_NUM(op, a, 2);\n\n    int r;\n\n    if (strcmp(op, "==") == 0) {\n        r = lval_eq(a->cell[0], a->cell[1]);\n    }\n    if (strcmp(op, "!=") == 0) {\n        r = !lval_eq(a->cell[0], a->cell[1]);\n    }\n    lval_del(a);\n    return lval_num(r);\n}\n\nlval* builtin_eq(lenv* e, lval* a) {\n    return builtin_cmp(e, a, "==");\n}\n\nlval* builtin_ne(lenv* e, lval* a) {\n    return builtin_cmp(e, a, "!=");\n}\n')),(0,l.kt)("h2",{id:"if-function"},"If Function"),(0,l.kt)("p",null,"To make the comparison operators useful we'll need an ",(0,l.kt)("inlineCode",{parentName:"p"},"if")," function. This function is a little like the ternary operation in C. Upon some condition being true it evaluates to one thing, and if the condition is false, it evaluates to another."),(0,l.kt)("p",null,"We can again make use of Q-Expressions to encode a computation. First we get the user to pass in the result of a comparison, then we get the user to pass in two Q-Expressions representing the code to be evaluated upon a condition being either true or false."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},'lval* builtin_if(lenv* e, lval* a) {\n    LASSERT("if", a, 3);\n    LASSERT_TYPE("if", a, 0, LVAL_NUM);\n    LASSERT_TYPE("if", a, 1, LVAL_QEXPR);\n    LASSERT_TYPE("if", a, 2, LVAL_QEXPR);\n\n    lval* x;\n    a->cell[1]->type = LVAL_SEXPR;\n    a->cell[2]->type = LVAL_SEXPR;\n\n    if (a->cell[0]->num) {\n        x = lval_eval(e, lval_pop(a, 1));\n    } else {\n        x = lval_eval(e, lval_pop(a, 2));\n    }\n\n    lval_del(a);\n\n    return x;\n}\n\n// don\'t forget to register all of these builtins\nlenv_add_builtin(e, "if", builtin_if);\nlenv_add_builtin(e, "==", builtin_eq);\nlenv_add_builtin(e, "!=", builtin_ne);\nlenv_add_builtin(e, ">",  builtin_gt);\nlenv_add_builtin(e, "<",  builtin_lt);\nlenv_add_builtin(e, ">=", builtin_ge);\nlenv_add_builtin(e, "<=", builtin_le);\n')),(0,l.kt)("h2",{id:"recursive-functions"},"Recursive Functions"),(0,l.kt)("p",null,"By introducing conditionals we've actually made the language a lot more powerful. This is because they effectively let us implement recursive functions."),(0,l.kt)("p",null,"Recursive functions are those which call themselves. We've used these already in C to perform reading in and evaluation of expressions. The reason we require conditionals for them is that they let us test for the situation where we wish to terminate the recursion."),(0,l.kt)("p",null,"For example, we can use conditionals to implement a function ",(0,l.kt)("inlineCode",{parentName:"p"},"len")," which tells us the number of items in a list. If we encounter the empty list we just return ",(0,l.kt)("inlineCode",{parentName:"p"},"0"),". Otherwise, we return the length of the ",(0,l.kt)("inlineCode",{parentName:"p"},"tail")," of the input list, plus ",(0,l.kt)("inlineCode",{parentName:"p"},"1"),". It repeatedly uses the ",(0,l.kt)("inlineCode",{parentName:"p"},"len")," function until it reaches the empty list. At this point it returns ",(0,l.kt)("inlineCode",{parentName:"p"},"0")," and adds all the other partial results together."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"(fun {len l} {\n    if ( == l {})\n        {0}\n        {+ 1 (len (tail l)}\n})\n")),(0,l.kt)("p",null,"Just as in C, there is a pleasant symmetry to this sort of recursive function. First we do something for the empty list (the base case). Then if we get something bigger, we take off a chunk such as the head of the list, and do something to it, before combining it with the rest of the thing to which the function has been already applied."))}c.isMDXComponent=!0},59860:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/files/conditionals-baa61ddbcdf5d22f1e5912738c5a193b.c"}}]);