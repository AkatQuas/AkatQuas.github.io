"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[460],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>k});var o=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=o.createContext({}),s=function(e){var n=o.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=s(e.components);return o.createElement(c.Provider,{value:n},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=s(t),d=a,k=p["".concat(c,".").concat(d)]||p[d]||m[d]||r;return t?o.createElement(k,i(i({ref:n},u),{},{components:t})):o.createElement(k,i({ref:n},u))}));function k(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=d;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l[p]="string"==typeof e?e:a,i[1]=l;for(var s=2;s<r;s++)i[s]=t[s];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},97324:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var o=t(87462),a=(t(67294),t(3905));const r={title:"React Hooks Review",categories:["frontend"],tags:["frontend","reactjs","hooks"]},i=void 0,l={permalink:"/blog/2021/04/16/react-hooks-review",source:"@site/blog/2021-04-16-react-hooks-review.md",title:"React Hooks Review",description:"Recently, I get a little confused on how React hooks executes, and this is what I have summarized.",date:"2021-04-16T00:00:00.000Z",formattedDate:"April 16, 2021",tags:[{label:"frontend",permalink:"/blog/tags/frontend"},{label:"reactjs",permalink:"/blog/tags/reactjs"},{label:"hooks",permalink:"/blog/tags/hooks"}],readingTime:4.52,hasTruncateMarker:!0,authors:[],frontMatter:{title:"React Hooks Review",categories:["frontend"],tags:["frontend","reactjs","hooks"]},prevItem:{title:"Test-Driven Development in FrontEnd",permalink:"/blog/2021/05/06/tdd-in-frontend"},nextItem:{title:"Micro Frontends",permalink:"/blog/2021/04/11/micro-frontend"}},c={authorsImageUrls:[]},s=[{value:"Get started",id:"get-started",level:2},{value:"Summary",id:"summary",level:2},{value:"References",id:"references",level:2}],u={toc:s};function p(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,o.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Recently, I get a little confused on how React hooks executes, and this is what I have summarized."),(0,a.kt)("p",null,"During the process of delving, I come across some knowledge on how V8 deals with function compilation, since we would have lots of anonymous functions (closures in some cases) defined whilst using hooks."),(0,a.kt)("h2",{id:"get-started"},"Get started"),(0,a.kt)("p",null,"Imagine we have a class component like the following one."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"class Counter extends React.Component {\n  state = {\n    counter: 1,\n  };\n  render() {\n    const { counter } = this.state;\n    return (\n      <>\n        <p>current value: {counter}</p>\n        {/* anonymous function */}\n        <button onClick={() => this.setState({ counter: counter + 1 })}>\n          Increment\n        </button>\n      </>\n    );\n  }\n}\n")),(0,a.kt)("p",null,"It's obvious that ",(0,a.kt)("inlineCode",{parentName:"p"},"button")," would receive a new click callback after every ",(0,a.kt)("inlineCode",{parentName:"p"},"render"),"."),(0,a.kt)("p",null,"To avoid repeatedly generating the ",(0,a.kt)("inlineCode",{parentName:"p"},"onClick")," anonymous function, so we have another style of function definition."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"In V8, the anonymous function is only parsed once, but allocated every time execution hits the code. So we have different function every time the code runs.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"class Counter extends React.Component {\n  state = {\n    counter: 1,\n  };\n  // class method\n  increment = () => {\n    const { counter } = this.state;\n    this.setState({\n      counter: counter + 1,\n    });\n  };\n  render() {\n    const { counter } = this.state;\n    return (\n      <>\n        <p>current value: {counter}</p>\n        {/* reference to the class method */}\n        <button onClick={this.increment}>Increment</button>\n      </>\n    );\n  }\n}\n")),(0,a.kt)("p",null,"In Functional Components, we have similar situation."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const Counter = () => {\n  const [counter, setCounter] = React.useState(1);\n  return (\n    <>\n      <p>current value: {counter}</p>\n      {/* anonymous function */}\n      <button onClick={() => setCounter(counter)}>Increment</button>\n    </>\n  );\n};\n")),(0,a.kt)("p",null,"Still, ",(0,a.kt)("inlineCode",{parentName:"p"},"button")," would receive a new click callback after every ",(0,a.kt)("inlineCode",{parentName:"p"},"render"),"."),(0,a.kt)("p",null,"Here comes the ",(0,a.kt)("inlineCode",{parentName:"p"},"useCallback")," to rescue."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const Counter = () => {\n  const [counter, setCounter] = React.useState(1);\n  const onClick = React.useCallback(() => {\n    setCounter(counter + 1);\n  }, [counter]);\n  return (\n    <>\n      <p>current value: {counter}</p>\n      <button onClick={onClick}>Increment</button>\n    </>\n  );\n};\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"useCallback")," would return the same function as long as the dependency ",(0,a.kt)("inlineCode",{parentName:"p"},"counter")," doesn't change."),(0,a.kt)("p",null,"So the VDOM reference stays untouched even if the function component gets re-rendered."),(0,a.kt)("p",null,"Now, we are going to look at a more complicated situation."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const Counter = () => {\n  const [counter, setCounter] = React.useState(1);\n  const [tip, setTip] = React.useState('first tip');\n\n  const onClick = React.useCallback(() => {\n    setCounter(counter + 1);\n  }, [counter]);\n\n  React.useEffect(() => {\n    setTip('second tip');\n  }, []);\n\n  const [heavy, setHeavy] = React.useState({\n    a: {},\n    // ... some huge object\n    z: {},\n  });\n\n  return (\n    <>\n      <p>current tip: {tip}</p>\n      <p>current value: {counter}</p>\n      <button onClick={onClick}>Increment</button>\n    </>\n  );\n};\n")),(0,a.kt)("p",null,"It's guaranteed there would be two ",(0,a.kt)("inlineCode",{parentName:"p"},"render")," invocations. Here come the questions\uff1a"),(0,a.kt)("p",null,"Question 1. Will the ",(0,a.kt)("inlineCode",{parentName:"p"},"onClick")," functions equal to each other during these two invocations?"),(0,a.kt)("details",null,(0,a.kt)("summary",null,"My Opinion"),(0,a.kt)("p",null,"They are same functions.\n",(0,a.kt)("inlineCode",{parentName:"p"},"useCallback")," would return the same function as long as the dependency ",(0,a.kt)("inlineCode",{parentName:"p"},"counter")," doesn't change. Internally, ",(0,a.kt)("inlineCode",{parentName:"p"},"hook.memoizedState")," is not updated, so the same function is returned from same ",(0,a.kt)("inlineCode",{parentName:"p"},"memoizedState"),".")),(0,a.kt)("p",null,"Question 2. Will ",(0,a.kt)("inlineCode",{parentName:"p"},"React.useCallback")," execute twice? Will each execution receive same arguments (anonymous function)?"),(0,a.kt)("details",null,(0,a.kt)("summary",null,"My Opinion"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"useCallback")," is just a plain normal JavaScript function, so it executes twice."),(0,a.kt)("p",null,"However, the arguments are different. There will be a newly allocated local function in every execution.")),(0,a.kt)("p",null,"Question 3. Will ",(0,a.kt)("inlineCode",{parentName:"p"},"React.useEffect")," execute twice? Will each execution receive same arguments (anonymous function)?"),(0,a.kt)("details",null,(0,a.kt)("summary",null,"My Opinion"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," is just a plain normal JavaScript function, so it executes twice."),(0,a.kt)("p",null,"And, each execution is invoked with a brand new allocated local function. Internally, ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," would adjust the effect flag in ",(0,a.kt)("inlineCode",{parentName:"p"},"hook.memoizedState")," according to the dependencies.")),(0,a.kt)("p",null,"Question 4. Will ",(0,a.kt)("inlineCode",{parentName:"p"},"React.useState")," execute twice? Will each execution receive same arguments (a large object)?"),(0,a.kt)("details",null,(0,a.kt)("summary",null,"My Opinion"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"useState")," is just a plain normal JavaScript function, so it executes twice."),(0,a.kt)("p",null,"Internally, ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," would memorize the value in the first execution. The arguments is ignored in the rest executions."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"useState")," would receive a new allocated large object as arguments on each execution. And this object is eligible to be collected (Garbage collection) after execution.")),(0,a.kt)("p",null,"Question 5. What's point of using these ",(0,a.kt)("inlineCode",{parentName:"p"},"useCallback"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"useMemo"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," hooks? What we could do if the arguments are different?"),(0,a.kt)("details",null,(0,a.kt)("summary",null,"My Opinion"),(0,a.kt)("p",null,"hooks invocation is required by ",(0,a.kt)("em",{parentName:"p"},"React fiber reconciliation"),"."),(0,a.kt)("p",null,"Without these hooks invocation, React is unable to trace these ",(0,a.kt)("em",{parentName:"p"},"local variables/closure objects"),". So React cannot perform ",(0,a.kt)("em",{parentName:"p"},"reconciliation")," actively upon these objects' mutations."),(0,a.kt)("p",null,"With the help of these tracing, React fiber keeps its references solid, avoiding unnecessary reconciliation."),(0,a.kt)("p",null,"The function component might re-render and return a new VDOM. However, there will be no difference during VDOM diff comparison sine their references are same. This would result no DOM update execution, which is skipped."),(0,a.kt)("p",null,"The following example is more persuasive\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const Child = ({ onClick }) => <button onClick={onClick}>Click me!</button>;\n\nconst ParentWithoutHooks = () => {\n  const handleClick = function () {\n    console.log('clicked');\n  };\n  // whenever parent re-renders,\n  // the Child is forced to rerender\n  // since handleClick is a new function after every render\n  return (\n    <>\n      <Child onClick={handleClick} />\n    </>\n  );\n};\n\nconst ParentWithHooks = () => {\n  const handleClick = React.useCallback(\n    function () {\n      console.log('clicked');\n    },\n    [\n      /* dependencies if necessary */\n    ]\n  );\n  // when the parent re-renders,\n  // in an optimistic situation,\n  // Child is only re-rendered if onClick is changed\n  return (\n    <>\n      <Child onClick={handleClick} />\n    </>\n  );\n};\n"))),(0,a.kt)("h2",{id:"summary"},"Summary"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Most of the time it does not matter. Pay more attention to the business.")),(0,a.kt)("h2",{id:"references"},"References"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://stackoverflow.com/a/36530072"},"Function compilation mechanism in V8")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://mrale.ph/blog/2012/09/23/grokking-v8-closures-for-fun.html"},"V8 closures"))))}p.isMDXComponent=!0}}]);