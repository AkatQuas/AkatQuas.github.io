"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4114],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),c=p(n),f=a,h=c["".concat(l,".").concat(f)]||c[f]||u[f]||o;return n?r.createElement(h,s(s({ref:t},d),{},{components:n})):r.createElement(h,s({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=f;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[c]="string"==typeof e?e:a,s[1]=i;for(var p=2;p<o;p++)s[p]=n[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},22394:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var r=n(87462),a=(n(67294),n(3905));const o={title:"07",tags:["lisp","interpreter"]},s=void 0,i={unversionedId:"lisp-interpreter-in-py/chapter-07",id:"lisp-interpreter-in-py/chapter-07",title:"07",description:"Up until now, we had our interpreter and parser code mixed together and the interpreter would evaluate an expression as soon as the parser recognized a certain language construct like addition, subtraction, multiplication, or division. Such interpreters are called syntax-directed interpreters. They usually make a single pass over the input and are suitable for basic language applications. In order to analyze more complex Pascal programming language constructs, we need to build an intermediate representation (IR). Our parser will be responsible for building an IR and our interpreter will use it to interpret the input represented as the IR.",source:"@site/docs/lisp-interpreter-in-py/chapter-07.md",sourceDirName:"lisp-interpreter-in-py",slug:"/lisp-interpreter-in-py/chapter-07",permalink:"/docs/lisp-interpreter-in-py/chapter-07",draft:!1,tags:[{label:"lisp",permalink:"/docs/tags/lisp"},{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",frontMatter:{title:"07",tags:["lisp","interpreter"]},sidebar:"tutorialSidebar",previous:{title:"06",permalink:"/docs/lisp-interpreter-in-py/chapter-06"},next:{title:"08",permalink:"/docs/lisp-interpreter-in-py/chapter-08"}},l={},p=[],d={toc:p};function c(e){let{components:t,...o}=e;return(0,a.kt)("wrapper",(0,r.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Up until now, we had our interpreter and parser code mixed together and the interpreter would evaluate an expression as soon as the parser recognized a certain language construct like addition, subtraction, multiplication, or division. Such interpreters are called ",(0,a.kt)("em",{parentName:"p"},"syntax-directed")," interpreters. They usually make a single pass over the input and are suitable for basic language applications. In order to analyze more complex Pascal programming language constructs, we need to build an ",(0,a.kt)("em",{parentName:"p"},"intermediate representation (IR)"),". Our parser will be responsible for building an IR and our interpreter will use it to interpret the input represented as the ",(0,a.kt)("em",{parentName:"p"},"IR"),"."),(0,a.kt)("p",null,"It turns out that a tree is a very suitable data structure for an IR."),(0,a.kt)("p",null,"Let's quickly talk about tree terminology."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A tree is a data structure that consists of one or more nodes organized into a hierarchy."),(0,a.kt)("li",{parentName:"ul"},"The tree has one root, which is the top node."),(0,a.kt)("li",{parentName:"ul"},"All nodes except the root have a unique parent."),(0,a.kt)("li",{parentName:"ul"},"The node labeled ","*"," in the picture below is a parent. Nodes labeled 2 and 7 are its children; children are ordered from left to right."),(0,a.kt)("li",{parentName:"ul"},"A node with no children is called a leaf node."),(0,a.kt)("li",{parentName:"ul"},"A node that has one or more children and that is not the root is called an interior node."),(0,a.kt)("li",{parentName:"ul"},"The children can also be complete subtrees. In the picture below the left child (labeled ","*",") of the + node is a complete subtree with its own children."),(0,a.kt)("li",{parentName:"ul"},"In computer science we draw trees upside down starting with the root node at the top and branches growing downward.")),(0,a.kt)("p",null,"Here is a tree for the expression 2 ","*"," 7 + 3 with explanations:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part7_tree_terminology.png",alt:""}),(0,a.kt)("p",null,"The IR we'll use throughout the series is called an ",(0,a.kt)("em",{parentName:"p"},"abstract-syntax tree AST"),". But before digging deeper, let's talk about ",(0,a.kt)("em",{parentName:"p"},"parse trees")," briefly. Though we're not going to use parse trees for our interpreter and compiler, they can help you understand how your parser interpreted the input by visualizing the execution trace of the parser. We'll also compare them with ASTs to see why ASTs are better suited for intermediate representation than parse trees."),(0,a.kt)("p",null,"So, what is a parse tree? A ",(0,a.kt)("em",{parentName:"p"},"parse-tree")," (sometimes called a ",(0,a.kt)("em",{parentName:"p"},"concrete syntax tree"),") is a tree that represents the syntactic structure of a language construct according to our grammar definition. It basically shows how your parser recognized the language construct or, in other words, it shows how the start symbol of your grammar derives a certain string in the programming language."),(0,a.kt)("p",null,"The call stack of the parser implicitly represents a parse tree and it's automatically built in memory by your parser as it is trying to recognize a certain language construct."),(0,a.kt)("p",null,"Let's take a look at a parse tree for the expression 2 ","*"," 7 + 3:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part7_tree_terminology.png",alt:""}),(0,a.kt)("p",null,"In the picture above you can see that:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The parse tree records a sequence of rules the parser applies to recognize the input."),(0,a.kt)("li",{parentName:"ul"},"The root of the parse tree is labeled with the grammar start symbol."),(0,a.kt)("li",{parentName:"ul"},"Each interior node represents a non-terminal, that is it represents a grammar rule application, like ",(0,a.kt)("em",{parentName:"li"},"expr, term"),", or ",(0,a.kt)("em",{parentName:"li"},"factor")," in our case."),(0,a.kt)("li",{parentName:"ul"},"Each leaf node represents a token.")),(0,a.kt)("p",null,"As already mentioned, we're not going to manually construct parser trees and use them for our interpreter but parse trees can help you understand how the parser interpreted the input by visualizing the parser call sequence."),(0,a.kt)("p",null,"Now let's talk about ",(0,a.kt)("em",{parentName:"p"},"abstract-syntax trees"),". This is the ",(0,a.kt)("em",{parentName:"p"},"intermediate representation (IR)")," that we'll heavily use throughout the rest of the series. It is one of the central data strictures for our interpreter and future compiler projects."),(0,a.kt)("p",null,"Here are the main differences between ASTs and Parse trees:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"ASTs uses operators/operations as root and interior nodes and it uses operands as their children."),(0,a.kt)("li",{parentName:"ul"},"ASTs do not use interior nodes to represent a grammar rule, unlike the parse tree does."),(0,a.kt)("li",{parentName:"ul"},"ASTs don't represent every detail from the real syntax (that's why they're called ",(0,a.kt)("em",{parentName:"li"},"abstract"),") - no rule nodes and no parentheses."),(0,a.kt)("li",{parentName:"ul"},"ASTs are dense compared to a parse tree for the same language construct.")),(0,a.kt)("p",null,"So, what is an abstract syntax tree? An ",(0,a.kt)("em",{parentName:"p"},"abstract syntax tree (AST)")," is a tree that represents the abstract syntactic structure of a language construct where each interior node and the root node represents an operator, and the children of the node represent the operands of that operator."),(0,a.kt)("p",null,"ASTs are more compact than parse trees. Just take a look at an AST and a parse tree for the expression ",(0,a.kt)("em",{parentName:"p"},"7 + (( 2 + 3 ))"),". The following AST is much smaller than the parse tree, but still captures the essence of the input:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part7_ast_02.png",alt:""}),(0,a.kt)("p",null,'How to encode operator precedence in an AST? In order to encode the operator precedence in AST to represent that "X happens before Y", you just need to put X lower in the tree than Y.'),(0,a.kt)("p",null,"More examples:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part7_astprecedence_01.png",alt:""}),(0,a.kt)("img",{src:"./imgs/lsbasi_part7_astprecedence_02.png",alt:""}),(0,a.kt)("p",null,"From the pictures above, it's obvious that operators with higher precedence end up being lower in the tree."),(0,a.kt)("p",null,"Now it's time to write some code to implement different AST node types and modify our parser to generate an AST tree composed of those nodes."),(0,a.kt)("p",null,"First, we'll create a base node class called AST that other classes will inherit from:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"class AST(object):\n    pass\n")),(0,a.kt)("p",null,"ASTs represent the operator-operand model."),(0,a.kt)("p",null,"So far, we have four operators and integer operands. The operators are addition, subtraction, multiplication, and division. We could have created a separate class to represent each operator like ",(0,a.kt)("em",{parentName:"p"},"AddNode, SubNode, MulNode"),", and ",(0,a.kt)("em",{parentName:"p"},"DivNode"),", but instead we're going to have only one ",(0,a.kt)("em",{parentName:"p"},"BinOp")," class to represent all four binary operators (a binary operator is an operator that operates on two operands):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"class BinOp(AST):\n    def __init__(self, left, op, right):\n        self.left = left\n        self.token = self.op = op\n        self.right = right\n")),(0,a.kt)("p",null,"The parameters to the constructor are ",(0,a.kt)("em",{parentName:"p"},"left, op, right"),", where ",(0,a.kt)("em",{parentName:"p"},"left")," and ",(0,a.kt)("em",{parentName:"p"},"right")," point correspondingly to the node of the left operand and to the node of the right operand. ",(0,a.kt)("em",{parentName:"p"},"Op")," holds a token for the operator itself: Token(PLUS, \u2018+') for the plus operator, Token(MINUS, \u2018-\u2018) for the minus operator, and so on."),(0,a.kt)("p",null,"To represent integers in our AST, we'll define a class ",(0,a.kt)("em",{parentName:"p"},"Num")," that will hold an INTEGER token and the token's value:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"class Num(AST):\n    def __init__(self, token):\n        self.token = token\n        self.value = token.value\n")),(0,a.kt)("p",null,"As you've noticed, all nodes store the token used to create the node. This is mostly for convenience and it will come in handy in the future."),(0,a.kt)("p",null,"Here is an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"# 2 * 7 + 3\nmul_token = Token(MUL, '*')\nplus_token = Token(PLUS, '+')\nmul_node = BinOp(\n    left=Num(Token(INTEGER, 2)),\n    op=mul_token,\n    right=Num(Token(INTEGER, 7))\n)\nadd_node = BinOp(\n    left=mul_node,\n    op=plus_token,\n    right=Num(Token(INTEGER, 3))\n)\n")),(0,a.kt)("img",{src:"./imgs/lsbasi_part7_astimpl_01.png",alt:""}),(0,a.kt)("p",null,"Here is our modified parser code that builds and returns an AST as a result of recognizing the input (an arithmetic expression):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'class AST(object):\n    pass\n\n\nclass BinOp(AST):\n    def __init__(self, left, op, right):\n        self.left = left\n        self.token = self.op = op\n        self.right = right\n\n\nclass Num(AST):\n    def __init__(self, token):\n        self.token = token\n        self.value = token.value\n\n\nclass Parser(object):\n    def __init__(self, lexer):\n        self.lexer = lexer\n        # set current token to the first token taken from the input\n        self.current_token = self.lexer.get_next_token()\n\n    def error(self):\n        raise Exception(\'Invalid syntax\')\n\n    def eat(self, token_type):\n        # compare the current token type with the passed token\n        # type and if they match then "eat" the current token\n        # and assign the next token to the self.current_token,\n        # otherwise raise an exception.\n        if self.current_token.type == token_type:\n            self.current_token = self.lexer.get_next_token()\n        else:\n            self.error()\n\n    def factor(self):\n        """ factor : INTEGER | LPAREN expr RPAREN """\n        token = self.current_token\n        if token.type == INTEGER:\n            self.eat(INTEGER)\n            return Num(token)\n        elif token.type == LPAREN:\n            self.eat(LPAREN)\n            node = self.expr()\n            self.eat(RPAREN)\n            return node\n\n    def term(self):\n        """ term : factor ((MUL | DIV))* """\n        node = self.factor()\n\n        while self.current_token.type in (MUL, DIV):\n            token = self.current_token\n            if token.type == MUL:\n                self.eat(MUL)\n            elif token.type == DIV:\n                self.eat(DIV)\n\n            node = BinOp(left=node, op=token, right=self.factor())\n\n        return node\n\n    def expr(self):\n        """\n        expr   : term ((PLUS | MINUS) term)*\n        term   : factor ((MUL | DIV) factor)*\n        factor : INTEGER | LPAREN expr RPAREN\n        """\n        node = self.term()\n\n        while self.current_token.type in (PLUS, MINUS):\n            token = self.current_token\n            if token.type == PLUS:\n                self.eat(PLUS)\n            elif token.type == MINUS:\n                self.eat(MINUS)\n\n            node = BinOp(left=node, op=token, right=self.factor())\n\n        return node\n\n    def parse(self):\n        return self.expr()\n')),(0,a.kt)("p",null,"If you look at the parser code above you can see that the way it builds nodes of an AST is that each BinOp node adopts the current value of the node variable as its left child and the result of a call to a term or factor as its right child, so it's effectively pushing down nodes to the left."),(0,a.kt)("p",null,"Here is a visual representation how the parser gradually builds an AST for the expression 1 + 2 + 3 + 4 + 5:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part7_astimpl_02.png",alt:""}),(0,a.kt)("p",null,"How do you navigate the tree to properly evaluate the expression represented by that tree? You do that by using a ",(0,a.kt)("em",{parentName:"p"},"postorder traversal")," - a special case of ",(0,a.kt)("em",{parentName:"p"},"depth-first traversal")," - which starts at the root node and recursively visits the children of each node from left to right. The postorder traversal visits nodes as far away from the root as fast as it can."),(0,a.kt)("img",{src:"./imgs/lsbasi_part7_ast_walking_01.png",alt:""}),(0,a.kt)("p",null,"Here is a pseudo code for the postorder traversal where ",(0,a.kt)("inlineCode",{parentName:"p"},"<<postorder actions>>")," is a placeholder for action like addition, substraction, multiplication, or division for a ",(0,a.kt)("em",{parentName:"p"},"BinOp node")," or a simpler action like returning the integer value of a ",(0,a.kt)("em",{parentName:"p"},"Num node"),"."),(0,a.kt)("img",{src:"./imgs/lsbasi_part7_ast_visit_postorder.png",alt:""}),(0,a.kt)("p",null,"The reason we're going to use a postorder traversal for our interpreter is that first, we need to evaluate interior nodes lower in the tree because they represent operators with higher precedence and second, we need to evaluate operands of an operator before applying the operator to those operands."),(0,a.kt)("p",null,"In the picture below, you can see that with postorder traversal we first evaluate the expression 2 ","*"," 7 and only after that we evaluate 14 + 3, which gives us the correct result, 17:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part7_ast_walking_02.png",alt:""}),(0,a.kt)("p",null,"Okay, let's write some code to visit and interpret the abstract syntax trees built by our parser, shall we?"),(0,a.kt)("p",null,"Here is the source code that implements the Visitor pattern:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"class NodeVisitor(object):\n    def visit(self, node):\n        method_name = 'visit_' + type(node).__name__\n        visitor = getattr(self, method_name, self.generic_visit)\n        return visitor(node)\n\n    def generic_visit(self, node):\n        raise Exception('No visit_{} method'.format(type(node).__name__))\n")),(0,a.kt)("p",null,"And here is the source code of our ",(0,a.kt)("em",{parentName:"p"},"Interpreter")," class that inherits from the ",(0,a.kt)("em",{parentName:"p"},"NodeVisitor")," class and implements different methods that have the form ",(0,a.kt)("em",{parentName:"p"},"visit_NodeType"),", where ",(0,a.kt)("em",{parentName:"p"},"NodeType")," is replaced with the node's class name like ",(0,a.kt)("em",{parentName:"p"},"BinOp, Num"),", and so on:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"class Interpreter(NodeVisitor):\n    def __init__(self,parser):\n        self.parser = parser\n\n    def visit_BinOp(self, node):\n        if node.op.type == PLUS:\n            return self.visit(node.left) + self.visit(node.right)\n        elif node.op.type == MINUS:\n            return self.visit(node.left) - self.visit(node.right)\n        elif node.op.type == MUL:\n            return self.visit(node.left) * self.visit(node.right)\n        elif node.op.type == DIV:\n            return self.visit(node.left) / self.visit(node.right)\n\n    def visit_Num(self, node):\n        return node.value\n")),(0,a.kt)("p",null,"There are two interesting things about the code that are worth mentioning:"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"First"),", the visitor code that manipulates AST nodes is decoupled from the AST nodes themselves. You can see that none of the AST node classes (BinOp and Num) provide any code to manipulate the data stored in those nodes. That logic is encapsulated in the ",(0,a.kt)("em",{parentName:"p"},"Interpreter")," class that implements the ",(0,a.kt)("em",{parentName:"p"},"NodeVisitor")," class."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Second"),", instead of a giant ",(0,a.kt)("em",{parentName:"p"},"if")," statement in the NodeVisitor's visit method like the following codes:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def visit(node):\n    node_type = type(node).__name__\n    if node_type == 'BinOp':\n        return self.visit_BinOp(node)\n    elif node_type == 'Num':\n        return self.visit_Num(node)\n    elif ...\n    # ...\n\n# or\n\ndef visit(node):\n    if isinstance(node, BinOp):\n        return self.visit_BinOp(node)\n    elif isinstance(node, Num):\n        return self.visit_Num(node)\n    elif ...\n")),(0,a.kt)("p",null,"The NodeVisitor's ",(0,a.kt)("inlineCode",{parentName:"p"},"visit")," method is very generic and dispatches calls to the appropriate method based on the node type passed to it. In order to make use of it, our interpreter inherits from the ",(0,a.kt)("em",{parentName:"p"},"NodeVisitor")," class and implements necessary methods. So if the type of a node passed to the visit method is BinOp, then the visit method will dispatch the call to the ",(0,a.kt)("em",{parentName:"p"},"visit_BinOp")," method, and if the type of a node is Num, then the visit method will dispatch the call to the ",(0,a.kt)("em",{parentName:"p"},"visit_Num")," method, and so on."),(0,a.kt)("p",null,"Spend some time studying this approach (standard Python module ast uses the same mechanism for node traversal) as we will be extending our interpreter with many new ",(0,a.kt)("em",{parentName:"p"},"visit_NodeType")," methods in the future."),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"generic_visit")," method is a fallback that raises an exception to indicate that it encountered a node that the implementation class has no corresponding ",(0,a.kt)("em",{parentName:"p"},"visit_NodeType")," method for."),(0,a.kt)("p",null,"Okay, here is the complete code of our new interpreter for your convenience:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"\"\"\" SPI - Simple Pascal Interpreter \"\"\"\n\n###############################################################################\n#                                                                             #\n#  LEXER                                                                      #\n#                                                                             #\n###############################################################################\n\n# Token types\n#\n# EOF (end-of-file) token is used to indicate that\n# there is no more input left for lexical analysis\nINTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = (\n    'INTEGER', 'PLUS', 'MINUS', 'MUL', 'DIV', '(', ')', 'EOF'\n)\n\n\nclass Token(object):\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n\n    def __str__(self):\n        \"\"\"String representation of the class instance.\n\n        Examples:\n            Token(INTEGER, 3)\n            Token(PLUS, '+')\n            Token(MUL, '*')\n        \"\"\"\n        return 'Token({type}, {value})'.format(\n            type=self.type,\n            value=repr(self.value)\n        )\n\n    def __repr__(self):\n        return self.__str__()\n\n\nclass Lexer(object):\n    def __init__(self, text):\n        # client string input, e.g. \"4 + 2 * 3 - 6 / 2\"\n        self.text = text\n        # self.pos is an index into self.text\n        self.pos = 0\n        self.current_char = self.text[self.pos]\n\n    def error(self):\n        raise Exception('Invalid character')\n\n    def advance(self):\n        \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\"\n        self.pos += 1\n        if self.pos > len(self.text) - 1:\n            self.current_char = None  # Indicates end of input\n        else:\n            self.current_char = self.text[self.pos]\n\n    def skip_whitespace(self):\n        while self.current_char is not None and self.current_char.isspace():\n            self.advance()\n\n    def integer(self):\n        \"\"\"Return a (multidigit) integer consumed from the input.\"\"\"\n        result = ''\n        while self.current_char is not None and self.current_char.isdigit():\n            result += self.current_char\n            self.advance()\n        return int(result)\n\n    def get_next_token(self):\n        \"\"\"Lexical analyzer (also known as scanner or tokenizer)\n\n        This method is responsible for breaking a sentence\n        apart into tokens. One token at a time.\n        \"\"\"\n        while self.current_char is not None:\n\n            if self.current_char.isspace():\n                self.skip_whitespace()\n                continue\n\n            if self.current_char.isdigit():\n                return Token(INTEGER, self.integer())\n\n            if self.current_char == '+':\n                self.advance()\n                return Token(PLUS, '+')\n\n            if self.current_char == '-':\n                self.advance()\n                return Token(MINUS, '-')\n\n            if self.current_char == '*':\n                self.advance()\n                return Token(MUL, '*')\n\n            if self.current_char == '/':\n                self.advance()\n                return Token(DIV, '/')\n\n            if self.current_char == '(':\n                self.advance()\n                return Token(LPAREN, '(')\n\n            if self.current_char == ')':\n                self.advance()\n                return Token(RPAREN, ')')\n\n            self.error()\n\n        return Token(EOF, None)\n\n\n###############################################################################\n#                                                                             #\n#  PARSER                                                                     #\n#                                                                             #\n###############################################################################\n\nclass AST(object):\n    pass\n\n\nclass BinOp(AST):\n    def __init__(self, left, op, right):\n        self.left = left\n        self.token = self.op = op\n        self.right = right\n\n\nclass Num(AST):\n    def __init__(self, token):\n        self.token = token\n        self.value = token.value\n\n\nclass Parser(object):\n    def __init__(self, lexer):\n        self.lexer = lexer\n        # set current token to the first token taken from the input\n        self.current_token = self.lexer.get_next_token()\n\n    def error(self):\n        raise Exception('Invalid syntax')\n\n    def eat(self, token_type):\n        # compare the current token type with the passed token\n        # type and if they match then \"eat\" the current token\n        # and assign the next token to the self.current_token,\n        # otherwise raise an exception.\n        if self.current_token.type == token_type:\n            self.current_token = self.lexer.get_next_token()\n        else:\n            self.error()\n\n    def factor(self):\n        \"\"\"factor : INTEGER | LPAREN expr RPAREN\"\"\"\n        token = self.current_token\n        if token.type == INTEGER:\n            self.eat(INTEGER)\n            return Num(token)\n        elif token.type == LPAREN:\n            self.eat(LPAREN)\n            node = self.expr()\n            self.eat(RPAREN)\n            return node\n\n    def term(self):\n        \"\"\"term : factor ((MUL | DIV) factor)*\"\"\"\n        node = self.factor()\n\n        while self.current_token.type in (MUL, DIV):\n            token = self.current_token\n            if token.type == MUL:\n                self.eat(MUL)\n            elif token.type == DIV:\n                self.eat(DIV)\n\n            node = BinOp(left=node, op=token, right=self.factor())\n\n        return node\n\n    def expr(self):\n        \"\"\"\n        expr   : term ((PLUS | MINUS) term)*\n        term   : factor ((MUL | DIV) factor)*\n        factor : INTEGER | LPAREN expr RPAREN\n        \"\"\"\n        node = self.term()\n\n        while self.current_token.type in (PLUS, MINUS):\n            token = self.current_token\n            if token.type == PLUS:\n                self.eat(PLUS)\n            elif token.type == MINUS:\n                self.eat(MINUS)\n\n            node = BinOp(left=node, op=token, right=self.term())\n\n        return node\n\n    def parse(self):\n        return self.expr()\n\n###############################################################################\n#                                                                             #\n#  INTERPRETER                                                                #\n#                                                                             #\n###############################################################################\n\nclass NodeVisitor(object):\n    def visit(self, node):\n        method_name = 'visit_' + type(node).__name__\n        visitor = getattr(self, method_name, self.generic_visit)\n        return visitor(node)\n\n    def generic_visit(self, node):\n        raise Exception('No visit_{} method'.format(type(node).__name__))\n\nclass Interpreter(NodeVisitor):\n    def __init__(self, parser):\n        self.parser = parser\n\n    def visit_BinOp(self, node):\n        if node.op.type == PLUS:\n            return self.visit(node.left) + self.visit(node.right)\n        elif node.op.type == MINUS:\n            return self.visit(node.left) - self.visit(node.right)\n        elif node.op.type == MUL:\n            return self.visit(node.left) * self.visit(node.right)\n        elif node.op.type == DIV:\n            return self.visit(node.left) / self.visit(node.right)\n\n    def visit_Num(self, node):\n        return node.value\n\n    def interpret(self):\n        tree = self.parser.parse()\n\n        return self.visit(tree)\n\ndef main():\n    while True:\n        try:\n            text = input('calc >')\n        except EOFError:\n            break\n        if not text:\n            continue\n\n        lexer = Lexer(text)\n        parser = Parser(lexer)\n        interpreter = Interpreter(parser)\n        result = interpreter.interpret()\n        print(result)\n\nif __name__ == '__main__':\n    main()\n")),(0,a.kt)("p",null,"On this article, we've learned about parse trees, ASTs, how to construct ASTs and how to traverse them to interpret the input represented by those ASTs. You've also modified the parser and the interpreter and split them apart. The current interface between the lexer, parser, and the interpreter now looks like this:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part7_pipeline.png",alt:""}),(0,a.kt)("p",null,'You can read that as "The parser gets tokens from the lexer and then returns the generated AST for the interpreter to traverse and interpret the input."'),(0,a.kt)("p",null,"Next, we'll add assignment and unary operators."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Appendix")),(0,a.kt)("p",null,"You can see how parse trees look like for different arithmetic expressions by trying out a small utility called ",(0,a.kt)("a",{target:"_blank",href:n(78086).Z},"genptdot.py")," to help you visualize them. To use the utility you first need to install ",(0,a.kt)("a",{parentName:"p",href:"http://graphviz.org/"},"Graphviz")," package and after you've run the following command, you can open the generated image file parsetree.png and see a parse tree for the expression you passed as a command line argument:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'$ python genptdot.py "14 + 2 * 3 - 6 / 2" > parsetree.dot && dot -Tpng -o parsetree.png parsetree.dot\n')),(0,a.kt)("p",null,"Here is the generated image parsetree.png for the expression 14 + 2 ","*"," 3 - 6 / 2:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part7_genptdot_01.png",alt:""}),(0,a.kt)("p",null,"Play with the utility a bit by passing it different arithmetic expressions and see what a parse tree looks like for a particular expression."))}c.isMDXComponent=!0},78086:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/files/genptdot-ec0ad9b98856aa8027ec76ff82df0e44.py"}}]);