"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1819],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>f});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),s=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=s(e.components);return a.createElement(i.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,i=e.parentName,m=p(e,["components","mdxType","originalType","parentName"]),d=s(n),k=r,f=d["".concat(i,".").concat(k)]||d[k]||c[k]||l;return n?a.createElement(f,o(o({ref:t},m),{},{components:n})):a.createElement(f,o({ref:t},m))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=k;var p={};for(var i in t)hasOwnProperty.call(t,i)&&(p[i]=t[i]);p.originalType=e,p[d]="string"==typeof e?e:r,o[1]=p;for(var s=2;s<l;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"},81971:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>p,toc:()=>s});var a=n(87462),r=(n(67294),n(3905));const l={title:"10",tags:["lisp","interpreter"]},o=void 0,p={unversionedId:"lisp-interpreter-in-py/chapter-10",id:"lisp-interpreter-in-py/chapter-10",title:"10",description:"In this article we will update our interpreter to parse and interpret our very first complete Pascal program. The program can also be compiled by the Free Pascal compiler, fpc.",source:"@site/docs/lisp-interpreter-in-py/chapter-10.md",sourceDirName:"lisp-interpreter-in-py",slug:"/lisp-interpreter-in-py/chapter-10",permalink:"/docs/lisp-interpreter-in-py/chapter-10",draft:!1,tags:[{label:"lisp",permalink:"/docs/tags/lisp"},{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",frontMatter:{title:"10",tags:["lisp","interpreter"]},sidebar:"tutorialSidebar",previous:{title:"09",permalink:"/docs/lisp-interpreter-in-py/chapter-09"},next:{title:"11",permalink:"/docs/lisp-interpreter-in-py/chapter-11"}},i={},s=[{value:"Update the lexer",id:"update-the-lexer",level:3},{value:"Updating the Parser",id:"updating-the-parser",level:3},{value:"Updating the Interpreter",id:"updating-the-interpreter",level:3}],m={toc:s};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In this article we will update our interpreter to parse and interpret our very first complete Pascal program. The program can also be compiled by the ",(0,r.kt)("a",{parentName:"p",href:"http://www.freepascal.org/"},"Free Pascal compiler, fpc"),"."),(0,r.kt)("p",null,"What we're going to cover in this article:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"How to parse and interpret the Pascal ",(0,r.kt)("em",{parentName:"li"},"PROGRAM")," header"),(0,r.kt)("li",{parentName:"ol"},"How to parse Pascal variable declarations"),(0,r.kt)("li",{parentName:"ol"},"Update the interpreter to use the ",(0,r.kt)("em",{parentName:"li"},"DIV")," keyword for integer division and a forward slash ",(0,r.kt)("em",{parentName:"li"},"/")," for float division"),(0,r.kt)("li",{parentName:"ol"},"Support for Pascal comments")),(0,r.kt)("p",null,"Dive in and look at the grammar changes first. We'll add some new rules and update some existing rules."),(0,r.kt)("img",{src:"./imgs/lsbasi_part10_grammar.png",alt:""}),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The program definition grammar rule is updated to include the ",(0,r.kt)("em",{parentName:"p"},"PROGRAM")," reserved keyword, the program name, and a block that ends with a dot. Here is an example of a complete Pascal program:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"PROGRAM Part10;\nBEGIN\nEND.\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("em",{parentName:"p"},"block")," rule combines a declaration rule and a ",(0,r.kt)("em",{parentName:"p"},"compound_statement")," rule. We'll also use the rule later in the series when we add procedure declarations. Here is an example of a block:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"VAR\nnumber : INTEGER;\n\nBEGIN\nEND\n\n# or\n\nBEGIN\nEND\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Pascal declarations have several parts and each part is optional. In this article, we'll cover the variable declaration part only. The ",(0,r.kt)("em",{parentName:"p"},"declarations")," rule has either a variable declaration sub-rule or it's empty.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Pascal is a statically typed language, which means that every variable needs a variable declaration that explicitly specifies its type. In Pascal, variables must be declared before they are used. This is achieved by declaring variables in the program variable declaration section using the ",(0,r.kt)("em",{parentName:"p"},"VAR")," reserved keyword. You can define variables like this:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"VAR\nnumber     : INTEGER;\na, b, c, x : INTEGER;\ny          : REAL;\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("em",{parentName:"p"},"type_spec")," rule is for handling ",(0,r.kt)("em",{parentName:"p"},"INTEGER")," and ",(0,r.kt)("em",{parentName:"p"},"REAL")," types and is used in variable declarations. In the example below."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"VAR\na : INTEGER;\nb : REAL;\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("em",{parentName:"p"},"term")," rule is updated to use the ",(0,r.kt)("em",{parentName:"p"},"DIV")," keyword for integer division and a forward slash ",(0,r.kt)("em",{parentName:"p"},"/")," for float division."),(0,r.kt)("p",{parentName:"li"},"Before, dividing 20 by 7 using a forward slash would produce an INTEGER 2:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"20 / 7 = 2\n")),(0,r.kt)("p",{parentName:"li"},"Now, dividing 20 by 7 using a forward slash will produce a REAL (floating-point number) 2.85714285714 :"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"20 / 7 = 2.85714285714\n")),(0,r.kt)("p",{parentName:"li"},"From now on, to get an INTEGER instead of a REAL, you need to use the ",(0,r.kt)("em",{parentName:"p"},"DIV")," keyword:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"20 DIV 7 = 2\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("em",{parentName:"p"},"factor")," rule is updated to handle both integer and real (float) constants. I also removed the INTEGER sub-rule because the constants will be represented by ",(0,r.kt)("em",{parentName:"p"},"INTEGER_CONST")," and ",(0,r.kt)("em",{parentName:"p"},"REAL_CONST")," tokens and the ",(0,r.kt)("em",{parentName:"p"},"INTEGER")," token will be used to represent the integer type. In the example below the lexer will generate an ",(0,r.kt)("em",{parentName:"p"},"INTEGER_CONST")," token for 20 and 7 and a ",(0,r.kt)("em",{parentName:"p"},"REAL_CONST")," token for 3.14 :"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"y := 20 / 7 + 3.14;\n")),(0,r.kt)("p",{parentName:"li"},"Here is our complete grammar for today:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre"},"program : PROGRAM variable SEMI block DOT\n\nblock : declarations compound_statement\n\ndeclarations : VAR (variable_declaration SEMI)+\n            | empty\n\nvariable_declaration : ID (COMMA ID)* COLON type_spec\n\ntype_spec : INTEGER\n\ncompound_statement : BEGIN statement_list END\n\nstatement_list : statement\n            | statement SEMI statement_list\n\nstatement : compound_statement\n        | assignment_statement\n        | empty\n\nassignment_statement : variable ASSIGN expr\n\nempty :\n\nexpr : term ((PLUS | MINUS) term)*\n\nterm : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*\n\nfactor : PLUS factor\n    | MINUS factor\n    | INTEGER_CONST\n    | REAL_CONST\n    | LPAREN expr RPAREN\n    | variable\n\nvariable: ID\n")))),(0,r.kt)("p",null,"In the rest of the article we'll go through the same drill we went through last time:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Update the lexer"),(0,r.kt)("li",{parentName:"ol"},"Update the parser"),(0,r.kt)("li",{parentName:"ol"},"Update the interpreter")),(0,r.kt)("h3",{id:"update-the-lexer"},"Update the lexer"),(0,r.kt)("p",null,"Here is a summary of the lexer changes:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"New tokens"),(0,r.kt)("li",{parentName:"ol"},"New and updated reserved keywords"),(0,r.kt)("li",{parentName:"ol"},"New ",(0,r.kt)("em",{parentName:"li"},"skip_comments")," method to handle Pascal comments"),(0,r.kt)("li",{parentName:"ol"},"Rename the ",(0,r.kt)("em",{parentName:"li"},"integer")," method and make some changes to the method itself"),(0,r.kt)("li",{parentName:"ol"},"Update the ",(0,r.kt)("em",{parentName:"li"},"get_next_token")," method to return new tokens")),(0,r.kt)("p",null,"One by one:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"To handle a program header, variable declarations, integer and float constants as well as integer and float division, we need to add some new tokens - some of which are reserved keywords - and we also need to update the meaning of the INTEGER token to represent the integer type and not an integer constant. Here is a complete list of new and updated tokens:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"PROGRAM (reserved keyword)"),(0,r.kt)("li",{parentName:"ul"},"VAR (reserved keyword)"),(0,r.kt)("li",{parentName:"ul"},"COLON (:)"),(0,r.kt)("li",{parentName:"ul"},"COMMA (,)"),(0,r.kt)("li",{parentName:"ul"},"INTEGER (we change it to mean integer type and not integer constant like 3 or 5)"),(0,r.kt)("li",{parentName:"ul"},"REAL (for Pascal REAL type)"),(0,r.kt)("li",{parentName:"ul"},"INTEGER_CONST (for example, 3 or 5)"),(0,r.kt)("li",{parentName:"ul"},"REAL_CONST (for example, 3.14 and so on)"),(0,r.kt)("li",{parentName:"ul"},"INTEGER_DIV for integer division (the DIV reserved keyword)"),(0,r.kt)("li",{parentName:"ul"},"FLOAT_DIV for float division ( forward slash / )"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Here is the complete mapping of reserved keywords to tokens:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-python"},"RESERVED_KEYWORDS = {\n    'PROGRAM': Token(PROGRAM, 'PROGRAM'),\n    'VAR': Token(VAR, 'VAR'),\n    'DIV': Token(INTEGER_DIV, 'DIV'),\n    'INTEGER': Token(INTEGER, 'INTEGER'),\n    'REAL': Token(REAL, 'REAL'),\n    'BEGIN': Token(BEGIN, 'BEGIN'),\n    'END': Token(END, 'END'),\n}\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"We're adding the ",(0,r.kt)("em",{parentName:"p"},"skip_comment")," method to handle Pascal comments. The method is pretty basic and all it does is discarding all the characters until the closing curly brace is found:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def skip_comment(self):\n    while self.current_char != '}':\n        self.advance()\n    self.advance()  # the closing curly brace\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"We are renaming the integer method the number method. It can handle both integer constants and float constants like 3 and 3.14:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def number(self):\n    \"\"\"Return a (multidigit) integer or float consumed from the input.\"\"\"\n    result = ''\n    while self.current_char is not None and self.current_char.isdigit():\n        result += self.current_char\n        self.advance()\n\n    if self.current_char == '.':\n        result += self.current_char\n        self.advance()\n\n        while (\n            self.current_char is not None and\n            self.current_char.isdigit()\n        ):\n            result += self.current_char\n            self.advance()\n\n        token = Token('REAL_CONST', float(result))\n    else:\n        token = Token('INTEGER_CONST', int(result))\n\n    return token\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"We're also updating the ",(0,r.kt)("em",{parentName:"p"},"get_next_token")," method to return new tokens:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_next_token(self):\n    while self.current_char is not None:\n        ...\n        if self.current_char == '{':\n            self.advance()\n            self.skip_comment()\n            continue\n        ...\n        if self.current_char.isdigit():\n            return self.number()\n\n        if self.current_char == ':':\n            self.advance()\n            return Token(COLON, ':')\n\n        if self.current_char == ',':\n            self.advance()\n            return Token(COMMA, ',')\n        ...\n        if self.current_char == '/':\n            self.advance()\n            return Token(FLOAT_DIV, '/')\n        ...\n")))),(0,r.kt)("h3",{id:"updating-the-parser"},"Updating the Parser"),(0,r.kt)("p",null,"Here is a summary of the changes:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"New AST nodes: ",(0,r.kt)("em",{parentName:"li"},"Program, Block, VarDecl, Type")),(0,r.kt)("li",{parentName:"ol"},"New methods corresponding to new grammar rules: ",(0,r.kt)("em",{parentName:"li"},"block, declarations, variable_declaration, type_spec"),"."),(0,r.kt)("li",{parentName:"ol"},"Updates to the existing parser methods: ",(0,r.kt)("em",{parentName:"li"},"program, term, factor"))),(0,r.kt)("p",null,"One by one:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"We'll start with new AST nodes first. There are four new nodes:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("em",{parentName:"p"},"Program")," AST node represents a program and will be our root node"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Program(AST):\n    def __init__(self, name, block):\n        self.name = name\n        self.block = block\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("em",{parentName:"p"},"Block")," AST node holds declarations and a compound statement:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Block(AST):\n    def __init__(self, declarations, compound_statement):\n        self.declarations = declarations\n    self.compound_statement = compound_statement\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("em",{parentName:"p"},"VarDecl")," AST node represents a variable declaration. It holds a variable node and a type node:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class VarDecl(AST):\n    def __init__(self, var_node, type_node):\n        self.var_node = var_node\n        self.type_node = type_node\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("em",{parentName:"p"},"Type")," AST node represents a variable type (INTEGER or REAL):"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Type(AST):\n    def __init__(self, token):\n        self.token = token\n        self.value = token.value\n"))))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Each rule from the grammar has a corresponding method in our recursive-descent parser. Today we're adding four new methods: ",(0,r.kt)("em",{parentName:"p"},"block, declarations, variable_declaration"),", and ",(0,r.kt)("em",{parentName:"p"},"type_spec"),". These methods are responsible for parsing new language constructs and constructing new AST nodes:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def block(self):\n    """ block : declarations compound_statement """\n    declaration_nodes = self.declarations()\n    compound_statement_node = self.compound_statement()\n    node = Block(declaration_nodes, compound_statement_node)\n    return node\n\ndef declarations(self):\n    """\n    declarations : VAR (variable_declaration SEMI)+\n                | empty\n    """\n    declarations = []\n    if self.current_token.type == VAR:\n        self.eat(VAR)\n        while self.current_token.type == ID:\n            var_decl = self.variable_declaration()\n            declarations.extend(var_decl)\n            self.eat(SEMI)\n    return declarations\n\ndef variable_declaration(self):\n    """ variable_declaration : ID (COMMA ID)* COLON type_spec """\n    var_nodes = [Var(self.current_token)] # first ID\n    self.eat(ID)\n\n    while self.current_token.type == COMMA:\n        self.eat(COMMA)\n        var_nodes.append(Var(self.current_token))\n        self.eat(ID)\n\n    self.eat(COLON)\n\n    type_node = self.type_spec()\n    var_declarations = [\n        VarDecl(var_node, type_node) for var_node in var_nodes\n    ]\n    return var_declarations\n\ndef type_spec(self):\n    """ type_spec : INTEGER\n                | REAL\n    """\n    token = self.current_token\n    if self.current_token.type == INTEGER:\n        self.eat(INTEGER)\n    else:\n        self.eat(REAL)\n    node = Type(token)\n\n    retun node\n'))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"We also need to update the ",(0,r.kt)("em",{parentName:"p"},"program, term"),", and ",(0,r.kt)("em",{parentName:"p"},"factor")," methods to accommodate the grammar changes:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def program(self):\n    """ program: PROGRAM variable SEMI block DOT """\n    self.eat(PROGRAM)\n    var_node = self.variable()\n    prog_name = var_node.value\n    self.eat(SEMI)\n    block_node = self.block()\n    program_node = Program(prog_name, block_node)\n    self.eat(DOT)\n    return program_node\n\ndef term(self):\n    """term : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*"""\n    node = self.factor()\n\n    while self.current_token.type in (MUL, INTEGER_DIV, FLOAT_DIV):\n        token = self.current_token\n        if token.type == MUL:\n            self.eat(MUL)\n        elif token.type == INTEGER_DIV:\n            self.eat(INTEGER_DIV)\n        elif token.type == FLOAT_DIV:\n            self.eat(FLOAT_DIV)\n\n        node = BinOp(left=node, op=token, right=self.factor())\n\n    return node\n\ndef factor(self):\n    """factor : PLUS factor\n            | MINUS factor\n            | INTEGER_CONST\n            | REAL_CONST\n            | LPAREN expr RPAREN\n            | variable\n    """\n    token = self.current_token\n    if token.type == PLUS:\n        self.eat(PLUS)\n        node = UnaryOp(token, self.factor())\n        return node\n    elif token.type == MINUS:\n        self.eat(MINUS)\n        node = UnaryOp(token, self.factor())\n        return node\n    elif token.type == INTEGER_CONST:\n        self.eat(INTEGER_CONST)\n        return Num(token)\n    elif token.type == REAL_CONST:\n        self.eat(REAL_CONST)\n        return Num(token)\n    elif token.type == LPAREN:\n        self.eat(LPAREN)\n        node = self.expr()\n        self.eat(RPAREN)\n        return node\n    else:\n        node = self.variable()\n        return node\n')))),(0,r.kt)("h3",{id:"updating-the-interpreter"},"Updating the Interpreter"),(0,r.kt)("p",null,"There will be four new methods to visit our new nodes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"visit_Program"),(0,r.kt)("li",{parentName:"ul"},"visit_Block"),(0,r.kt)("li",{parentName:"ul"},"visit_VarDecl"),(0,r.kt)("li",{parentName:"ul"},"visit_Type")),(0,r.kt)("p",null,"They are pretty straightforward. You can also see that the Interpreter does nothing with ",(0,r.kt)("em",{parentName:"p"},"VarDecl")," and ",(0,r.kt)("em",{parentName:"p"},"Type")," nodes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def visit_Program(self, node):\n    self.visit(node.block)\n\ndef visit_Block(self, node):\n    for declaration in node.declarations:\n        self.visit(declaration)\n    self.visit(node.compound_statement)\n\ndef visit_VarDecl(self, node):\n    pass\n\ndef visit_Type(self, node):\n    pass\n")),(0,r.kt)("p",null,"We also need to update the ",(0,r.kt)("em",{parentName:"p"},"visit_BinOp")," method to properly interpret integer and float divisions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def visit_BinOp(self, node):\n    if node.op.type == PLUS:\n        return self.visit(node.left) + self.visit(node.right)\n    elif node.op.type == MINUS:\n        return self.visit(node.left) - self.visit(node.right)\n    elif node.op.type == MUL:\n        return self.visit(node.left) * self.visit(node.right)\n    elif node.op.type == INTEGER_DIV:\n        return self.visit(node.left) / self.visit(node.right)\n    elif node.op.type == FLOAT_DIV:\n        return float(self.visit(node.left)) / float(self.visit(node.right))\n")),(0,r.kt)("p",null,"Next, more detail about symbol table management."))}d.isMDXComponent=!0}}]);