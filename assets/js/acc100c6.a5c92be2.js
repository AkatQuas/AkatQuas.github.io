"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2993],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},f="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),f=p(n),h=a,m=f["".concat(l,".").concat(h)]||f[h]||u[h]||s;return n?r.createElement(m,o(o({ref:t},c),{},{components:n})):r.createElement(m,o({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,o=new Array(s);o[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[f]="string"==typeof e?e:a,o[1]=i;for(var p=2;p<s;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},31939:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>f,frontMatter:()=>s,metadata:()=>i,toc:()=>p});var r=n(87462),a=(n(67294),n(3905));const s={title:"03",tags:["lisp","interpreter"]},o=void 0,i={unversionedId:"lisp-interpreter-in-py/chapter-03",id:"lisp-interpreter-in-py/chapter-03",title:"03",description:'Today I\'m going to talk about how to parse (recognize) and interpret arithmetic expressions that have any number of plus or minus operators in it, for example "7 - 3 + 2 - 1".',source:"@site/docs/lisp-interpreter-in-py/chapter-03.md",sourceDirName:"lisp-interpreter-in-py",slug:"/lisp-interpreter-in-py/chapter-03",permalink:"/docs/lisp-interpreter-in-py/chapter-03",draft:!1,tags:[{label:"lisp",permalink:"/docs/tags/lisp"},{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",frontMatter:{title:"03",tags:["lisp","interpreter"]},sidebar:"tutorialSidebar",previous:{title:"02",permalink:"/docs/lisp-interpreter-in-py/chapter-02"},next:{title:"04",permalink:"/docs/lisp-interpreter-in-py/chapter-04"}},l={},p=[],c={toc:p};function f(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,'Today I\'m going to talk about how to parse (recognize) and interpret arithmetic expressions that have any number of plus or minus operators in it, for example "7 - 3 + 2 - 1".'),(0,a.kt)("p",null,"Graphically, the arithmetic expressions in this article can be represented with the following syntax diagram:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part3_syntax_diagram.png",alt:""}),(0,a.kt)("p",null,"What is a syntax diagram? A ",(0,a.kt)("strong",{parentName:"p"},"syntax diagram")," is a graphical representation of a programming language's syntax rules. Basically, a syntax diagram visually shows you which statements are allowed in your programming language and which are not."),(0,a.kt)("p",null,"Syntax diagrams are pretty easy to read: just follow the paths indicated by the arrows. Some paths indicate choices. And some paths indicate loops."),(0,a.kt)("p",null,"Syntax diagrams serve two main purposes:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"They graphically represent the specification (grammar) of a programming language."),(0,a.kt)("li",{parentName:"ol"},"They can be used to help you write your parser - you can map a diagram to code by following simple rules.")),(0,a.kt)("p",null,"We've learned that the process of recognizing a phrase in the stream of tokens is called parsing. And the part of an interpreter or compiler that performs that job is called a parser. Parsing is also called syntax analysis, and the parser is also aptly called, you guessed it correct, a syntax analyzer."),(0,a.kt)("p",null,"From the previous articles (",(0,a.kt)("a",{parentName:"p",href:"/docs/lisp-interpreter-in-py/chapter-01"},"Part 1")," and ",(0,a.kt)("a",{parentName:"p",href:"/docs/lisp-interpreter-in-py/chapter-02"},"Part 2"),") that the ",(0,a.kt)("em",{parentName:"p"},"expr")," method is where both parser and interpreter live. Again, the parser just recognizes the structure making sure it corresponds to some specifications and the interpreter actually evaluates the expression once the parser has successfully recognized (parsed) it."),(0,a.kt)("p",null,"The following code snippet shows the parser code corresponding to the diagram. The rectangular box from the syntax diagram ",(0,a.kt)("em",{parentName:"p"},"term")," becomes a ",(0,a.kt)("em",{parentName:"p"},"term")," method that parses an integer and the ",(0,a.kt)("em",{parentName:"p"},"expr")," method just follows the syntax diagram flow:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def term(self):\n    self.eat(INTEGER)\n\ndef expr(self):\n    # set current token to the first token taken from the input\n    self.current_token = self.get_next_token()\n\n    self.term()\n\n    while self.current_token.type in (PLUS, MINUS):\n        token = self.current_token\n        if token.type == PLUS:\n            self.eat(PLUS)\n            self.term()\n        elif toke.type == MINUS:\n            self.eat(MINUS)\n            self.term()\n")),(0,a.kt)("p",null,"You can see that ",(0,a.kt)("em",{parentName:"p"},"expr")," first calls the ",(0,a.kt)("em",{parentName:"p"},"term")," method. Then the ",(0,a.kt)("em",{parentName:"p"},"expr")," method has a ",(0,a.kt)("em",{parentName:"p"},"while loop")," which can execute zero or more times. And inside the loop the parser makes a choice based on the token (whether it's a plus or minus sign)."),(0,a.kt)("p",null,"The parser itself does not interpret anything though: if it recognizes an expression it's silent and if it does not, it throws out a syntax error. Let's modify the ",(0,a.kt)("em",{parentName:"p"},"expr")," method and add the interpreter code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'def term(self):\n    """ Return an INTEGER token value"""\n    token = self.current_token\n    self.eat(INTEGER)\n    return token.value\n\ndef expr(self):\n    """ Parser / Interpreter """\n    # set current token to the first token taken from the input\n    self.current_token = self.get_next_token()\n\n    result = self.term()\n    while self.current_token.type in (PLUS, MINUS):\n        token = self.current_token\n        if token.type == PLUS:\n            self.eat(PLUS)\n            result = result + self.term()\n        elif token.type == MINUS:\n            self.eat(MINUS)\n            result = result - self.term()\n    return result\n')),(0,a.kt)("p",null,"Here is the source code for your new version of the calculator that can handle valid arithmetic expressions containing integers and any number of addition and subtraction operators:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'# Token types\n#\n# EOF (end-of-file) token is used to indicate that\n# there is no more input left for lexical analysis\nINTEGER, PLUS, MINUS, EOF = \'INTEGER\', \'PLUS\', \'MINUS\', \'EOF\'\n\n\nclass Token(object):\n    def __init__(self, type, value):\n        # token type: INTEGER, PLUS, MINUS, or EOF\n        self.type = type\n        # token value: non-negative integer value, \'+\', \'-\', or None\n        self.value = value\n\n    def __str__(self):\n        """String representation of the class instance.\n        Examples:\n            Token(INTEGER, 3)\n            Token(PLUS, \'+\')\n        """\n        return \'Token({type}, {value})\'.format(\n            type=self.type,\n            value=repr(self.value)\n        )\n\n    def __repr__(self):\n        return self.__str__()\n\n\nclass Interpreter(object):\n    def __init__(self, text):\n        # client string input, e.g. "3 + 5", "12 - 5 + 3", etc\n        self.text = text\n        # self.pos is an index into self.text\n        self.pos = 0\n        # current token instance\n        self.current_token = None\n        self.current_char = self.text[self.pos]\n\n    ##########################################################\n    # Lexer code                                             #\n    ##########################################################\n    def error(self):\n        raise Exception(\'Invalid syntax\')\n\n    def advance(self):\n        """Advance the `pos` pointer and set the `current_char` variable."""\n        self.pos += 1\n        if self.pos > len(self.text) - 1:\n            self.current_char = None  # Indicates end of input\n        else:\n            self.current_char = self.text[self.pos]\n\n    def skip_whitespace(self):\n        while self.current_char is not None and self.current_char.isspace():\n            self.advance()\n\n    def integer(self):\n        """Return a (multidigit) integer consumed from the input."""\n        result = \'\'\n        while self.current_char is not None and self.current_char.isdigit():\n            result += self.current_char\n            self.advance()\n        return int(result)\n\n    def get_next_token(self):\n        """Lexical analyzer (also known as scanner or tokenizer)\n        This method is responsible for breaking a sentence\n        apart into tokens. One token at a time.\n        """\n        while self.current_char is not None:\n\n            if self.current_char.isspace():\n                self.skip_whitespace()\n                continue\n\n            if self.current_char.isdigit():\n                return Token(INTEGER, self.integer())\n\n            if self.current_char == \'+\':\n                self.advance()\n                return Token(PLUS, \'+\')\n\n            if self.current_char == \'-\':\n                self.advance()\n                return Token(MINUS, \'-\')\n\n            self.error()\n\n        return Token(EOF, None)\n\n    ##########################################################\n    # Parser / Interpreter code                              #\n    ##########################################################\n    def eat(self, token_type):\n        # compare the current token type with the passed token\n        # type and if they match then "eat" the current token\n        # and assign the next token to the self.current_token,\n        # otherwise raise an exception.\n        if self.current_token.type == token_type:\n            self.current_token = self.get_next_token()\n        else:\n            self.error()\n\n    def term(self):\n        """Return an INTEGER token value."""\n        token = self.current_token\n        self.eat(INTEGER)\n        return token.value\n\n    def expr(self):\n        """Arithmetic expression parser / interpreter."""\n        # set current token to the first token taken from the input\n        self.current_token = self.get_next_token()\n\n        result = self.term()\n        while self.current_token.type in (PLUS, MINUS):\n            token = self.current_token\n            if token.type == PLUS:\n                self.eat(PLUS)\n                result = result + self.term()\n            elif token.type == MINUS:\n                self.eat(MINUS)\n                result = result - self.term()\n\n        return result\n\n\ndef main():\n    while True:\n        try:\n            text = input(\'calc> \')\n        except EOFError:\n            break\n        if not text:\n            continue\n        interpreter = Interpreter(text)\n        result = interpreter.expr()\n        print(result)\n\n\nif __name__ == \'__main__\':\n    main()\n')))}f.isMDXComponent=!0}}]);