"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1057],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},f="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),f=p(n),h=a,m=f["".concat(l,".").concat(h)]||f[h]||u[h]||o;return n?r.createElement(m,s(s({ref:t},c),{},{components:n})):r.createElement(m,s({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[f]="string"==typeof e?e:a,s[1]=i;for(var p=2;p<o;p++)s[p]=n[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},35892:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>f,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var r=n(87462),a=(n(67294),n(3905));const o={title:"02",tags:["lisp","interpreter"]},s=void 0,i={unversionedId:"lisp-interpreter-in-py/chapter-02",id:"lisp-interpreter-in-py/chapter-02",title:"02",description:"On this section, we'll create a new version of the calculator from calc1.py that will be able to:",source:"@site/docs/lisp-interpreter-in-py/chapter-02.md",sourceDirName:"lisp-interpreter-in-py",slug:"/lisp-interpreter-in-py/chapter-02",permalink:"/docs/lisp-interpreter-in-py/chapter-02",draft:!1,tags:[{label:"lisp",permalink:"/docs/tags/lisp"},{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",frontMatter:{title:"02",tags:["lisp","interpreter"]},sidebar:"tutorialSidebar",previous:{title:"01 Why study interpreters and compilers?",permalink:"/docs/lisp-interpreter-in-py/chapter-01"},next:{title:"03",permalink:"/docs/lisp-interpreter-in-py/chapter-03"}},l={},p=[],c={toc:p};function f(e){let{components:t,...o}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"On this section, we'll create a new version of the calculator from ",(0,a.kt)("a",{target:"_blank",href:n(99258).Z},"calc1.py")," that will be able to:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Handle whitespace characters anywhere in the input string")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Consume multi-digit integers from the input")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Substract two integers"))),(0,a.kt)("p",null,"Here is the complete code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"# Token types\n# EOF (end-of-file) token is used to indicate that\n# there is no more input left for lexical analysis\nINTEGER, PLUS, MINUS, EOF = 'INTEGER', 'PLUS', 'MINUS', 'EOF'\n\nclass Token(object):\n    def __init__(self, type, value):\n        # token type: INTEGER, PLUS, MINUS, or EOF\n        self.type = type\n        # token value: non-negative integer value, '+', '-', or None\n        self.value = value\n\n    def __str__(self):\n        \"\"\"\n        String representation of the class instance.\n        Examples:\n            Token(INTEGER, 3)\n            Token(PLUS '+')\n        \"\"\"\n        return 'Token({type}, {value})'.format(\n            type=self.type,\n            value=repr(self.value)\n        )\n\n    def __repr__(self):\n        return self.__str__()\n\nclass Interpreter(object):\n    def __init__(self, text):\n        # client string input, e.g. \"3+5\", \"12 - 5\", etc\n        self.text = text\n        # self.pos is an index into self.text\n        self.pos = 0\n        # current_token = None\n        self.current_token = None\n        self.current_char = self.text[self.pos]\n\n    def error(self):\n        raise Exception('Error parsing inpt')\n\n    def advance(self):\n        \"\"\"\n        Advance the `pos` pointer and set the `current_char` variable.\n        \"\"\"\n        self.pos += 1\n        if self.pos > len(self.text) - 1:\n            self.current_char = None\n        else:\n            self.current_char = self.text[self.pos]\n\n    def skip_whitespace(self):\n        while self.current_char is not None and self.current_char.isspace():\n            self.advance()\n\n    def integer(self):\n        \"\"\"\n        Return a (multidigit) integer consumed from the input.\n        \"\"\"\n        result = ''\n        while self.current_char is not None and self.current_char.isdigit():\n            result += self.current_char\n            self.advance()\n        return int(result)\n\n    def get_next_token(self):\n        \"\"\"\n        Lexical analyzer (also known as scanner or tokenizer)\n\n        This method is responsible for breaking a sentence apart into tokens.\n        \"\"\"\n        while self.current_char is not None:\n            if self.current_char.isspace():\n                self.skip_whitespace()\n                continue\n\n            if self.current_char.isdigit():\n                return Token(INTEGER, self.integer())\n\n            if self.current_char == '+':\n                self.advance()\n                return Token(PLUS, '+')\n\n            if self.current_char == '-':\n                self.advance()\n                return Token(MINUS, '-')\n\n            self.error()\n\n        return Token(EOF, None)\n\n    def eat(self, token_type):\n        # compare the current token type with the passed token\n        # type and if they match then \"eat\" the current token\n        # and assign the next token to the self.current_token,\n        # otherwise raise an exception.\n\n        if self.current_token.type == token_type:\n            self.current_token = self.get_next_token()\n        else:\n            self.error()\n\n    def expr(self):\n        \"\"\"\n        Parser / Interpreter\n        expr -> INTEGER PLUS INTEGER\n        expr -> INTEGER MINUS INTEGER\n        \"\"\"\n\n        # set current token to the first token taken from the input\n        self.current_token = self.get_next_token()\n\n        # we expect the current token to be an integer\n        left = self.current_token\n        self.eat(INTEGER)\n\n        # we expect the current token to be either a '+' or '-'\n        op = self.current_token\n        if op.type == PLUS:\n            self.eat(PLUS)\n        else:\n            self.eat(MINUS)\n\n        # we expect the current token to be an integer\n        right = self.current_token\n        self.eat(INTEGER)\n\n        # after the above call the self.current_token is set to EOF token\n\n        # at this point either the INTEGER PLUS INTEGER or\n        # the INTEGER MINUS INTEGER sequence of tokens\n        # has been successfully found and the method can just\n        # return the result of adding or subtracting two integers,\n\n        if op.type == PLUS:\n            result = left.value + right.value\n        else:\n            result = left.value - right.value\n\n        return result\n\n\ndef main():\n    while True:\n        try:\n            text = input('calc> ')\n        except EOFError:\n            break\n\n        if not text:\n            continue\n        interpreter = Interpreter(text)\n        result = interpreter.expr()\n        print(result)\n\nif __name__ == '__main__':\n    main()\n")),(0,a.kt)("p",null,"The major code changes compared with the version from Part 1 are:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("em",{parentName:"li"},"get_next_token")," method was refactored a bit. The logic to increment the pos pointer was factored into a separate method ",(0,a.kt)("em",{parentName:"li"},"advance"),"."),(0,a.kt)("li",{parentName:"ol"},"Two more methods were added: ",(0,a.kt)("em",{parentName:"li"},"skip_whitespace")," to ignore whitespace characters and ",(0,a.kt)("em",{parentName:"li"},"integer")," to handle multi-digit integers in the input."),(0,a.kt)("li",{parentName:"ol"},"The ",(0,a.kt)("em",{parentName:"li"},"expr")," method was modified to recognize ",(0,a.kt)("strong",{parentName:"li"},"INTEGER -> MINUS -> INTEGER")," phrase in addition to ",(0,a.kt)("strong",{parentName:"li"},"INTEGER -> PLUS -> INTEGER")," phrase. The method now also interprets both addition and subtraction after having successfully recognized the corresponding phrase.")),(0,a.kt)("p",null,"Here we'd like to talk a little about ",(0,a.kt)("strong",{parentName:"p"},"lexemes, parsing, and parsers"),"."),(0,a.kt)("p",null,"You already know about tokens. But in order for me to round out the discussion of tokens I need to mention lexemes. What is a lexeme? A ",(0,a.kt)("strong",{parentName:"p"},"lexeme")," is a sequence of characters that form a token. In the following picture you can see some examples of tokens and sample lexemes and hopefully it will make the relationship between them clear:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part2_lexemes.png",alt:""}),(0,a.kt)("p",null,"Before you can interpret an expression you first need to recognize what kind of phrase it is, whether it is addition or subtraction, for example. That's what the ",(0,a.kt)("em",{parentName:"p"},"expr")," method essentially does: it finds the structure in the stream of tokens it gets from the ",(0,a.kt)("em",{parentName:"p"},"get_next_token")," method and then it interprets the phrase that is has recognized, generating the result of the arithmetic expression."),(0,a.kt)("p",null,"The process of finding the structure in the stream of tokens, or put differently, the process of recognizing a phrase in the stream of tokens is called ",(0,a.kt)("strong",{parentName:"p"},"parsing"),". The part of an interpreter or compiler that performs that job is called a ",(0,a.kt)("strong",{parentName:"p"},"parser"),"."),(0,a.kt)("p",null,"So the ",(0,a.kt)("em",{parentName:"p"},"expr")," method is the part of your interpreter where both ",(0,a.kt)("strong",{parentName:"p"},"parsing")," and ",(0,a.kt)("strong",{parentName:"p"},"interpreting")," happens - the ",(0,a.kt)("em",{parentName:"p"},"expr")," method first tries to recognize (parse) the ",(0,a.kt)("strong",{parentName:"p"},"INTEGER -> PLUS -> INTEGER")," or the ",(0,a.kt)("strong",{parentName:"p"},"INTEGER -> MINUS -> INTEGER")," phrase in the stream of tokens and after it has successfully recognized (parsed) one of those phrases, the method interprets it and returns the result of either addition or subtraction of two integers to the caller."))}f.isMDXComponent=!0},99258:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/files/calc1-cee2a425ba7b4148857a9be2ab72e179.py"}}]);