"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2849],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>p});var o=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=o.createContext({}),c=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=c(e.components);return o.createElement(l.Provider,{value:n},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=c(t),m=a,p=h["".concat(l,".").concat(m)]||h[m]||d[m]||i;return t?o.createElement(p,r(r({ref:n},u),{},{components:t})):o.createElement(p,r({ref:n},u))}));function p(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,r=new Array(i);r[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[h]="string"==typeof e?e:a,r[1]=s;for(var c=2;c<i;c++)r[c]=t[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},83264:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var o=t(87462),a=(t(67294),t(3905));const i={title:"Concurrency Primitives",sidebar_position:3},r=void 0,s={unversionedId:"concurrency-in-go/primitives",id:"concurrency-in-go/primitives",title:"Concurrency Primitives",description:"Put very simply, a goroutine is a function that is running concurrently (remember: not necessarily in parallel!) alongside other code.",source:"@site/docs/concurrency-in-go/primitives.md",sourceDirName:"concurrency-in-go",slug:"/concurrency-in-go/primitives",permalink:"/docs/concurrency-in-go/primitives",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Concurrency Primitives",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Introduction on Concurrency and Parallelism",permalink:"/docs/concurrency-in-go/introduction"},next:{title:"Concurrency Patterns in Go",permalink:"/docs/concurrency-in-go/patterns"}},l={},c=[{value:"The <code>sync</code> package",id:"the-sync-package",level:2},{value:"<code>WaitGroup</code>",id:"waitgroup",level:2},{value:"<code>Mutex</code> and <code>RWMutex</code>",id:"mutex-and-rwmutex",level:2},{value:"<code>Cond</code>",id:"cond",level:2},{value:"Once",id:"once",level:2},{value:"<code>Pool</code>",id:"pool",level:2},{value:"Channels",id:"channels",level:2},{value:"The <code>select</code> Statement",id:"the-select-statement",level:2}],u={toc:c};function h(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,o.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Put very simply, a goroutine is a function that is running concurrently (remember: not necessarily in parallel!) alongside other code."),(0,a.kt)("p",null,"In fact, every Go program has at least one goroutine: the main goroutine, which is automatically created and started when the process begins."),(0,a.kt)("p",null,"So let\u2019s look at what\u2019s happening behind the scenes here: how do goroutines actually work? Are they OS threads? Green threads? How many can we create?"),(0,a.kt)("p",null,"Goroutines are unique to Go (though some other languages have a concurrency primitive is similar). They\u2019re not OS threads, and they\u2019re not exactly green threads\u2014threads that are managed by a language\u2019s runtime\u2014they\u2019re a higher level of abstraction known as coroutines. Coroutines are simply concurrent subroutines (functions, closures, or methods in Go) that are nonpreemptive\u2014that is, they cannot be interrupted. Instead, coroutines have multiple points throughout which allow for suspension or reentry."),(0,a.kt)("p",null,"What makes goroutines unique to Go are their deep integration with Go\u2019s runtime. Goroutines don't define their own suspension or reentry points; Go\u2019s runtime observes the runtime behavior of goroutines and automatically suspends them when they block and then resumes them when they become unblocked. In a way this makes them preemptable, but only at points where the goroutine has become blocked. It is an elegant partnership between the runtime and a goroutine\u2019s logic. Thus, goroutines can be considered a special class of coroutine."),(0,a.kt)("p",null,"Coroutines, and thus goroutines, are implicitly concurrent constructs, but concurrency is not a property of a coroutine: something must host several coroutines simultaneously and give each an opportunity to execute. Note that this does not imply that coroutines are implicitly parallel. It is certainly possible to have several coroutines executing sequentially to give the illusion of parallelism."),(0,a.kt)("p",null,"Go\u2019s mechanism for hosting goroutines is an implementation of what\u2019s called an ",(0,a.kt)("strong",{parentName:"p"},"M:N scheduler"),", which means it maps ",(0,a.kt)("em",{parentName:"p"},"M green threads")," to ",(0,a.kt)("em",{parentName:"p"},"N OS threads"),". Goroutines are then scheduled onto the green threads. When we have more goroutines than green threads available, the scheduler handles the distribution of the goroutines across the available threads and ensures that when these goroutines become blocked, other goroutines can be run."),(0,a.kt)("p",null,"Go follows a model of concurrency called the ",(0,a.kt)("em",{parentName:"p"},"fork-join")," model. The word ",(0,a.kt)("em",{parentName:"p"},"fork")," refers to the fact that at any point in the program, it can split off a ",(0,a.kt)("em",{parentName:"p"},"child")," branch of execution to be run concurrently with its ",(0,a.kt)("em",{parentName:"p"},"parent"),". The word join refers to the fact that at some point in the future, these concurrent branches of execution will ",(0,a.kt)("em",{parentName:"p"},"join")," back together. Where the ",(0,a.kt)("em",{parentName:"p"},"child")," rejoins the parent is called a ",(0,a.kt)("em",{parentName:"p"},"join point"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"            main\n              |\n              |--fork--\x3e child\n              |            |\n              |            |\njoin-point:   |-<- join ---|\n              |            x\n              |            |\n            main         child\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"join points")," are what guarantee our program\u2019s correctness and remove the race condition."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'var wg sync.WaitGroup\nsayHello := func() {\n  defer wg.Done() // the child would return to join?\n  fmt.Println("hello")\n}\n\nwg.Add(1)\ngo sayHello()\nwg.Wait() // this is the join part\n')),(0,a.kt)("p",null,"Because goroutines operate within the same address space as each other, and simply host functions, utilizing goroutines is a natural extension to writing non-concurrent code. Go\u2019s compiler nicely takes care of pinning variables in memory so that goroutines don't accidentally access freed memory, which allows developers to focus on their problem space instead of memory management; however, it\u2019s not a blank check."),(0,a.kt)("p",null,"Since multiple goroutines can operate against the same address space, we still have to worry about synchronization. As we\u2019ve discussed, we can choose either to synchronize access to the shared memory the goroutines access, or we can use CSP primitives to share memory by communication."),(0,a.kt)("p",null,"In the following example, we combine the fact that goroutines are not garbage collected with the runtime\u2019s ability to introspect upon itself and measure the amount of memory allocated before and after goroutine creation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'memConsumed := func() uint64 {\n  runtime.GC()\n  var s runtime.MemStats\n  runtime.ReadMemStats(&s)\n  return s.Sys\n}\nvar c <-chan interface{}\nvar wg sync.WaitGroup\nnoop := func() {\n  wg.Done()\n  <-c // the goroutine would hang up forever\n}\n\nconst numGoroutines = 1e4 // a big number of goroutines to create\nwg.Add(numGoroutines)\nbefore := memConsumed()\nfor i := numGoroutines; i > 0; i-- {\n  go noop()\n}\nwg.Wait()\nafter := memConsumed()\nfmt.Printf("%.3fkb", float64(after-before)/numGoroutines/1000)\n')),(0,a.kt)("p",null,"Something that might dampen our spirits is ",(0,a.kt)("em",{parentName:"p"},"context switching"),", which is when something hosting a concurrent process must save its state to switch to running a different concurrent process. At the OS level, with threads, this can be quite costly. The OS thread must save things like register values, lookup tables, and memory maps to successfully be able to switch back to the current thread when it is time. Then it has to load the same information for the incoming thread."),(0,a.kt)("p",null,"Context switching in software is comparatively much, much cheaper. Under a software-defined scheduler, the runtime can be more selective in what is persisted for retrieval, how it is persisted, and when the persisting need occur."),(0,a.kt)("h2",{id:"the-sync-package"},"The ",(0,a.kt)("inlineCode",{parentName:"h2"},"sync")," package"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"sync")," package contains the concurrency primitives that are most useful for low-level memory access synchronization. In Go, these memory-access-synchronization operations have their use\u2014mostly in small scopes such as a struct. It will be up to you to decide when memory access synchronization is appropriate."),(0,a.kt)("h2",{id:"waitgroup"},(0,a.kt)("inlineCode",{parentName:"h2"},"WaitGroup")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"WaitGroup")," is a great way to wait for a set of concurrent operations to complete when you either don't care about the result of the concurrent operation, or you have other means of collecting their results. If neither of those conditions are true, I suggest you use ",(0,a.kt)("inlineCode",{parentName:"p"},"channels")," and a ",(0,a.kt)("inlineCode",{parentName:"p"},"select")," statement instead."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// 2nd goroutine sleeping...\n// 1st goroutine sleeping...\n//\n// All goroutines complete.\nvar wg sync.WaitGroup\nwg.Add(1) // call Add with an argument of 1 to indicate that one goroutine is beginning.\ngo func() {\n  defer wg.Done() // call Done using the defer keyword to ensure that before exiting the goroutine\u2019s closure, indicating to the WaitGroup\n  fmt.Println("1st goroutine sleeping...")\n  time.Sleep(1)\n}()\nwg.Add(1)\ngo func() {\n  defer wg.Done()\n  fmt.Println("2nd goroutine sleeping...")\n  time.Sleep(2)\n}()\nwg.Wait() // call Wait, which will block the main goroutine until all goroutines have indicated they have exited.\nfmt.Println("All goroutines complete.")\n')),(0,a.kt)("p",null,"Notice that the calls to ",(0,a.kt)("inlineCode",{parentName:"p"},"Add")," are done outside the goroutines they\u2019re helping to track. If we didn't do this, we would have introduced a race condition:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Had the calls to ",(0,a.kt)("inlineCode",{parentName:"p"},"Add")," been placed inside the goroutines\u2019 closures, the call to ",(0,a.kt)("inlineCode",{parentName:"p"},"Wait")," could have returned without blocking at all because the calls to ",(0,a.kt)("inlineCode",{parentName:"p"},"Add")," would not have taken place.")),(0,a.kt)("h2",{id:"mutex-and-rwmutex"},(0,a.kt)("inlineCode",{parentName:"h2"},"Mutex")," and ",(0,a.kt)("inlineCode",{parentName:"h2"},"RWMutex")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Mutex")," stands for \u201cmutual exclusion\u201d and is a way to guard critical sections of your program. A ",(0,a.kt)("inlineCode",{parentName:"p"},"Mutex")," provides a concurrent-safe way to express exclusive access to these shared resources. The developers are responsible for coordinating access to this memory by guarding access to it with a mutex."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"To borrow a Goism, whereas channels share memory by communicating, a ",(0,a.kt)("inlineCode",{parentName:"p"},"Mutex")," shares memory by creating a convention developers must follow to synchronize access to the memory.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'var count int\nvar lock sync.Mutex\n\nincrement := func() {\n  lock.Lock() // request exclusive use of the critical section guarded by a `Mutex.lock`.\n  defer lock.Unlock() // indicate that jobs are done with the critical section lock is guarding.\n  count++\n  fmt.Printf("Incrementing: %d\\n", count)\n}\n\ndecrement := func() {\n  lock.Lock() // request exclusive use of the critical section guarded by a `Mutex.lock`.\n  defer lock.Unlock() // indicate that jobs are done with the critical section lock is guarding.\n  count--\n  fmt.Printf("Decrementing: %d\\n", count)\n}\n\n// Increment\nvar arithmetic sync.WaitGroup\nfor i := 0; i <= 5; i++ {\n  arithmetic.Add(1)\n  go func() {\n  defer arithmetic.Done()\n    increment()\n  }()\n}\n\n// Decrement\nfor i: = 0; i <= 5; i++ {\n  arithmetic.Add(1)\n  go func() {\n    defer arithmetic.Done()\n    decrement()\n  }()\n}\narithmetic.Wait()\nfmt.Println("Arithmetic complete.")\n')),(0,a.kt)("p",null,"You\u2019ll notice that we always call ",(0,a.kt)("inlineCode",{parentName:"p"},"Unlock")," within defer statement. This is a very common idiom when utilizing a ",(0,a.kt)("inlineCode",{parentName:"p"},"Mutex")," to ensure the call always happens, even when ",(0,a.kt)("inlineCode",{parentName:"p"},"panicing"),". Failing to do so will probably cause your program to deadlock."),(0,a.kt)("p",null,"Critical sections are so named because they reflect a bottleneck in your program. ",(0,a.kt)("em",{parentName:"p"},"It is somewhat ",(0,a.kt)("strong",{parentName:"em"},"expensive to enter and exit")," a critical section, and so generally people attempt to ",(0,a.kt)("strong",{parentName:"em"},"minimize the time")," spent in critical sections.")),(0,a.kt)("p",null,"One strategy for doing so is to reduce the cross-section of the critical section. There may be memory that needs to be shared between multiple concurrent processes, but perhaps not all of these processes will read and write to this memory. If this is the case, you can take advantage of a different type of mutex: ",(0,a.kt)("inlineCode",{parentName:"p"},"sync.RWMutex"),"."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"sync.RWMutex")," is conceptually the same thing as a Mutex: it guards access to memory; however, You can request a lock for reading, in which case you will be granted access unless the lock is being held for writing. This means that an arbitrary number of readers can hold a reader lock or only a single writer lock."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'producer := func(wg *sync.WaitGroup, l sync.Locker) {\n  defer wg.Done()\n  for i := 5; i > 0; i-- {\n    l.Lock()\n    l.Unlock()\n    time.Sleep(1)\n  }\n}\n\nobserver := func(wg *sync.WaitGroup, l sync.Locker) {\n  defer wg.Done()\n  l.Lock()\n  defer l.Unlock()\n}\n\ntest := func(count int, mutex, rwMutex sync.Locker) time.Duration {\n  var wg sync.WaitGroup\n  wg.Add(count+1)\n  beginTestTime := time.Now()\n  go producer(&wg, mutex)\n  for i := count; i > 0; i-- {\n    go observer(&wg, rwMutex)\n  }\n  wg.Wait()\n  return time.Since(beginTestTime)\n}\n\ntw := tabwriter.NewWriter(os.Stdout, 0, 1, 2, \' \', 0)\ndefer tw.Flush()\n\nvar m sync.RWMutex\nfmt.Fprintf(tw, "Readers\\tRWMutext\\tMutex\\n")\nfor i := 0; i < 20; i++ {\n  count := int(math.Pow(2, float64(i)))\n  fmt.Fprintf(\n    tw,\n    "%d\\t%v\\t%v\\n",\n    count,\n    test(count, &m, m.RLocker()),\n    test(count, &m, &m),\n  )\n}\n')),(0,a.kt)("h2",{id:"cond"},(0,a.kt)("inlineCode",{parentName:"h2"},"Cond")),(0,a.kt)("p",null,"The comment for the ",(0,a.kt)("inlineCode",{parentName:"p"},"Cond")," type really does a great job of describing its purpose:"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Cond")," implements a condition variable, a rendezvous point for goroutines waiting for or announcing the occurrence of an event."),(0,a.kt)("p",null,"In that definition, an \u201cevent\u201d is any arbitrary signal between two or more goroutines that carries no information other than the fact that it has occurred."),(0,a.kt)("p",null,"Very often you\u2019ll want to wait for one of these signals before continuing execution on a goroutine. If we were to look at how to accomplish this without the Cond type, one naive approach to doing this is to use an infinite loop:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"for conditionTrue() == false {\n  time.Sleep(1*time.Millisecond) // using sleep to release the CPU core\n}\n")),(0,a.kt)("p",null,"This is better, but it\u2019s still inefficient, and you have to figure out how long to sleep for: too long, and you\u2019re artificially degrading performance; too short, and you\u2019re unnecessarily consuming too much CPU time. It would be better if there were some kind of way for a goroutine to efficiently sleep until it was signaled to wake and check its condition. This is exactly what the Cond type does for us. Using a ",(0,a.kt)("inlineCode",{parentName:"p"},"Cond"),", we could write the previous examples like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"// instantiate a new `Cond`\n// The `NewCond` function takes in a type that satisfies the `sync.Locker` interface.\n// This is what allows the `Cond` type to facilitate coordination with other goroutines in a concurrent-safe way.\nc := sync.NewCond(&sync.Mutex{})\n\n// lock the Locker for this condition\n// This is necessary because the call to `Wait` automatically\n// calls `Unlock` on the Locker when entered.\nc.L.Lock()\nfor conditionTrue() == false {\n  // wait to be notified that the condition has occurred.\n  // This is a blocking call and the goroutine will be suspended.\n  c.Wait()\n}\n\n// unlock the Locker for this condition.\n// This is necessary because when the call to `Wait` exits,\n// it calls `Lock` on the Locker for the condition\nc.L.Unlock()\n")),(0,a.kt)("p",null,"This approach is much more efficient. Note that the call to Wait doesn't just block, it ",(0,a.kt)("em",{parentName:"p"},"suspends")," the current goroutine, allowing other goroutines to run on the OS thread."),(0,a.kt)("p",null,"A few other things happen when you call ",(0,a.kt)("inlineCode",{parentName:"p"},"Wait"),": upon entering ",(0,a.kt)("inlineCode",{parentName:"p"},"Wait"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Unlock")," is called on the ",(0,a.kt)("inlineCode",{parentName:"p"},"Cond")," variable\u2019s Locker, and upon exiting ",(0,a.kt)("inlineCode",{parentName:"p"},"Wait"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Lock")," is called on the ",(0,a.kt)("inlineCode",{parentName:"p"},"Cond")," variable\u2019s Locker. This is effectively a hidden side effect of the method. It looks like we\u2019re holding this lock the entire time while we wait for the condition to occur, but that\u2019s not actually the case."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// create condition using a standard `sync.Mutex` as the Locker\nc := sync.NewCond(&sync.Mutex{})\n// create a slice with a length of 0, capacity of 10.\nqueue := make([]interface{}, 0, 10)\n\nremoveFromQueue := func(delay time.Duration) {\n  time.Sleep(delay)\n  // enter the critical section for the condition\n  // so we can modify data pertinent to the condition.\n  c.L.Lock()\n\n  // simulate dequeuing an item by reassigning\n  // the head of the slice to the second item\n  queue = queue[1:]\n  fmt.Println("Removed from queue")\n\n  //  exit the condition\u2019s critical section\n  c.L.Unlock()\n\n  // let a goroutine waiting on the condition know that something has occurred\n  c.Signal()\n}\n\nfor i := 0; i < 10; i++ {\n  // enter the critical section for the condition\n  // by calling Lock on the condition\u2019s `Locker`\n  c.L.Lock()\n  // This is important because a signal on the condition\n  // doesn\'t necessarily mean what you\u2019ve been waiting for\n  //  has occurred\u2014only that something has occurred.\n  for len(queue) == 2 {\n\n    // suspend the main goroutine until\n    // a signal on the condition has been sent.\n    c.Wait()\n  }\n  fmt.Println("Adding to queue")\n  queue = append(queue, struct{}{})\n\n  // create a new goroutine that will\n  // dequeue an element after one second\n  go removeFromQueue(1*time.Second)\n\n  // exit the condition\u2019s critical section\n  c.L.Unlock()\n}\n')),(0,a.kt)("p",null,"There's a new method in this example, ",(0,a.kt)("inlineCode",{parentName:"p"},"Signal"),". This is one of two methods that the ",(0,a.kt)("inlineCode",{parentName:"p"},"Cond")," type provides for notifying goroutines blocked on a ",(0,a.kt)("inlineCode",{parentName:"p"},"Wait")," call that the condition has been triggered. The other is a method called ",(0,a.kt)("inlineCode",{parentName:"p"},"Broadcast"),". Internally, the runtime maintains a FIFO list of goroutines waiting to be signaled; ",(0,a.kt)("inlineCode",{parentName:"p"},"Signal")," finds the goroutine that\u2019s been waiting the longest and notifies that, whereas ",(0,a.kt)("inlineCode",{parentName:"p"},"Broadcast")," sends a signal to all goroutines that are waiting."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"In addition, the Cond type is much more performant than utilizing channels.")),(0,a.kt)("p",null,"Like most other things in the sync package, usage of Cond works best when constrained to a tight scope, or exposed to a broader scope through a type that encapsulates it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'/*\n  An example to use `Broadcast`\n\n  We\u2019re creating a GUI application with a button on it.\n  We want to register an arbitrary number of functions\n  that will run when that button is clicked.\n\n  A `Cond` is perfect for this because we can use\n  its `Broadcast` method to notify all registered handlers.\n*/\n\n// define a type `Button` that contains a condition, `Clicked`.\ntype Button struct {\n  Clicked *sync.Cond\n}\n\nbutton := Button{ Clicked: sync.NewCond(&sync.Mutex{}) }\n\n// define a convenience function that will allow us\n// to register functions to handle signals from a condition.\n// Each handler is run on its own goroutine, and subscribe\n// will not exit until that goroutine is confirmed to be running.\nsubscribe := func(c *sync.Cond, fun func()) {\n  var goroutineRunning sync.WaitGroup\n  goroutineRunning.Add(1)\n  go func() {\n    goroutineRunning.Done()\n    c.L.Lock()\n    defer c.L.Unlock()\n    c.Wait()\n    fn()\n  }()\n  goroutineRunning.Wait()\n}\n\n// set a handler for when the mouse button is raised\nvar clickRegistered sync.WaitGroup\nclickRegistered.Add(3)\nsubscribe(button.Clicked, func() {\n  fmt.Println("Maximizing window.")\n  clickRegistered.Done()\n})\n\nsubscribe(button.Clicked, func() {\n  fmt.Println("Displaying annoying dialog box!")\n  clickRegistered.Done()\n})\n\nsubscribe(button.Clicked, func() {\n  fmt.Println("Mouse clicked.")\n  clickRegistered.Done()\n})\n\nbutton.Clicked.Broadcast()\nclickRegistered.Wait()\n')),(0,a.kt)("h2",{id:"once"},"Once"),(0,a.kt)("p",null,"As the name implies, ",(0,a.kt)("inlineCode",{parentName:"p"},"sync.Once")," is a type that utilizes some sync primitives internally to ensure that ",(0,a.kt)("em",{parentName:"p"},"only one call")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"Do")," ever calls the function passed in\u2014even on different goroutines."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'var count int\nincrement := func() {\n  count++\n}\n\nvar once sync.Once\nvar increments sync.WaitGroup\nincrements.Add(100)\nfor i := 0; i < 100; i++ {\n  go func() {\n    defer increments.Done()\n    once.Do(increment)\n  }()\n}\nincrements.Wait()\n// output\n// Count: 1\nfmt.Printf("Count is %d\\n", count)\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'var count int = 10\nincrement := func() { count++ }\ndecrement := func() { count-- }\nvar once sync.Once\nonce.Do(increment)\nonce.Do(decrement)\n// output\n// Count: 11\nfmt.Printf("Count: %d\\n", count)\n')),(0,a.kt)("p",null,"This is because ",(0,a.kt)("inlineCode",{parentName:"p"},"sync.Once")," only counts the number of times ",(0,a.kt)("inlineCode",{parentName:"p"},"Do")," is called, not how many times unique functions passed into ",(0,a.kt)("inlineCode",{parentName:"p"},"Do")," are called. In this way, copies of ",(0,a.kt)("inlineCode",{parentName:"p"},"sync.Once")," are tightly coupled to the functions they are intended to be called with. Check more details in the source file of ",(0,a.kt)("inlineCode",{parentName:"p"},"sync/once"),"."),(0,a.kt)("h2",{id:"pool"},(0,a.kt)("inlineCode",{parentName:"h2"},"Pool")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Pool")," is a concurrent-safe implementation of the object pool pattern."),(0,a.kt)("p",null,"At a high level, the pool pattern is a way to create and make available a fixed number, or pool, of things for use. It\u2019s commonly used to constrain the creation of things that are expensive (e.g., database connections) so that only a fixed number of them are ever created, but an indeterminate number of operations can still request access to these things. In the case of Go\u2019s ",(0,a.kt)("inlineCode",{parentName:"p"},"sync.Pool"),", this data type can be safely used by multiple goroutines."),(0,a.kt)("p",null,"The primary interface of ",(0,a.kt)("inlineCode",{parentName:"p"},"Pool")," is its ",(0,a.kt)("inlineCode",{parentName:"p"},"Get")," method. When called, ",(0,a.kt)("inlineCode",{parentName:"p"},"Get")," will first check whether there are any available instances within the pool to return to the caller, and if not, call its ",(0,a.kt)("inlineCode",{parentName:"p"},"New")," member variable to create a new one. When finished, callers call ",(0,a.kt)("inlineCode",{parentName:"p"},"Put")," to place the instance they were working with back in the pool for use by other processes."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'myPool := &sync.Pool {\n  New: func() interface{} {\n    fmt.Println("Creating new instance.")\n    return struct{}{}\n  }\n}\n\nmyPool.Get()\n\ninstance := myPool.Get()\nmyPool.Put(instance)\nmyPool.Get()\n')),(0,a.kt)("p",null,"So why use a pool and not just instantiate objects as you go? Go has a garbage collector, so the instantiated objects will be automatically cleaned up. What\u2019s the point? Consider this example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'var numCalcsCreated int\ncalcPool := &sync.Pool{\n    New: func() interface{} {\n        numCalcsCreated += 1\n        mem := make([]byte, 1024)\n        // storing the address of the slice of bytes\n        return &mem\n    },\n}\n\ncalcPool.Put(calcPool.New())\ncalcPool.Put(calcPool.New())\ncalcPool.Put(calcPool.New())\ncalcPool.Put(calcPool.New())\n\nconst numWorkers = 1024 * 1024\nvar wg sync.WaitGroup\nwg.Add(numWorkers)\n\nfor i := numWorkers; i > 0; i-- {\n    go func() {\n        defer wg.Done()\n        // asserting the type is a pointer to a slice of bytes\n        mem := calcPool.Get().(*[]byte)\n        defer calcPool.Put(mem)\n    }()\n}\n\nwg.Wait()\n// output: becasue we only have 8 logic processor\n// 8 calculators were created.\nfmt.Printf("%d calculators were created.", numCalcsCreated)\n')),(0,a.kt)("p",null,"Had this example is run without a ",(0,a.kt)("inlineCode",{parentName:"p"},"sync.Pool"),", though the results are nondeterministic, in the worst case it could have been attempting to allocate a gigabyte of memory, but as you see from the output, the real memory allocation is only allocated 4 KB."),(0,a.kt)("p",null,"Another common situation where a ",(0,a.kt)("inlineCode",{parentName:"p"},"Pool")," is useful is for ",(0,a.kt)("em",{parentName:"p"},"warming a cache of pre-allocated objects")," for operations that must run as quickly as possible. In this case, instead of trying to guard the host machine\u2019s memory by constraining the number of objects created, we\u2019re trying to guard consumers\u2019 time by front-loading the time it takes to get a reference to another object."),(0,a.kt)("p",null,"This is very common when writing high- throughput network servers that attempt to respond to requests as quickly as possible. Checkout this example:"),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("p",null,"A service that don't use ",(0,a.kt)("inlineCode",{parentName:"p"},"sync.Pool"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// simulates creating a connection to a service\nfunc connectToService() interface{} {\n  time.Sleep(1*time.Second)\n  return struct{}{}\n}\n\n// a network handler that opens a connection\n// to another service for every connection\n// the network handler accepts.\nfunc startNetworkDaemon() *sync.WaitGroup {\n  var wg sync.WaitGroup\n  wg.Add(1)\n  go func() {\n    server, err := net.Listen("tcp", "localhost:8080")\n    if err != nil {\n      log.Fatalf("cannot listen: %v", err)\n    }\n    defer server.Close()\n    wg.Done()\n    for {\n      conn, err := server.Accept()\n      if err != nil {\n        log.Printf("cannot accept connection: %v", err)\n        continue\n      }\n      connectToService()\n      fmt.Fprintln(conn, "")\n      conn.Close()\n    }\n  }()\n  return &wg\n}\n\n// test functions\nfunc init() {\n  daemonStarted := startNetworkDaemon()\n  daemonStarted.Wait()\n}\n\nfunc BenchmarkNetworkRequest(b *testing.B) {\n  for i := 0; i < b.N; i++ {\n    conn, err := net.Dial("tcp", "localhost:8080")\n    if err != nil {\n      b.Fatalf("cannot dial host: %v", err)\n    }\n    if _, err := ioutil.ReadAll(conn); err != nil {\n      b.Fatalf("cannot read: %v", err)\n    }\n    conn.Close()\n  }\n}\n'))),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("p",null,"A service that use ",(0,a.kt)("inlineCode",{parentName:"p"},"sync.Pool")," to host connections to the fictitious service.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'func connectToService() interface{} {\n  time.Sleep(1*time.Second)\n  return struct{}{}\n}\n\nfunc warServiceConnCache() *sync.Pool {\n  p := &sync.Pool {\n      New: connectToService,\n  }\n\n  for i := 0; i < 10; i++ {\n      p.Put(p.New())\n  }\n  return p\n}\n\nfunc startNetworkDaemon() *sync.WaitGroup {\n  var wg sync.WaitGroup\n  wg.Add(1)\n  go func() {\n      connPool := warServiceConnCache()\n      server, err := net.Listen("tcp", "localhost:9090")\n\n      if err != nil {\n          log.Fatal("cannot listen: %v", err)\n      }\n      defer server.Close()\n\n      wg.Done()\n\n      for {\n          conn, err := server.Accept()\n          if err != nil {\n              log.Printf("cannot accept connection: %v", err)\n              continue\n          }\n          svcConn := connPool.Get()\n          fmt.Fprintln(conn, "")\n          connPool.Put(svcConn)\n          conn.Close()\n      }\n  }()\n  return &wg\n}\n\n// test functions\nfunc init() {\n  daemonStarted := startNetworkDaemon()\n  daemonStarted.Wait()\n}\n\nfunc BenchmarkNetworkRequest(b *testing.B) {\n  for i := 0; i < b.N; i++ {\n    conn, err := net.Dial("tcp", "localhost:8080")\n    if err != nil {\n      b.Fatalf("cannot dial host: %v", err)\n    }\n    if _, err := ioutil.ReadAll(conn); err != nil {\n      b.Fatalf("cannot read: %v", err)\n    }\n    conn.Close()\n  }\n}\n'))),(0,a.kt)("p",null,"The object pool design pattern is best used either when you have concurrent processes that require objects, but dispose of them very rapidly after instantiation, or when construction of these objects could negatively impact memory."),(0,a.kt)("p",null,"So when working with a Pool, just remember the following points:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"When instantiating ",(0,a.kt)("inlineCode",{parentName:"p"},"sync.Pool"),", give it a ",(0,a.kt)("inlineCode",{parentName:"p"},"New")," member variable that is thread-safe when called.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"When you receive an instance from ",(0,a.kt)("inlineCode",{parentName:"p"},"Get"),", make no assumptions regarding the state of the object you receive back.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Make sure to call ",(0,a.kt)("inlineCode",{parentName:"p"},"Put")," when you\u2019re finished with the object you pulled out of the pool. Otherwise, the ",(0,a.kt)("inlineCode",{parentName:"p"},"Pool")," is useless. Usually this is done with ",(0,a.kt)("inlineCode",{parentName:"p"},"defer"),".")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Objects in the pool must be roughly uniform in makeup."))),(0,a.kt)("h2",{id:"channels"},"Channels"),(0,a.kt)("p",null,"Channels are one of the synchronization primitives in Go derived from Hoare\u2019s CSP. While they can be used to synchronize access of the memory, they are best used to communicate information between goroutines."),(0,a.kt)("p",null,"Like a river, a channel serves as a conduit for a stream of information; values may be passed along the channel, and then read out downstream. When using channels, you\u2019ll pass a value into a ",(0,a.kt)("inlineCode",{parentName:"p"},"chan")," variable, and then somewhere else in your program read it off the channel. The disparate parts of your program don't require knowledge of each other, only a reference to the same place in memory where the channel resides. This can be done by passing references of channels around your program."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"var readOnlyStream <-chan interface{}\nreadOnlyStream := make(<-chan interface{})\n\nvar sendOnlyStream chan<- interface{}\nsendOnlyStream := make(chan<- interface{})\n\nvar receiveChan <-chan interface{}\nvar sendChan chan<- interface{}\ndataStream := make(chan interface{})\n// Valid statements:\nreceiveChan = dataStream\nsendChan = dataStream\n")),(0,a.kt)("p",null,"It's not often to see unidirectional channels instantiated, but often them are used as function parameters and return types, which is very useful. This is possible because Go will implicitly convert bidirectional channels to unidirectional channels when needed."),(0,a.kt)("p",null,"The channels in Go are said to be blocking:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Any goroutine that attempts to write to a channel that is full will wait until the channel has been emptied")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Any goroutine that attempts to read from a channel that is empty will wait until at least one item is placed on it"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'value, ok := <-someStream\n// (true): Hello channels\nfmt.Printf("(%v): %v", ok, value)\n\nintStream := make(chan int)\ngo func () {\n  intStream <- 3\n  intStream <- 1\n  close(intStream)\n}\nfor {\n  integer, ok := <- intStream\n  fmt.Printf("(%v): %v", ok, integer)\n}\n// output:\n// (true): 3\n// (true): 1\n// (false): 0\n// (false): 0\n// ... forever (false):0\n')),(0,a.kt)("p",null,"The second return value is a way for a read operation to indicate whether the read off the channel was a value generated by a write elsewhere in the process, or a default value generated from a closed channel."),(0,a.kt)("p",null,"This opens up a few new patterns for us. The first is ranging over a channel. The ",(0,a.kt)("inlineCode",{parentName:"p"},"range")," keyword\u2014used in conjunction with the ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," statement\u2014supports channels as arguments, and will automatically break the loop when a channel is closed. This allows for concise iteration over the values on a channel."),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("p",null,"Some examples.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'intStream := make(chan int)\ngo func() {\n  defer close(intStream)\n  for i := 1; i <= 5; i++ {\n    intStream <- i\n  }\n}()\n\nfor integer := range intStream {\n  fmt.Printf("%v ", integer)\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'begin := make(chan interface{})\nvar wg sync.WaitGroup\nfor i := 0; i < 5 ; i++ {\n  wg.Add(1)\n  go func(i int) {\n    defer wg.Done()\n    <-begin\n    fmt.Printf("%v has begun\\n", i)\n  }(i)\n}\n\nfmt.Println("Unblocking goroutines...")\nclose(begin)\nwg.Wait()\nfmt.Println("Program exiting")\n'))),(0,a.kt)("p",null,"We can also create ",(0,a.kt)("em",{parentName:"p"},"buffered channels"),", which are channels that are given a capacity when they\u2019re instantiated. This means that even if no reads are performed on the channel, a goroutine can still perform n writes. Here\u2019s how to declare and instantiate one:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"// we can place four things onto the channel\n// regardless of whether it\u2019s being read from\nvar dataStream chan interface{}\ndataStream = make(chan interface{}, 4)\n\n// equivalent statement\na := make(chan int)\nb := make(chan int, 0)\n")),(0,a.kt)("p",null,"The declaration of a buffered channel is no different from an unbuffered one. Unbuffered channels are also defined in terms of buffered channels: an unbuffered channel is simply a buffered channel created with a capacity of 0."),(0,a.kt)("p",null,"It also bears mentioning that if a buffered channel is empty and has a receiver, the buffer will be bypassed and the value will be passed directly from the sender to the receiver. In practice, this happens transparently, but it\u2019s worth knowing for understanding the performance profile of buffered channels."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'// it\u2019s a little faster than writing to stdout directly.\nvar stdoutBuff bytes.Buffer\n\n// ensure that the buffer is written out\n// to stdout before the process exits.\ndefer stdoutBuff.WriteTo(os.Stdout)\n\n// create a buffered channel with a capacity of 4\n// change the capacity, the output will change\n// because the channel is buffered with size\nintStream := make(chan int, 4)\ngo func() {\n  defer close(intStream)\n  defer fmt.Fprintln(&stdoutBuff, "Producer Done.")\n  for i := 0; i < 5 ; i++ {\n    fmt.Fprintf(&stdoutBuff, "Sending: %d\\n", i)\n    intStream <- i\n  }\n}()\n\nfor integer := range intStream {\n  fmt.Fprintf(&stdoutBuff, "Recevied %v.\\n", integer)\n}\n')),(0,a.kt)("img",{src:"./channel-operation.png",alt:"Result of channel operations given a channel's state"}),(0,a.kt)("p",null,"The first thing we should do to put channels in the right context is to assign channel ",(0,a.kt)("em",{parentName:"p"},"ownership"),". The ",(0,a.kt)("em",{parentName:"p"},"ownership")," is defined as being a goroutine that instantiates, writes, and closes a channel. Unidirectional channel declarations are the tool that will allow us to distinguish between goroutines that own channels and those that only utilize them: channel owners have a write-access view into the channel (",(0,a.kt)("inlineCode",{parentName:"p"},"chan")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"chan<-"),"), and channel utilizers only have a read-only view into the channel (",(0,a.kt)("inlineCode",{parentName:"p"},"<-chan"),")."),(0,a.kt)("p",null,"The goroutine that owns a channel should:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Instantiate the channel."),(0,a.kt)("li",{parentName:"ol"},"Perform writes, or pass ownership to another goroutine."),(0,a.kt)("li",{parentName:"ol"},"Close the channel."),(0,a.kt)("li",{parentName:"ol"},"Encapsulate the previous three things in this list and expose them via a reader channel.")),(0,a.kt)("p",null,"As a consumer of a channel, two things draw our attention:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Knowing when the channel is closed.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Responsibly handling blocking for any reason."))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'chanOwner := func() <-chan int {\n  // instantiate a buffered channel.\n  // Since we know we\u2019ll produce six results,\n  // we create a buffered channel of 5\n  // so that the goroutine can complete as quickly as possible.\n  resultStream := make(chan int, 5)\n\n  go func() {\n    // ensure to close the channel once we finished usages\n    defer close(resultStream)\n    for i := 0; i <= 5; i ++ {\n      resultStream <- i\n    }\n  }()\n  // return read-only channel for consumers\n  return resultStream\n}\n\nresultStream := chanOwner()\nfor result := range resultStream {\n  fmt.Printf("Received: %d\\n", result)\n}\nfmt.Println("Done Receiving!")\n')),(0,a.kt)("p",null,"In many ways, channels are the glue that binds goroutines together."),(0,a.kt)("h2",{id:"the-select-statement"},"The ",(0,a.kt)("inlineCode",{parentName:"h2"},"select")," Statement"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"select")," statement is the glue that binds channels together; it\u2019s how we\u2019re able to compose channels together in a program to form larger abstractions."),(0,a.kt)("p",null,"In addition to joining components, at these critical junctures in your program, select statements can help safely bring channels together with concepts like cancellations, timeouts, waiting, and default values."),(0,a.kt)("p",null,"Just like a ",(0,a.kt)("inlineCode",{parentName:"p"},"switch")," block, a ",(0,a.kt)("inlineCode",{parentName:"p"},"select")," block encompasses a series of ",(0,a.kt)("inlineCode",{parentName:"p"},"case")," statements that guard a series of statements."),(0,a.kt)("p",null,"However, ",(0,a.kt)("inlineCode",{parentName:"p"},"case")," statements in a ",(0,a.kt)("inlineCode",{parentName:"p"},"select")," block aren't tested sequentially, and execution won't automatically fall through if none of the criteria are met. Instead, all channel reads and writes are considered simultaneously to see if any of them are ready: populated or closed channels in the case of reads, and channels that are not at capacity in the case of writes. If none of the channels are ready, the entire select statement blocks. Then when one the channels is ready, that operation will proceed, and its corresponding statements will execute. If more than one channel are ready, the Go runtime will perform a pseudo-random uniform selection over the set of case statements."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'start := time.Now()\nc := make(chan interface{})\ngo func() {\n  time.Sleep(5 * time.Second)\n  close(c)\n}()\n\nfmt.Println("Blocking or read...")\nselect {\ncase <-c:\n  fmt.Printf("Unblocked %v later.\\n", time.Since(start))\n}\n// output:\n// Blocking on read...\n// Unblocked 5.000170047s later.\n')),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("p",null,"We introduce a random variable into your equation\u2014in this case, which channel to select from. By weighting the chance of each channel being utilized equally, all Go programs that utilize the select statement will perform well in the average case.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'c1 := make(chan interface{})\nclose(c1)\nc2 := make(chan interface{})\nclose(c2)\nvar c1Count, c2Count int\nfor i := 1000; i >= 0; i-- {\n  select {\n  case <-c1:\n    c1Count++\n  case <-c1:\n    c1Count++\n  case <-c2:\n    c2Count++\n  }\n}\nfmt.Printf("c1Count: %d\\nc2Count: %d\\n", c1Count, c2Count)\n// c1Count is almost twice c2Count\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'c1 := make(chan interface{})\nclose(c1)\nc2 := make(chan interface{})\nclose(c2)\nvar c1Count, c2Count int\nfor i := 1000; i >= 0; i-- {\n  select {\n  case <-c1:\n    c1Count++\n  case <-c2:\n    c2Count++\n  }\n}\nfmt.Printf("c1Count: %d\\nc2Count: %d\\n", c1Count, c2Count)\n// c1 is almost same as c2Count\n'))),(0,a.kt)("p",null,"Go\u2019s time package provides an elegant way to do timeout problem with channels that fits nicely within the paradigm of select statements. The ",(0,a.kt)("inlineCode",{parentName:"p"},"time.After")," function takes in a ",(0,a.kt)("inlineCode",{parentName:"p"},"time.Duration")," argument and returns a channel that will send the current time after the duration."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'var c <-chan int\nselect {\ncase <-c:\ncase <- time.After(1 * time.Second):\n  fmt.Println("Timed out.")\n}\n')),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("p",null,"Like ",(0,a.kt)("inlineCode",{parentName:"p"},"case")," statements, the ",(0,a.kt)("inlineCode",{parentName:"p"},"select")," statement also allows for a ",(0,a.kt)("inlineCode",{parentName:"p"},"default")," clause in case you\u2019d like to do something if all the channels you\u2019re selecting against are blocking."),(0,a.kt)("p",null,"A ",(0,a.kt)("inlineCode",{parentName:"p"},"default")," clause used in conjunction with a for-select loop. This allows a goroutine to make progress on work while waiting for another goroutine to report a result.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'done := make(chan interface{})\ngo func() {\n  time.Sleep(5*time.Second)\n  close(done)\n}()\nworkCounter := 0\nloop:\nfor {\n  select {\n  case <-done:\n    break loop\n  default:\n    // don\'t block these code,\n    // let the control flow\n  }\n  // Simulate work\n  workCounter++\n  time.Sleep(1*time.Second)\n}\n\nfmt.Printf("Achieved %v cycles of work before signalled to stop.\\n", workCounter)\n// output:\n// Achieved 5 cycles of work before signalled to stop.\n'))),(0,a.kt)("p",null,"Finally, there is a special case for empty select statements: select statements with no case clauses. These look like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"select {}\n")),(0,a.kt)("p",null,"This statement will simply block forever."))}h.isMDXComponent=!0}}]);