"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3886],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=p(t),m=i,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||r;return t?a.createElement(h,l(l({ref:n},u),{},{components:t})):a.createElement(h,l({ref:n},u))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[c]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},22084:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=t(87462),i=(t(67294),t(3905));const r={title:"09 Variables",tags:["lisp","interpreter"]},l=void 0,o={unversionedId:"lisp-interpreter-in-c/variables",id:"lisp-interpreter-in-c/variables",title:"09 Variables",description:"document",source:"@site/docs/lisp-interpreter-in-c/09-variables.md",sourceDirName:"lisp-interpreter-in-c",slug:"/lisp-interpreter-in-c/variables",permalink:"/docs/lisp-interpreter-in-c/variables",draft:!1,tags:[{label:"lisp",permalink:"/docs/tags/lisp"},{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",sidebarPosition:9,frontMatter:{title:"09 Variables",tags:["lisp","interpreter"]},sidebar:"tutorialSidebar",previous:{title:"08 Q-Expressions",permalink:"/docs/lisp-interpreter-in-c/q-expressions"},next:{title:"10 Functions",permalink:"/docs/lisp-interpreter-in-c/functions"}},s={},p=[{value:"Immutability",id:"immutability",level:2},{value:"Symbol Syntax",id:"symbol-syntax",level:2},{value:"Function Pointers",id:"function-pointers",level:2},{value:"Cyclic Types",id:"cyclic-types",level:2},{value:"Function Type",id:"function-type",level:2},{value:"Environment",id:"environment",level:2},{value:"Variable Evaluation",id:"variable-evaluation",level:2},{value:"Builtins",id:"builtins",level:2},{value:"Define Function",id:"define-function",level:2},{value:"Error Reporting",id:"error-reporting",level:2}],u={toc:p};function c(e){let{components:n,...r}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,r,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"http://www.buildyourownlisp.com/chapter11_variables"},"document")),(0,i.kt)("p",null,"codes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{target:"_blank",href:t(58349).Z},"variables"))),(0,i.kt)("h2",{id:"immutability"},"Immutability"),(0,i.kt)("p",null,"We are adding some new features to the language. In this chapter, we add ",(0,i.kt)("strong",{parentName:"p"},"variables"),"."),(0,i.kt)("p",null,"The variables are ",(0,i.kt)("strong",{parentName:"p"},"immutable")," meaning they cannot change. Actually the variables are simply a way of ",(0,i.kt)("strong",{parentName:"p"},"naming values"),". They let us assign a ",(0,i.kt)("strong",{parentName:"p"},"name")," to a ",(0,i.kt)("strong",{parentName:"p"},"value"),", and then let us get a copy of that ",(0,i.kt)("strong",{parentName:"p"},"value")," later on when we need it."),(0,i.kt)("p",null,"To allow for ",(0,i.kt)("strong",{parentName:"p"},"naming values")," we need to create a structure which stores the name and value of everything named in our program. We call this the ",(0,i.kt)("strong",{parentName:"p"},"environment"),". When we start a new interactive prompt we want to create a new environment to go along with it, in which each new bit of input is evaluated. Then we can store and recall variables as we program."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"What happens when we re-assign a name to something new? Isn't this like mutability?"),(0,i.kt)("p",{parentName:"blockquote"},"In our Lisp, when we re-assign a name we're going to delete the old association and create a new one. This gives the illusion that the thing assigned to that name has changed, and is mutable, but in fact we have deleted the old thing and assigned it a new thing. This is different to C where we really can change the data pointed to by a pointer, or stored in a struct, without deleting it and creating a new one.")),(0,i.kt)("h2",{id:"symbol-syntax"},"Symbol Syntax"),(0,i.kt)("p",null,"Now that we're going to allow for user defined variables we need to update the grammar for symbols to be more flexible. Rather than just our builtin functions it should match any possible valid symbol. Unlike in C, where the name a variable can be given is fairly restrictive, we're going to allow for all sorts of characters in the name of a variable."),(0,i.kt)("p",null,"We can create a regular expression that expresses the range of characters available as follows."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"/[a-zA-Z0-9_+\\\\-*\\\\/\\\\\\\\=<>!&]+/\n")),(0,i.kt)("p",null,"At first glance this looks like we've just bashed our hands into keyboards. Actually it is a regular expression using a big range specifier ",(0,i.kt)("inlineCode",{parentName:"p"},"[]"),". Inside range specifiers special characters lose their meaning, but some of these characters still need to be escaped with backslashes. Because this is part of a C string we need to put two backslashes to represent a single backslash character in the input."),(0,i.kt)("p",null,"This rule lets symbols be any of the normal C identifier characters ",(0,i.kt)("inlineCode",{parentName:"p"},"a-zA-Z0-9_")," the arithmetic operator characters ",(0,i.kt)("inlineCode",{parentName:"p"},"+\\\\-*\\\\/")," the backslash character ",(0,i.kt)("inlineCode",{parentName:"p"},"\\\\\\\\")," the comparison operator characters ",(0,i.kt)("inlineCode",{parentName:"p"},"=<>!")," or an ampersands ",(0,i.kt)("inlineCode",{parentName:"p"},"&"),". This will give us all the flexibility we need for defining new and existing symbols."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"mpca_lang(MPCA_LANG_DEFAULT,\n    \"\\\n        number: /-?[0-9]+/ ;\n        symbol: /[a-zA-Z0-9_+\\\\-*\\\\/\\\\\\\\=<>!&]+/ ;\\\n        sexpr: '(' <expr>* ')'; \\\n        qexpr: '{' <expr>* '}'; \\\n        expr: <number> | <symbol> | <sexpr> | <qexpr>; \\\n        lispy: /^/ <expr>* /$/; \\\n    \",\n    Number, Symbol, Sexpr, Qexpr, Expr, Lispy);\n")),(0,i.kt)("h2",{id:"function-pointers"},"Function Pointers"),(0,i.kt)("p",null,"Once we introduce variables, symbols will no longer represent functions in our language, but rather they will represent a name for us to look up into our environment and get some new value back from."),(0,i.kt)("p",null,"Therefore, we need a new value to represent functions in our language, which we can return once one of the builtin symbols is encountered. To create this new type of ",(0,i.kt)("inlineCode",{parentName:"p"},"lval")," we are going to use something called a ",(0,i.kt)("strong",{parentName:"p"},"function pointer"),"."),(0,i.kt)("p",null,"Function pointers are a great feature of C that lets you store and pass around pointers to functions. It doesn't make sense to edit the data pointed to by these pointers. Instead, we use them to call the function they point to, as if it were a normal function."),(0,i.kt)("p",null,"Like normal pointers, function pointers have some type associated with them. This type specifies the type of the function pointed to, not the type of the data pointed to. This lets the compiler work out if it has been called correctly."),(0,i.kt)("p",null,"In the previous chapter our builtin functions took a ",(0,i.kt)("inlineCode",{parentName:"p"},"lval*")," as input and returned a ",(0,i.kt)("inlineCode",{parentName:"p"},"lval*")," as output. In this chapter our builtin functions will take an extra pointer to the environment ",(0,i.kt)("inlineCode",{parentName:"p"},"lenv*")," as input. We can declare a new function pointer type called ",(0,i.kt)("inlineCode",{parentName:"p"},"lbuiltin"),", for this type of function, like this."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"typedef lval*(*lbuiltin)(lenv*, lval*);\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Why is that syntax so odd?"),(0,i.kt)("p",{parentName:"blockquote"},"In some places the syntax of C can look particularly weird. It can help if we understand exactly why the syntax is like this. Let us de-construct the syntax in the example above part by part."),(0,i.kt)("p",{parentName:"blockquote"},"First the ",(0,i.kt)("inlineCode",{parentName:"p"},"typedef"),". This can be put before any standard variable declaration. It results in the name of the variable, being declared a new type, matching what would be the inferred type of that variable. This is why in the above declaration what looks like the function name becomes the new type name."),(0,i.kt)("p",{parentName:"blockquote"},"Next all those ",(0,i.kt)("inlineCode",{parentName:"p"},"*"),". Pointer types in C are actually meant to be written with the star ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," on the left-hand side of the variable name, not the right-hand side of the type ",(0,i.kt)("inlineCode",{parentName:"p"},"int *x"),';. This is because C type syntax works by a kind of inference. Instead of reading "Create a new ',(0,i.kt)("inlineCode",{parentName:"p"},"int")," pointer ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),'". It is meant to read "Create a new variable ',(0,i.kt)("inlineCode",{parentName:"p"},"x")," where to dereference ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," results in an ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),'." Therefore ',(0,i.kt)("inlineCode",{parentName:"p"},"x")," is inferred to be a pointer to an ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),"."),(0,i.kt)("p",{parentName:"blockquote"},'This idea is extended to function pointers. We can read the above declaration as follows. "To get an ',(0,i.kt)("inlineCode",{parentName:"p"},"lval*")," we dereference ",(0,i.kt)("inlineCode",{parentName:"p"},"lbuiltin")," and call it with a ",(0,i.kt)("inlineCode",{parentName:"p"},"lenv*")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"lval*"),'." Therefore ',(0,i.kt)("inlineCode",{parentName:"p"},"lbuiltin")," must be a function pointer that takes an ",(0,i.kt)("inlineCode",{parentName:"p"},"lenv*")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"lval*")," and returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"lval*"),".")),(0,i.kt)("h2",{id:"cyclic-types"},"Cyclic Types"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"lbuiltin")," type references the ",(0,i.kt)("inlineCode",{parentName:"p"},"lval")," type and the ",(0,i.kt)("inlineCode",{parentName:"p"},"lenv")," type. This means that they should be declared first in the source file."),(0,i.kt)("p",null,"But we want to make a ",(0,i.kt)("inlineCode",{parentName:"p"},"lbuiltin")," field in our ",(0,i.kt)("inlineCode",{parentName:"p"},"lval")," struct so we can create function values. So, our ",(0,i.kt)("inlineCode",{parentName:"p"},"lbuiltin")," declaration must go before our ",(0,i.kt)("inlineCode",{parentName:"p"},"lval")," declaration. This leads to what is called a cyclic type dependency, where two types depend on each other."),(0,i.kt)("p",null,"We've come across this problem before with functions which depend on each other. The solution was to create a ",(0,i.kt)("strong",{parentName:"p"},"forward declaration")," which declared a function but left the body of it empty."),(0,i.kt)("p",null,"In C we can do exactly the same with types. First we declare two ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," types without a body. Secondly we typedef these to the names ",(0,i.kt)("inlineCode",{parentName:"p"},"lval")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"lenv"),". Then we can define our ",(0,i.kt)("inlineCode",{parentName:"p"},"lbuiltin")," function pointer type. And finally we can define the body of our ",(0,i.kt)("inlineCode",{parentName:"p"},"lval")," struct. Now all our type issues are resolved and the compiler won't complain anymore."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"struct lval;\nstruct lenv;\ntypedef struct lval lval;\ntypedef struct lenv lenv;\n\nenum { LVAL_ERR, LVAL_NUM, LVAL_SYM, LVAL_FUN, LVAL_SEXPR, LVAL_QEXPR };\n\ntypedef lval*(*lbuiltin)(lenv*, lval*);\n\nstruct lval {\n    int type;\n    long num;\n    char* err;\n    char* sym;\n    lbuiltin fun;\n\n    int count;\n    lval** cell;\n};\n")),(0,i.kt)("h2",{id:"function-type"},"Function Type"),(0,i.kt)("p",null,"As we've added a new possible ",(0,i.kt)("inlineCode",{parentName:"p"},"lval")," type with the enumeration ",(0,i.kt)("inlineCode",{parentName:"p"},"LVAL_FUN"),". We should update all our relevant functions that work on ",(0,i.kt)("inlineCode",{parentName:"p"},"lvals")," to deal correctly with this update. In most cases this just means inserting new cases into switch statements."),(0,i.kt)("p",null,"We can start by making a new constructor function for this type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"lval* lval_fun(lbuiltin func) {\n    lval* v = malloc(sizeof(lval));\n    v->type = LVAL_FUN;\n    v->fun = func;\n    return v;\n}\n")),(0,i.kt)("p",null,"On ",(0,i.kt)("inlineCode",{parentName:"p"},"lval_del"),", we don't need to do anything special for function pointers."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"case LVAL_FUN: break;\n")),(0,i.kt)("p",null,"On ",(0,i.kt)("inlineCode",{parentName:"p"},"lval_print"),", we can just print out a nominal string."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'case LVAL_FUN: printf("<function>"); break;\n')),(0,i.kt)("p",null,"We're also going to add a new function for ",(0,i.kt)("strong",{parentName:"p"},"copying")," an ",(0,i.kt)("inlineCode",{parentName:"p"},"lval"),". This is going to come in useful when we put things into, and take things out of, the environment."),(0,i.kt)("p",null,"For numbers and functions we can just copy the relevant fields directly. For strings we need to copy using ",(0,i.kt)("inlineCode",{parentName:"p"},"malloc")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"strcpy"),". To copy lists we need to allocate the correct amount of space and then copy each element individually."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"lval* lval_copy(lval* v) {\n    lval* x = malloc(sizeof(lval));\n    x->type = v->type;\n\n    switch (v->type) {\n        /* Copy Functions and Numbers directly */\n        case LVAL_FUN: x->fun = v->fun; break;\n        case LVAL_NUM: x->num = v->num; break;\n\n        /* Copy Strings using malloc and strcpy */\n        case LVAL_ERR:\n            x->err = malloc(strlen(v->err)+1);\n            strcpy(x->err, v->err); break;\n\n        case LVAL_SYM:\n            x->sym = malloc(strlen(v->sym) + 1);\n            strcpy(x->sym, v->sym); break;\n\n        /* Copy Lists by coping each sub-expression */\n        case LVAL_SEXPR:\n        case LVAL_QEXPR:\n            x->count = v->count;\n            x->cell = malloc(sizeof(lval*) * x->count);\n            for(int i = 0; i < x->count; i++) {\n                x->cell[i] = lval_copy(v->cell[i]0;\n            }\n            break;\n    }\n\n    return x;\n}\n")),(0,i.kt)("h2",{id:"environment"},"Environment"),(0,i.kt)("p",null,"The environment structure must encode a list of relationships between ",(0,i.kt)("strong",{parentName:"p"},"names")," and ",(0,i.kt)("strong",{parentName:"p"},"values"),". There are many ways to build a structure that can do this sort of thing. We are going to go for the simplest possible method that works well. This is to use two lists of equal length. One is a list of ",(0,i.kt)("inlineCode",{parentName:"p"},"lval*"),", and the other is a list of ",(0,i.kt)("inlineCode",{parentName:"p"},"char*"),". Each entry in one list has a corresponding entry in the other list at the same position."),(0,i.kt)("p",null,"We've already forward declared the ",(0,i.kt)("inlineCode",{parentName:"p"},"lenv")," struct, so it's time to define it as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"strcut lenv {\n    int count;\n    char** syms;\n    lval** vals;\n};\n")),(0,i.kt)("p",null,"We need some functions to create and delete this structure. Creation initialises the struct fields, while deletion iterates over the items in both lists and deletes or frees them."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"lenv* lenv_new(void) {\n    lenv* e = malloc(sizeof(lenv));\n    e->count = 0;\n    e->syms = NULL;\n    e->vals = NULL;\n    return e;\n}\n\nvoid lenv_del(lenv* e) {\n    for (int i = 0; i< e->count; i++) {\n        free(e->syms[i]);\n        lval_del(e->vals[i]);\n    }\n    free(e->syms);\n    free(e->vals);\n    free(e);\n}\n")),(0,i.kt)("p",null,"Next we can create two functions that either get values from the environment or put values into it."),(0,i.kt)("p",null,"To get a value from the environment we loop over all the items in the environment and check if the given symbol matches any of the stored strings. If we find a match we can return a copy of the stored value. If no match is found we should return an error."),(0,i.kt)("p",null,"The function for putting new variables into the environment is a little more complex. First we want to check if a variable with the same name already exists. If this is the case we should replace its value with the new one. To do this we loop over all the existing variables in the environment and check their name. If a match is found we delete the value stored at that location, and store there a copy of the input value."),(0,i.kt)("p",null,"If no existing value is found with that name, we need to allocate some more space to put it in. For this we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"realloc"),", and store a copy of the ",(0,i.kt)("inlineCode",{parentName:"p"},"lval")," and its name at the newly allocated locations."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'lval* lenv_get(lenv* e, lval* k) {\n    for (int i = 0; i < e->count; i++ ) {\n        if (strcmp(e->syms[i], k->sym) == 0) {\n            return lval_copy(e->vals[i]);\n        }\n    }\n\n    return lval_err("unbound symbol!");\n}\n\nvoid lenv_put(lenv* e, lval* k, lval* v) {\n    for (int i = 0; i < e->count; i++ ) {\n        if (strcmp(e->sym[i], k->sym) == 0) {\n            lval_del(e->vals[i]);\n            e->vals[i] = lval_copy(v);\n            return;\n        }\n    }\n\n    e->count++;\n    e->vals = realloc(e->vals, sizeof(lval*) * e->count);\n    e->syms = realloc(e->syms, sizeof(char*) * e->count);\n\n    e->vals[e->count-1] = lval_copy(v);\n    e->syms[e->count-1] = malloc(strlen(k->sym)+1);\n    strcpy(e->syms[e->count-1], k->sym);\n}\n')),(0,i.kt)("h2",{id:"variable-evaluation"},"Variable Evaluation"),(0,i.kt)("p",null,"The evaluation function now depends on some environment. We should pass this in as an argument and use it to get a value if we encounter a symbol type. Because our environment returns a copy of the value we need to remember to delete the input symbol ",(0,i.kt)("inlineCode",{parentName:"p"},"lval"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"lval* lval_eval(lenv* e, lval* v) {\n    if (v->type == LVAL_SYM) {\n        lval* x = lenv_get(e, v);\n        lval_del(v);\n        return x;\n    }\n\n    if (v->type == LVAL_SEXPR) { return lval_eval_sexpr(e, v); }\n\n    return v;\n}\n")),(0,i.kt)("p",null,"Because we've added a function type, our evaluation of S-Expressions also needs to change. Instead of checking for a symbol type we want to ensure it is a function type. If this condition holds we can call the ",(0,i.kt)("inlineCode",{parentName:"p"},"fun")," field of the ",(0,i.kt)("inlineCode",{parentName:"p"},"lval")," using the same notation as standard function calls."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'lval* lval_eval_sexpr(lenv* e, lval* v) {\n    for (int i = 0; i < v->count; i++) {\n        v->cell[i] = lval_eval(e, v->cell[i]);\n    }\n\n    for (int i = 0; i < v->count; i++) {\n        if (v->cell[i]->type == LVAL_ERR) { return lval_take(v, i);\n    }\n\n    if (v->count == 0) { return v; }\n    if (v->count == 1) { return lval_take(v, 0); }\n\n    lval* f = lval_pop(v, 0);\n\n    if (f->type != LVAL_FUN) {\n        lval_del(v);\n        lval_del(f);\n        return lval_err("first element is not a function");\n    }\n\n    lval* result = f->fun(e,v);\n    lval_del(f);\n    return result;\n}\n')),(0,i.kt)("h2",{id:"builtins"},"Builtins"),(0,i.kt)("p",null,"Now that our evaluation relies on the new function type we need to make sure we can register all of our builtin functions with the environment before we start the interactive prompt. At the moment our builtin functions are not the correct type. We need to change their type signature such that they take in some environment, and where appropriate change them to pass this environment into other calls that require it."),(0,i.kt)("p",null,"Once we've changed the builtins to the correct type we can create a function that registers all of our builtins into an environment."),(0,i.kt)("p",null,"For each builtin we want to create a function ",(0,i.kt)("inlineCode",{parentName:"p"},"lval")," and symbol ",(0,i.kt)("inlineCode",{parentName:"p"},"lval")," with the given name. We then register these with the environment using ",(0,i.kt)("inlineCode",{parentName:"p"},"lenv_put"),". The environment always takes or returns copies of values, so we need to remember to delete these two ",(0,i.kt)("inlineCode",{parentName:"p"},"lval")," after registration as we don't need them anymore."),(0,i.kt)("p",null,"If we split this task into two functions we can neatly register all of our builtins with some environment."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'void lenv_add_builtin(lenv* e, char* name, lbuiltin func) {\n    lval* k = lval_sym(name);\n    lval* v = lval_fun(func);\n    lenv_put(e, k, v);\n    lval_del(k); lval_del(v);\n}\n\nvodi lenv_add_builtins(lenv* e) {\n    /* List Functions */\n    lenv_add_builtin(e, "list", builtin_list);\n    lenv_add_builtin(e, "head", builtin_head);\n    lenv_add_builtin(e, "tail", builtin_tail);\n    lenv_add_builtin(e, "eval", builtin_eval);\n    lenv_add_builtin(e, "join", builtin_join);\n\n    /* Mathematical Functions */\n    lenv_add_builtin(e, "+", builtin_add);\n    lenv_add_builtin(e, "-", builtin_sub);\n    lenv_add_builtin(e, "*", builtin_mul);\n    lenv_add_builtin(e, "/", builtin_div);\n}\n')),(0,i.kt)("p",null,"The final step is to call this function before we create the interactive prompt. We also need to remember to delete the environment once we are finished."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'lenv* e = lenv_new();\nlenv_add_builtins(e);\n\nwhile(1) {\n    char* input = readline("lispy> ");\n    add_history(input);\n\n    mpc_result_t r;\n\n    if (mpc_parse("<stdin>", input, Lispy, &r)) {\n        lval* x = lval_eval(e, lval_read(r.output));\n        lval_println(x);\n        lval_del(x);\n\n        mpc_ast_delete(r.output);\n    } else {\n        mpc_err_print(r.error);\n        mpc_err_delete(r.error);\n    }\n\n    free(input);\n}\n\nlenv_del(e);\n')),(0,i.kt)("h2",{id:"define-function"},"Define Function"),(0,i.kt)("p",null,"We've managed to register our builtins as variables but we still don't have a way for users to define their own variables."),(0,i.kt)("p",null,"This is actually a bit awkward. We need to get the user to pass in a symbol to name, as well as the value to assign to it. But symbols can't appear on their own. Otherwise the evaluation function will attempt to retrieve a value for them from the environment."),(0,i.kt)("p",null,"The only way we can pass around symbols without them being evaluated is to put them between ",(0,i.kt)("inlineCode",{parentName:"p"},"{}")," in a quoted expression. So we're going to use this technique for our define function. It will take as input a list of symbols, and a number of other values. It will then assign each of the values to each of the symbols."),(0,i.kt)("p",null,"This function should act like any other builtin. It first checks for error conditions and then performs some command and returns a value. In this case first checks that the input arguments are the correct types. It then iterates over each symbol and value and puts them into the environment. If there is an error we can return it, but on success we will return the empty expression ",(0,i.kt)("inlineCode",{parentName:"p"},"()"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"lval* builtin_def(lenv* e, lval* a) {\n    LASSERT(a, a->cell[0]->type == LVAL_QEXPR, \"Function 'def' passed incorrect type!\");\n\n    lval* syms = a->cell[0];\n\n    for (int i = 0; i < syms->count; i++) {\n        LASSERT(a, syms->cell[i]->type == LVAL_SYM, \"Function 'def' cannot define non-symbols\");\n    }\n\n    LASSERT(a, syms->count == a->count -1, \"Function 'def' cannot define incorrect number of values of symbols\");\n\n    for (int i= 0; i < syms->count; i++) {\n        lenv_put(e, syms->cell[i], a->cell[i+1]);\n    }\n\n    lval_del(a);\n\n    return lval_sexpr();\n}\n")),(0,i.kt)("p",null,"We need to register this new builtin using our builtin function ",(0,i.kt)("inlineCode",{parentName:"p"},"lenv_add_builtins"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'lenv_add_builtin(e, "def", builtin_def);\n')),(0,i.kt)("p",null,"Now we should be able to support user defined variables. Because our ",(0,i.kt)("inlineCode",{parentName:"p"},"def")," function takes in a list of symbols we can do some cool things storing and manipulating symbols in lists before passing them to be defined. Have a play around in the prompt and ensure everything is working correctly."),(0,i.kt)("h2",{id:"error-reporting"},"Error Reporting"),(0,i.kt)("p",null,"So far the error reporting doesn't work so well. We can report when an error occurs, and give a vague notion of what the problem was, but we don't give the user much information about what exactly has gone wrong. For example if there is an unbound symbol we should be able to report exactly which symbol was unbound. This can help the user track down errors, typos, and other trivial problems."),(0,i.kt)("p",null,"Wouldn't it be great if we could write a function that can report errors in a similar way to how ",(0,i.kt)("inlineCode",{parentName:"p"},"printf")," works. It would be ideal if we could pass in strings, integers, and other data to make our error messages richer."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"printf")," function is a special function in C because it takes a variable number of arguments. We can create our own ",(0,i.kt)("strong",{parentName:"p"},"variable arguments")," functions, which is what we're going to da to make our error reporting better."),(0,i.kt)("p",null,"We'll modify ",(0,i.kt)("inlineCode",{parentName:"p"},"lval_err")," to act in the same way as ",(0,i.kt)("inlineCode",{parentName:"p"},"printf"),", taking in a format string, and after that a variable number of arguments to match into this string."),(0,i.kt)("p",null,"To declare that a function takes variables arguments in the type signature you use the special syntax of ellipsis ",(0,i.kt)("inlineCode",{parentName:"p"},"..."),", which represent the rest of the arguments."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"lval* lavl_err(char* fmt, ...);\n")),(0,i.kt)("p",null,"Then, inside the function there are standard library functions we can use to examine what the caller has passed in."),(0,i.kt)("p",null,"The first step is to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"va_list")," struct and initialise it with ",(0,i.kt)("inlineCode",{parentName:"p"},"va_start"),", passing in the last named argument. For other purposes it is possible to examine each argument passed in using ",(0,i.kt)("inlineCode",{parentName:"p"},"va_arg"),", but we are going to pass our whole variable argument list directly to the ",(0,i.kt)("inlineCode",{parentName:"p"},"vsnprintf")," function. This function acts like ",(0,i.kt)("inlineCode",{parentName:"p"},"printf")," but instead writes to a string and takes in a ",(0,i.kt)("inlineCode",{parentName:"p"},"va_list"),". Once we are done with our variable arguments, we should call ",(0,i.kt)("inlineCode",{parentName:"p"},"va_end")," to cleanup any resources used."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"vsnprintf")," function outputs to a string, which we need to allocate some first. Because we don't know the size of this string until we've run the function we first allocate a buffer ",(0,i.kt)("inlineCode",{parentName:"p"},"512")," characters big and then reallocate to a smaller buffer once we've output to it. If an error message is going to be longer than 512 characters it will just get cut off, but hopefully this won't happen."),(0,i.kt)("p",null,"Putting it all together the new error function looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"lval* lval_err(char* fmt, ...) {\n    lval* v = malloc(sizeof(lval));\n    v->type =LVAL_ERR;\n\n    va_list va;\n    va_start(va, fmt);\n\n    v->err = malloc(512);\n\n    vsnprintf(v->err, 511, fmt, va);\n\n    v->err = realloc(v->err, strlen(v->err) + 1);\n\n    va_end(va);\n\n    return v;\n}\n")),(0,i.kt)("p",null,"Using this we can then start adding in some better error messages to our functions. As an example we can look at ",(0,i.kt)("inlineCode",{parentName:"p"},"lenv_get"),". When a symbol can't be found, rather than reporting a generic error, we can actually report the name that was not found."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"return lval_err(\"Unbound Symbol '%s'\", k->sym);\n")),(0,i.kt)("p",null,"We can also adapter the ",(0,i.kt)("inlineCode",{parentName:"p"},"LASSERT")," macro such that it can take variable arguments too. Because this is a macro and not a standard function the syntax is slightly different. On the left-hand side of the definition we use the ellipses notation again, but on the right-hand side we use a special variable ",(0,i.kt)("inlineCode",{parentName:"p"},"__VA_ARGS__")," to paste in the contents of all the other arguments."),(0,i.kt)("p",null,"We need to prefix this special variable with two hash signs ",(0,i.kt)("inlineCode",{parentName:"p"},"##"),". This ensures that it is pasted correctly when the marco is passed no extra arguments. In essence what this does is make sure to remove the leading comma ",(0,i.kt)("inlineCode",{parentName:"p"},",")," to appear as if no extra arguments were passed in."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"#define LASSERT(args, cond, fmt, ...) \\\n    if (!(cond)) { \\\n        lval* err = lval_err(fmt, ##__VA_ARGS__); \\\n        lval_del(args);\\\n        return err;\\\n    }\n")),(0,i.kt)("p",null,"Now we can update some of our error messages to make them more informative. For example if the incorrect number of arguments were passed we can specify how many were required and how many were given."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"LASSERT(a, a->count == 1, \"Function 'head' passed too many arguments. Expected %i, got %i\", 1, a->count);\n")),(0,i.kt)("p",null,"We can also improve the error reporting for type errors. We should attempt to report what type was expected by a function and what type it actually got. Before we can do this it would be useful to have function that took as input some type enumeration and returned a string representation of that type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'char* ltype_name(int t) {\n    switch(t) {\n        case LVAL_FUN: return "Function";\n        case LVAL_NUM: return "Number";\n        case LVAL_ERR: return "Error";\n        case LVAL_SYM: return "Symbol";\n        case LVAL_SEXPR: return "S-Expression";\n        case LVAL_QEXPR: return "Q-Expression";\n        default: return "Unknown";\n    }\n}\n\nLASSERT(a, a->cell[0]->type == LVAL_QEXPR, "Function \'head\' passed incorrect type for argument 0. Expected %s, got %s", ltype_name(a->cell[0]->type), ltype_name(LVAL_QEXPR));\n')))}c.isMDXComponent=!0},58349:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/files/variables-e42356b5bacbb5d1ed485e33f3c18001.c"}}]);