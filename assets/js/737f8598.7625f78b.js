"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9517],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),c=p(n),f=a,h=c["".concat(l,".").concat(f)]||c[f]||u[f]||o;return n?r.createElement(h,s(s({ref:t},m),{},{components:n})):r.createElement(h,s({ref:t},m))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=f;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[c]="string"==typeof e?e:a,s[1]=i;for(var p=2;p<o;p++)s[p]=n[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},34650:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var r=n(87462),a=(n(67294),n(3905));const o={title:"04",tags:["lisp","interpreter"]},s=void 0,i={unversionedId:"lisp-interpreter-in-py/chapter-04",id:"lisp-interpreter-in-py/chapter-04",title:"04",description:"In the previous article you have learned how to parse (recognize) and interpret arithmetic expressions with any number of plus or minus oprators in them. You also learned about syntax diagrams and how they can be used to specify the syntax of a programming language.",source:"@site/docs/lisp-interpreter-in-py/chapter-04.md",sourceDirName:"lisp-interpreter-in-py",slug:"/lisp-interpreter-in-py/chapter-04",permalink:"/docs/lisp-interpreter-in-py/chapter-04",draft:!1,tags:[{label:"lisp",permalink:"/docs/tags/lisp"},{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",frontMatter:{title:"04",tags:["lisp","interpreter"]},sidebar:"tutorialSidebar",previous:{title:"03",permalink:"/docs/lisp-interpreter-in-py/chapter-03"},next:{title:"05",permalink:"/docs/lisp-interpreter-in-py/chapter-05"}},l={},p=[],m={toc:p};function c(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"In the previous article you have learned how to parse (recognize) and interpret arithmetic expressions with any number of plus or minus oprators in them. You also learned about syntax diagrams and how they can be used to specify the syntax of a programming language."),(0,a.kt)("p",null,"Today you're going to learn how to parse and interpret arithmetic expressions with any number of multiplication and division operators in them, for example ",(0,a.kt)("em",{parentName:"p"},"7 ")," 4 / 2 ",(0,a.kt)("em",{parentName:"p"}," 3"),". The division in this article will be an integer division, so if the expression is ",(0,a.kt)("em",{parentName:"p"},"9 / 4"),", then the answer will be an integer: 2."),(0,a.kt)("p",null,"We will also learn quite a bit today about another widely used notation for specifying the syntax of a programming language. It's called ",(0,a.kt)("em",{parentName:"p"},"context-free grammars")," (grammars, for short) or ",(0,a.kt)("em",{parentName:"p"},"BNF (Backus-Naur Form)"),". For the purpose of this article I will not use pure BNF notation but more like a modified EBNF notation."),(0,a.kt)("p",null,"Here are a couple of reasons to use grammars:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"A grammar specifies the syntax of a programming language in a concise manner. Unlike syntax diagrams, grammars are very compact. You will see me using grammars more and more in future articles."),(0,a.kt)("li",{parentName:"ol"},"A grammar can serve as great documentation."),(0,a.kt)("li",{parentName:"ol"},"A grammar is a good starting point even if you manually write your parser from scratch. Quite often you can just convert the grammar to code by following a set of simple rules."),(0,a.kt)("li",{parentName:"ol"},"There is a set of tools, called ",(0,a.kt)("em",{parentName:"li"},"parser generators"),", which accept a grammar as an input and automatically generate a parser for you based on that grammar. I will talk about those tools later on in the series.")),(0,a.kt)("p",null,"Here is a grammar that describes arithmetic expressions like ",(0,a.kt)("em",{parentName:"p"},"7 ")," 4 / 2 ",(0,a.kt)("em",{parentName:"p"}," 3")," (it's just one of the many expressions that can be generated by the grammar):"),(0,a.kt)("img",{src:"./imgs/lsbasi_part4_bnf1.png",alt:""}),(0,a.kt)("p",null,"A grammer consists fo a sequence of ",(0,a.kt)("em",{parentName:"p"},"rules"),", also known as ",(0,a.kt)("em",{parentName:"p"},"productions"),", There are two rules in our grammar:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part4_bnf2.png",alt:""}),(0,a.kt)("p",null,"A rule consists fo a ",(0,a.kt)("em",{parentName:"p"},"non-terminal"),", called the ",(0,a.kt)("em",{parentName:"p"},"head")," or ",(0,a.kt)("em",{parentName:"p"},"left-hand side")," of the production, a colon, and a sequence of terminals and/or non-terminars, called the ",(0,a.kt)("em",{parentName:"p"},"body")," or ",(0,a.kt)("em",{parentName:"p"},"right-hand side")," of the productions:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part4_bnf3.png",alt:""}),(0,a.kt)("p",null,"In the grammar I showed above, tokens like ",(0,a.kt)("strong",{parentName:"p"},"MUL, DIV, and INTEGER")," are called ",(0,a.kt)("em",{parentName:"p"},"terminals")," and variables like ",(0,a.kt)("em",{parentName:"p"},"expr")," and ",(0,a.kt)("em",{parentName:"p"},"factor")," are called ",(0,a.kt)("em",{parentName:"p"},"non-terminals"),". Non-terminals usually consist of a sequence of terminals and/or non-terminals:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part4_bnf4.png",alt:""}),(0,a.kt)("p",null,"The non-terminal symbol on the left side of the first rule is called the ",(0,a.kt)("em",{parentName:"p"},"start symbol"),". In the case of our grammar, the start symbol is ",(0,a.kt)("em",{parentName:"p"},"expr"),":"),(0,a.kt)("img",{src:"./imgs/lsbasi_part4_bnf5.png",alt:""}),(0,a.kt)("p",null,"What is a ",(0,a.kt)("em",{parentName:"p"},"factor"),"? For the purpose of this article a ",(0,a.kt)("em",{parentName:"p"},"factor")," is just an integer."),(0,a.kt)("p",null,"Let's quickly go over the symbols used in the grammar and their meaning."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"| - Alternatives. A bar means \u201cor\u201d. So (MUL | DIV) means either MUL or DIV."),(0,a.kt)("li",{parentName:"ul"},"( \u2026 ) - An open and closing parentheses mean grouping of terminals and/or non-terminals as in (MUL | DIV)."),(0,a.kt)("li",{parentName:"ul"},"( \u2026 )","*"," - Match contents within the group zero or more times.")),(0,a.kt)("p",null,"A grammar defines a language by explaining what sentences it can form. This is how you can ",(0,a.kt)("em",{parentName:"p"},"derive")," an arithmetic expression using the grammar: first you begin with the start symbol ",(0,a.kt)("em",{parentName:"p"},"expr")," and then repeatedly replace a non-terminal by the body of a rule for that non-terminal until you have generated a sentence consisting solely of terminals. Those sentences form a language defined by the grammar."),(0,a.kt)("p",null,"If the grammar cannot derive a certain arithmetic expression, then it doesn't support that expression and the parser will generate a syntax error when it tries to recognize the expression."),(0,a.kt)("p",null,"Now, let's map the above grammar to code, okay?"),(0,a.kt)("p",null,"Here are the guidelines that we will use to convert the grammar to source code. By following them, you can literally translate the grammar to a working parser:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Each rule, R, defined in the grammar, becomes a method with the same name, and references to that rule become a method call: R(). The body of the method follows the flow of the body of the rule using the very same guidelines."),(0,a.kt)("li",{parentName:"ol"},"Alternatives (a1 | a2 | aN) become an if-elif-else statement"),(0,a.kt)("li",{parentName:"ol"},"An optional grouping (\u2026)","*"," becomes a while statement that can loop over zero or more times"),(0,a.kt)("li",{parentName:"ol"},"Each token reference T becomes a call to the method eat: eat(T). The way the eat method works is that it consumes the token T if it matches the current lookahead token, then it gets a new token from the lexer and assigns that token to the current_token internal variable.")),(0,a.kt)("p",null,"Visually the guidelines look like this:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part4_rules.png",alt:""}),(0,a.kt)("p",null,"Let's get moving and convert our grammar to code following the above guidelines."),(0,a.kt)("p",null,"There are two rules in our grammar: one ",(0,a.kt)("em",{parentName:"p"},"expr")," rule and one ",(0,a.kt)("em",{parentName:"p"},"factor")," rule. Let's start with the ",(0,a.kt)("em",{parentName:"p"},"factor")," rule (production). According to the guidelines, you need to create a method called ",(0,a.kt)("em",{parentName:"p"},"factor")," that has a single call to the ",(0,a.kt)("em",{parentName:"p"},"eat")," method to consume the INTEGER token (guideline 4):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def factor(self):\n    self.eat(INTEGER)\n")),(0,a.kt)("p",null,"The rule ",(0,a.kt)("em",{parentName:"p"},"expr")," becomes the ",(0,a.kt)("em",{parentName:"p"},"expr")," method. The body of the rule starts with a reference to ",(0,a.kt)("em",{parentName:"p"},"factor")," that becomes a ",(0,a.kt)("em",{parentName:"p"},"factor()")," method call. The optional grouping ","*","(...)","*",(0,a.kt)("em",{parentName:"p"}," becomes a "),"while loop",(0,a.kt)("em",{parentName:"p"}," and "),"(MUL|DIV)",(0,a.kt)("em",{parentName:"p"}," alternatives become an "),"if-elif-else",(0,a.kt)("em",{parentName:"p"}," statement. By combing those pieces together we get the following "),"expr","*"," method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def expr(self):\n    self.factor()\n\n    while self.current_token.type in (MUL, DIV):\n        token = self.current_token\n        if token.type == MUL:\n            self.eat(MUL)\n            self.factor()\n        elif token.type == DIV:\n            self.eat(DIV)\n            self.factor()\n")),(0,a.kt)("p",null,"This is how a syntax diagram for the same ",(0,a.kt)("em",{parentName:"p"},"expr")," rule look like:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part4_sd.png",alt:""}),(0,a.kt)("p",null,"It's about time to dig into the source code of the new arithmetic expression interpreter. Below is the code of a calculator that can handle valid arithmetic expressions containing integers and any number of multiplication and division (integer division) operators."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'# Token types\n#\n# EOF (end-of-file) token is used to indicate that\n# there is no more input left for lexical analysis\nINTEGER, MUL, DIV, EOF = \'INTEGER\', \'MUL\', \'DIV\', \'EOF\'\n\n\nclass Token(object):\n    def __init__(self, type, value):\n        # token type: INTEGER, MUL, DIV, or EOF\n        self.type = type\n        # token value: non-negative integer value, \'*\', \'/\', or None\n        self.value = value\n\n    def __str__(self):\n        """String representation of the class instance.\n        Examples:\n            Token(INTEGER, 3)\n            Token(MUL, \'*\')\n        """\n        return \'Token({type}, {value})\'.format(\n            type=self.type,\n            value=repr(self.value)\n        )\n\n    def __repr__(self):\n        return self.__str__()\n\n\nclass Lexer(object):\n    def __init__(self, text):\n        # client string input, e.g. "3 * 5", "12 / 3 * 4", etc\n        self.text = text\n        # self.pos is an index into self.text\n        self.pos = 0\n        self.current_char = self.text[self.pos]\n\n    def error(self):\n        raise Exception(\'Invalid character\')\n\n    def advance(self):\n        """Advance the `pos` pointer and set the `current_char` variable."""\n        self.pos += 1\n        if self.pos > len(self.text) - 1:\n            self.current_char = None  # Indicates end of input\n        else:\n            self.current_char = self.text[self.pos]\n\n    def skip_whitespace(self):\n        while self.current_char is not None and self.current_char.isspace():\n            self.advance()\n\n    def integer(self):\n        """Return a (multidigit) integer consumed from the input."""\n        result = \'\'\n        while self.current_char is not None and self.current_char.isdigit():\n            result += self.current_char\n            self.advance()\n        return int(result)\n\n    def get_next_token(self):\n        """Lexical analyzer (also known as scanner or tokenizer)\n        This method is responsible for breaking a sentence\n        apart into tokens. One token at a time.\n        """\n        while self.current_char is not None:\n\n            if self.current_char.isspace():\n                self.skip_whitespace()\n                continue\n\n            if self.current_char.isdigit():\n                return Token(INTEGER, self.integer())\n\n            if self.current_char == \'*\':\n                self.advance()\n                return Token(MUL, \'*\')\n\n            if self.current_char == \'/\':\n                self.advance()\n                return Token(DIV, \'/\')\n\n            self.error()\n\n        return Token(EOF, None)\n\n\nclass Parser(object):\n    def __init__(self, lexer):\n        self.lexer = lexer\n        # set current token to the first token taken from the input\n        self.current_token = self.lexer.get_next_token()\n\n    def error(self):\n        raise Exception(\'Invalid syntax\')\n\n    def eat(self, token_type):\n        # compare the current token type with the passed token\n        # type and if they match then "eat" the current token\n        # and assign the next token to the self.current_token,\n        # otherwise raise an exception.\n        if self.current_token.type == token_type:\n            self.current_token = self.lexer.get_next_token()\n        else:\n            self.error()\n\n    def factor(self):\n        """Parse integer.\n        factor : INTEGER\n        """\n        token = self.current_token\n        self.eat(INTEGER)\n        return token.value\n\n    def parse(self):\n        """Arithmetic expression parser.\n        Grammar:\n        expr   : factor ((MUL | DIV) factor)*\n        factor : INTEGER\n        """\n        result = self.factor()\n\n        while self.current_token.type in (MUL, DIV):\n            token = self.current_token\n            if token.type == MUL:\n                self.eat(MUL)\n                result = result * self.factor()\n            elif token.type == DIV:\n                self.eat(DIV)\n                result = result / self.factor()\n\n        return result\n\n\ndef main():\n    while True:\n        try:\n            text = input(\'calc>\')\n        except EOFError:\n            break\n        if not text:\n            continue\n\n        lexer = Lexer(text)\n        parser = Parser(lexer)\n        result = parser.parse()\n        print(result)\n\n\nif __name__ == \'__main__\':\n    main()\n')))}c.isMDXComponent=!0}}]);