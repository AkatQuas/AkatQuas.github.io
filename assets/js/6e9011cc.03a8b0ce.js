"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6783],{3905:(e,r,t)=>{t.d(r,{Zo:()=>u,kt:()=>d});var a=t(67294);function n(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function i(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);r&&(a=a.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?i(Object(t),!0).forEach((function(r){n(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function s(e,r){if(null==e)return{};var t,a,n=function(e,r){if(null==e)return{};var t,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],r.indexOf(t)>=0||(n[t]=e[t]);return n}(e,r);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var l=a.createContext({}),p=function(e){var r=a.useContext(l),t=r;return e&&(t="function"==typeof e?e(r):o(o({},r),e)),t},u=function(e){var r=p(e.components);return a.createElement(l.Provider,{value:r},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var r=e.children;return a.createElement(a.Fragment,{},r)}},g=a.forwardRef((function(e,r){var t=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(t),g=n,d=c["".concat(l,".").concat(g)]||c[g]||m[g]||i;return t?a.createElement(d,o(o({ref:r},u),{},{components:t})):a.createElement(d,o({ref:r},u))}));function d(e,r){var t=arguments,n=r&&r.mdxType;if("string"==typeof e||n){var i=t.length,o=new Array(i);o[0]=g;var s={};for(var l in r)hasOwnProperty.call(r,l)&&(s[l]=r[l]);s.originalType=e,s[c]="string"==typeof e?e:n,o[1]=s;for(var p=2;p<i;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},90715:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=t(87462),n=(t(67294),t(3905));const i={title:"03 Language Grammar",tags:["lisp","interpreter"]},o=void 0,s={unversionedId:"lisp-interpreter-in-c/language-grammar",id:"lisp-interpreter-in-c/language-grammar",title:"03 Language Grammar",description:"document",source:"@site/docs/lisp-interpreter-in-c/03-language-grammar.md",sourceDirName:"lisp-interpreter-in-c",slug:"/lisp-interpreter-in-c/language-grammar",permalink:"/docs/lisp-interpreter-in-c/language-grammar",draft:!1,tags:[{label:"lisp",permalink:"/docs/tags/lisp"},{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",sidebarPosition:3,frontMatter:{title:"03 Language Grammar",tags:["lisp","interpreter"]},sidebar:"tutorialSidebar",previous:{title:"02 An Interactive Prompt",permalink:"/docs/lisp-interpreter-in-c/interactive-prompt"},next:{title:"04 Parsing",permalink:"/docs/lisp-interpreter-in-c/parsing"}},l={},p=[{value:"What is a Programming language?",id:"what-is-a-programming-language",level:2},{value:"Parser Combinator",id:"parser-combinator",level:2}],u={toc:p};function c(e){let{components:r,...t}=e;return(0,n.kt)("wrapper",(0,a.Z)({},u,t,{components:r,mdxType:"MDXLayout"}),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"http://www.buildyourownlisp.com/chapter5_languages"},"document")),(0,n.kt)("h2",{id:"what-is-a-programming-language"},"What is a Programming language?"),(0,n.kt)("p",null,"A programming language is very similar to a real language. There is a structure behind it, and some rules which dictate what is, and isn't, a valid thing to say."),(0,n.kt)("p",null,"It's an obvious observation that natural languages are built up of recursive and repeated substructures."),(0,n.kt)("p",null,"The consequence of this observation by Chomsky is important. It means that although there are an infinite number of different things that can be said, or written down in a particular language, it is still possible to process and understand all of them with a finite number of re-write rules. The name given to a set of re-write rules is a ",(0,n.kt)("strong",{parentName:"p"},"grammar"),"."),(0,n.kt)("p",null,"To write a programming language such as our Lisp we are going to need to understand grammars. For reading in the user input we need to write a ",(0,n.kt)("strong",{parentName:"p"},"grammar")," which describes it. Then we can use it along with our user input, to decide if the input is valid. We can also use it to build a structured internal representation, which will make the job of understanding it, and then evaluating it, performing the computations encoded within, much easier."),(0,n.kt)("p",null,"This is where a library called ",(0,n.kt)("inlineCode",{parentName:"p"},"mpc")," comes in."),(0,n.kt)("h2",{id:"parser-combinator"},"Parser Combinator"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"mpc")," is a ",(0,n.kt)("strong",{parentName:"p"},"Parser Combinator")," library that allows you to build programmes that understand and process particular languages. These are known as ",(0,n.kt)("strong",{parentName:"p"},"parsers"),". There are many different ways of building parsers, but the cool thing about using a ",(0,n.kt)("strong",{parentName:"p"},"Parser Combinator")," library is that it lets you build ",(0,n.kt)("strong",{parentName:"p"},"parsers")," easily, just by specifying the ",(0,n.kt)("strong",{parentName:"p"},"grammar")," ... sort of."),(0,n.kt)("p",null,"Many Parser Combinator libraries actually work by letting you write normal code that looks a bit like a grammar, not by actually specifying a grammar directly. In many situations this is fine, but sometimes it can get clunky and complicated."))}c.isMDXComponent=!0}}]);