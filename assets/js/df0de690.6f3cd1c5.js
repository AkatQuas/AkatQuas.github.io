"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6563],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=p(a),u=i,m=h["".concat(l,".").concat(u)]||h[u]||d[u]||o;return a?n.createElement(m,r(r({ref:t},c),{},{components:a})):n.createElement(m,r({ref:t},c))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=a[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},82537:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=a(87462),i=(a(67294),a(3905));const o={title:"Building Abstractions with Data",tags:["sicp"]},r=void 0,s={unversionedId:"sicp/building-abstractions-with-data",id:"sicp/building-abstractions-with-data",title:"Building Abstractions with Data",description:"Programs are typically designed to model complex phenomena, and more often than not one must construct computational objects that have several parts in order to model real-world phenomena that have several aspects. Any programming language would provide the means for building abstractions by combining data objects to form compound data.",source:"@site/docs/sicp/02-building-abstractions-with-data.md",sourceDirName:"sicp",slug:"/sicp/building-abstractions-with-data",permalink:"/docs/sicp/building-abstractions-with-data",draft:!1,tags:[{label:"sicp",permalink:"/docs/tags/sicp"}],version:"current",sidebarPosition:2,frontMatter:{title:"Building Abstractions with Data",tags:["sicp"]},sidebar:"tutorialSidebar",previous:{title:"Building Abstractions with Procedures",permalink:"/docs/sicp/building-abstractions-with-procedures"},next:{title:"Modularity, Objects, and State",permalink:"/docs/sicp/modularity-objects-state"}},l={},p=[{value:"Introduction to Data Abstraction",id:"introduction-to-data-abstraction",level:2},{value:"Pairs",id:"pairs",level:4},{value:"Abstraction Barriers",id:"abstraction-barriers",level:3},{value:"What Is Meant by Data?",id:"what-is-meant-by-data",level:3},{value:"Hierarchical Data and the Closure Property",id:"hierarchical-data-and-the-closure-property",level:2},{value:"Representing Sequences",id:"representing-sequences",level:3},{value:"List operation",id:"list-operation",level:4},{value:"Mapping over lists",id:"mapping-over-lists",level:4},{value:"Hierarchical Structures",id:"hierarchical-structures",level:3},{value:"Mapping over trees",id:"mapping-over-trees",level:4},{value:"Sequences as Conventional Interfaces",id:"sequences-as-conventional-interfaces",level:3},{value:"Sequence Operations",id:"sequence-operations",level:4},{value:"Nested Mappings",id:"nested-mappings",level:4},{value:"Symbolic Data",id:"symbolic-data",level:2},{value:"Quotation",id:"quotation",level:3},{value:"Representing Sets",id:"representing-sets",level:3},{value:"Example: Huffman Encoding Trees",id:"example-huffman-encoding-trees",level:3},{value:"Multiple Representations for Abstract Data",id:"multiple-representations-for-abstract-data",level:2},{value:"Tagged data",id:"tagged-data",level:3},{value:"Data-Directed Programming and Additivity",id:"data-directed-programming-and-additivity",level:3},{value:"Message passing",id:"message-passing",level:4},{value:"Systems with Generic Operations",id:"systems-with-generic-operations",level:2},{value:"Generic Arithmetic Operations",id:"generic-arithmetic-operations",level:3},{value:"Combining Data of Different Types",id:"combining-data-of-different-types",level:3},{value:"Coercion",id:"coercion",level:4},{value:"Hierarchies of types",id:"hierarchies-of-types",level:4},{value:"Inadequacies of hierarchies",id:"inadequacies-of-hierarchies",level:4}],c={toc:p};function h(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Programs are typically designed to model complex phenomena, and more often than not one must construct computational objects that have several parts in order to model real-world phenomena that have several aspects. Any programming language would provide the means for building abstractions by combining data objects to form compound data."),(0,i.kt)("p",null,"We need compound data in programming languages for:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"to elevate the conceptual level at which we can design our programs,")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"to increase the modularity of our designs,")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"to enhance the expressive power of our language."))),(0,i.kt)("p",null,"Just as the ability to define procedures enables us to deal with processes at a higher conceptual level than that of the primitive operations of the language, the ability to construct compound data objects enables us to deal with data at a higher conceptual level than that of the primitive data objects of the language."),(0,i.kt)("p",null,"The use of compound data also enables us to increase the modularity of our programs. The general technique of isolating the parts of a program that deal with how data objects are represented from the parts of a program that deal with how data objects are used is a powerful design methodology called ",(0,i.kt)("em",{parentName:"p"},"data abstraction"),"."),(0,i.kt)("p",null,"As with compound procedures, the main issue to be addressed is that of abstraction as a technique for coping with complexity, and we will see how data abstraction enables us to erect suitable abstraction barriers between different parts of a program."),(0,i.kt)("p",null,"The key to forming compound data is that a programming language should provide some kind of \u201cglue\u201d so that data objects can be combined to form more complex data objects."),(0,i.kt)("p",null,"One key idea in dealing with compound data is the notion of ",(0,i.kt)("em",{parentName:"p"},"closure")," \u2014that the glue we use for combining data objects should allow us to combine not only primitive data objects, but compound data objects as well. Another key idea is that compound data objects can serve as ",(0,i.kt)("em",{parentName:"p"},"conventional interfaces")," for combining program modules in mix-and-match ways."),(0,i.kt)("p",null,"Using ",(0,i.kt)("em",{parentName:"p"},"symbolic expressions")," and various alternatives for representing sets of objects. There are many ways in which a given data structure can be represented in terms of simpler objects, and the choice of representation can have significant impact on the time and space requirements of processes that manipulate the data."),(0,i.kt)("p",null,"Maintaining modularity in the presence of ",(0,i.kt)("em",{parentName:"p"},"generic operations"),", which helps to handle different types of data, requires more powerful abstraction barriers than can be erected with simple data abstraction alone."),(0,i.kt)("p",null,"In particular, we introduce data-directed programming as a technique that allows individual data representations to be designed in isolation and then combined additively."),(0,i.kt)("h2",{id:"introduction-to-data-abstraction"},"Introduction to Data Abstraction"),(0,i.kt)("p",null,"Data abstraction is a methodology that enables us to isolate how a compound data object is used from the details of how it is constructed from more primitive data objects."),(0,i.kt)("p",null,"The basic idea of data abstraction is that the programs should use data in such a way as to make no assumptions about the data that are not strictly necessary for performing the task at hand. At the same time, a ",(0,i.kt)("em",{parentName:"p"},"concrete")," data representation is defined independent of the programs that use the data."),(0,i.kt)("p",null,"The interface between these two parts of our system will be a set of procedures, called ",(0,i.kt)("em",{parentName:"p"},"selectors")," and ",(0,i.kt)("em",{parentName:"p"},"constructors"),", that implement the abstract data in terms of the concrete representation."),(0,i.kt)("h4",{id:"pairs"},"Pairs"),(0,i.kt)("p",null,"To enable the program to implement the concrete level of the data abstraction, the language provides a compound structure called a ",(0,i.kt)("em",{parentName:"p"},"pair"),"."),(0,i.kt)("p",null,"A pair is a data object that can be given a name and manipulated, just like a primitive data object."),(0,i.kt)("p",null,"The ability to combine pairs means that pairs can be used as general-purpose building blocks to create all sorts of complex data structures. Data objects constructed from pairs are called ",(0,i.kt)("em",{parentName:"p"},"list-structured")," data."),(0,i.kt)("h3",{id:"abstraction-barriers"},"Abstraction Barriers"),(0,i.kt)("p",null,"In general, the underlying idea of data abstraction is to identify for each type of data objects of that type will be expressed, and then to use only those operations in manipulating the data."),(0,i.kt)("p",null,"The details of how one level is implemented are irrelevant to the rest levels. In effect, procedures at each level are the interfaces that define the abstraction barriers and connect the different levels."),(0,i.kt)("p",null,"Using abstraction barriers makes programs much easier to maintain and to modify. Any complex data structure can be represented in a variety of ways with the primitive data structures provided by a programming language. Of course, the choice of representation influences the programs that operate on it; thus, if the representation were to be changed at some later time, all such programs might have to be modified accordingly."),(0,i.kt)("p",null,"Constraining the dependence on the representation to a few interface procedures helps us design programs as well as modify them, because it allows us to maintain the flexibility to consider alternate implementations."),(0,i.kt)("h3",{id:"what-is-meant-by-data"},"What Is Meant by Data?"),(0,i.kt)("p",null,"What exactly is meant by data? It is not enough to say ",(0,i.kt)("em",{parentName:"p"},"whatever is implemented by the given selectors and constructors"),". In general, we can think of data as defined by some collection of selectors and constructors, together with specified conditions that these procedures must fulfill in order to be a valid representation."),(0,i.kt)("h2",{id:"hierarchical-data-and-the-closure-property"},"Hierarchical Data and the Closure Property"),(0,i.kt)("p",null,"Pairs provide a primitive ",(0,i.kt)("em",{parentName:"p"},"glue")," to construct compound data objects."),(0,i.kt)("p",null,"The ability to create pairs whose elements could be pairs is the essence of list structure's importance as a representational tool. In general, an operation for combining data objects satisfies the closure property if the results of combining things with that operation can themselves be combined using the same operation. Closure is the key to power in any means of combination because it permits programmers to create ",(0,i.kt)("em",{parentName:"p"},"hierarchical")," structures-structures made up of parts, which themselves are made up of parts, and so on."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Throughout the book, the meaning of ",(0,i.kt)("em",{parentName:"p"},"closure")," is from abstract algebra, and its meaning is where a set of elements is said to be closed under an operation if applying the operation to elements in the set produces an element that is again an element of that set. ",(0,i.kt)("em",{parentName:"p"},"\u4ee3\u6570\u95ed\u5305\uff08\u57df\uff09")," or ",(0,i.kt)("em",{parentName:"p"},"algebraic closure"),".")),(0,i.kt)("h3",{id:"representing-sequences"},"Representing Sequences"),(0,i.kt)("p",null,"One of the useful structures we can build with pairs is a sequence\u2014an ordered collection of data objects."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"List, Array")),(0,i.kt)("h4",{id:"list-operation"},"List operation"),(0,i.kt)("p",null,"It is customary to number the elements of the list beginning with index 0."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"length")," procedure implements a simple recursive plan. The reduction step is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"length")," of an empty list is ",(0,i.kt)("inlineCode",{parentName:"li"},"0"),","),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"length")," of any list is ",(0,i.kt)("inlineCode",{parentName:"li"},"1")," plus the ",(0,i.kt)("inlineCode",{parentName:"li"},"length")," of the after list.")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"append")," takes two lists as arguments and combines their elements to make a new list, using a recursive plan:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If ",(0,i.kt)("inlineCode",{parentName:"li"},"list1")," is the empty list, then the result is just ",(0,i.kt)("inlineCode",{parentName:"li"},"list2"),"."),(0,i.kt)("li",{parentName:"ul"},"Otherwise, append the first element of ",(0,i.kt)("inlineCode",{parentName:"li"},"list1")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"list2"),", and add the rest ",(0,i.kt)("inlineCode",{parentName:"li"},"list1")," onto the result")),(0,i.kt)("h4",{id:"mapping-over-lists"},"Mapping over lists"),(0,i.kt)("p",null,"One extremely useful operation is to apply some transformation to each element in a list and generate the list of results. We can abstract this general idea and capture it as a common pa\ue03cern expressed as a higher-order procedure."),(0,i.kt)("p",null,"The higher-order procedure here is called ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," takes as arguments a procedure of one argument and a list, and returns a list of the results produced by applying the procedure to each element in the list."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"map")," is an important construct, not only because it captures a common pattern, but because it establishes a higher level of abstraction barrier that isolates the implementation of procedures that transform lists from the details of how the elements of the list are extracted and combined. This abstraction gives us the flexibility to change the low-level details of how sequences are implemented, while preserving the conceptual framework of operations that transform sequences to sequences."),(0,i.kt)("h3",{id:"hierarchical-structures"},"Hierarchical Structures"),(0,i.kt)("p",null,"Another way to think of sequences whose elements are sequences is as ",(0,i.kt)("em",{parentName:"p"},"trees"),". The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees."),(0,i.kt)("p",null,"Recursion is a natural tool for dealing with tree structures, since we can often reduce operations on trees to operations on their branches, which reduce in turn to operations on the branches of the branches, and so on, until we reach the leaves of the tree."),(0,i.kt)("h4",{id:"mapping-over-trees"},"Mapping over trees"),(0,i.kt)("p",null,"Just as ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," is a powerful abstraction for dealing with sequences, ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," together with recursion is a powerful abstraction for dealing with trees."),(0,i.kt)("h3",{id:"sequences-as-conventional-interfaces"},"Sequences as Conventional Interfaces"),(0,i.kt)("p",null,"If we could organize our programs to make the signal-flow structure manifest in the procedures we write, this would increase the conceptual clarity of the resulting code."),(0,i.kt)("h4",{id:"sequence-operations"},"Sequence Operations"),(0,i.kt)("p",null,"The key to organizing programs so as to more clearly reflect the signal-flow structure is to concentrate on the ",(0,i.kt)("em",{parentName:"p"},"signals")," that flow from one stage in the process to the next. If we represent these signals as lists, then we can use list operations to implement the processing at each of the stages."),(0,i.kt)("p",null,"The value of expressing programs as sequence operations is that this helps us make program designs that are modular, that is, designs that are constructed by combining relatively independent pieces. We can encourage modular design by providing a library of standard components together with a conventional interface for connecting the components in flexible ways."),(0,i.kt)("p",null,"Sequences, implemented here as lists, serve as a conventional interface that permits us to combine processing modules. Additionally, when we uniformly represent structures as sequences, we have localized the data-structure dependencies in our programs to some sequence operations. By changing these, we can experiment with alternative representations of sequences, while leaving the overall design of our programs intact."),(0,i.kt)("h4",{id:"nested-mappings"},"Nested Mappings"),(0,i.kt)("p",null,"We can extend the sequence paradigm to include many computations that are commonly expressed using nested loops."),(0,i.kt)("h2",{id:"symbolic-data"},"Symbolic Data"),(0,i.kt)("p",null,"We extend the representational capability of our language by introducing the ability to work with arbitrary symbols as data."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"MatLab has the ability to do symbolic mathematical work.")),(0,i.kt)("h3",{id:"quotation"},"Quotation"),(0,i.kt)("p",null,"In order to manipulate symbols we need a new element in the language: the ability to ",(0,i.kt)("em",{parentName:"p"},"quote")," a data object."),(0,i.kt)("p",null,"The expression ",(0,i.kt)("inlineCode",{parentName:"p"},"(list a b)")," constructs a list of the values of a and b rather than the symbols themselves. This issue is well-known in the context of natural languages, where words and sentences may be regarded either as semantic entities or as character strings (syntactic entities)."),(0,i.kt)("p",null,"Using quotation, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"(list 'a 'b)")," allows us to type in compound objects, using the conventional printed representation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(define a 1)\n(define b 2)\n(list a b)\n// output is (1 2)\n(list 'a 'b)\n// output is (a b)\n(list 'a b)\n// output is (a 2)\n")),(0,i.kt)("h3",{id:"representing-sets"},"Representing Sets"),(0,i.kt)("p",null,"There are a number of possible representation for sets. Informally, a set is simply a collection of distinct objects."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Sets as unordered lists"),(0,i.kt)("p",{parentName:"li"},"One way to represent a set is as a list of its elements in which no element appears more than once. The empty set is represented by the empty list.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Sets as ordered lists"),(0,i.kt)("p",{parentName:"li"},"One way to speed up our set operations is to change the representation so that the set elements are listed in increasing order. To do this, we need some way to compare two objects so that we can say which is bigger.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Sets as binary trees"),(0,i.kt)("p",{parentName:"li"},"To do better than the ordered-list representation, we arrange the set elements in the form of a tree. Each node of the tree holds one element of the set, called the ",(0,i.kt)("em",{parentName:"p"},"entry")," at that node, and a link to each of two other (possibly empty) nodes. The ",(0,i.kt)("em",{parentName:"p"},"left")," link points to elements smaller than the one at the node, and the ",(0,i.kt)("em",{parentName:"p"},"right")," link to elements greater than the one at the node."),(0,i.kt)("p",{parentName:"li"},"One way to solve this unbalanced tree problem is to define an operation that transforms an arbitrary tree into a balanced tree with the same elements. Then we can perform this transformation after every few ",(0,i.kt)("em",{parentName:"p"},"adjoin-set")," operations to keep our set in balance. There are other ways to solve this problem, most of which involve designing new data structures for which searching and insertion both can be done in ",(0,i.kt)("inlineCode",{parentName:"p"},"\u0398(logn)")," steps."))),(0,i.kt)("h3",{id:"example-huffman-encoding-trees"},"Example: Huffman Encoding Trees"),(0,i.kt)("p",null,"In general, we can attain significant savings if we use variable-length prefix codes that take advantage of the relative frequencies of the symbols in the messages to be encoded."),(0,i.kt)("p",null,"A Huffman code can be represented as a binary tree whose leaves are the symbols that are encoded. At each non-leaf node of the tree there is a set containing all the symbols in the leaves that lie below the node. In addition, each symbol at a leaf is assigned a weight (which is its relative frequency), and each non-leaf node contains a weight that is the sum of all the weights of the leaves lying below it. The weights are not used in the encoding or the decoding process."),(0,i.kt)("h2",{id:"multiple-representations-for-abstract-data"},"Multiple Representations for Abstract Data"),(0,i.kt)("p",null,"In addition to the data-abstraction barriers that isolate different design choices from each other and permit different choices to coexist in a single program."),(0,i.kt)("p",null,"Data may be represented in different ways by different parts of a program. This requires constructing ",(0,i.kt)("em",{parentName:"p"},"generic procedures")," - procedures that can operate on data that may be represented in more than one way. Our main technique for building generic procedures will be to work in terms of data objects that have ",(0,i.kt)("em",{parentName:"p"},"type tags"),", that is, data objects that include explicit ",(0,i.kt)("em",{parentName:"p"},"information about how they are to be processed"),"."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Data-directed")," programming is a powerful and convenient implementation strategy for additively assembling systems with generic operations."),(0,i.kt)("p",null,"The discipline of data abstraction ensures that the different implementation of same selectors will work with different constructor representations."),(0,i.kt)("h3",{id:"tagged-data"},"Tagged data"),(0,i.kt)("p",null,"One way to view data abstraction is as an application of the ",(0,i.kt)("em",{parentName:"p"},"principle of least commitment"),"."),(0,i.kt)("p",null,"The abstraction barrier formed by the selectors and constructors permits programmers to defer to the last possible moment the choice of a concrete representation for the data objects and thus retain maximum flexibility in the system design."),(0,i.kt)("p",null,"A straightforward way to accomplish this distinction between different constructor is to include a ",(0,i.kt)("em",{parentName:"p"},"type tag"),". Then we can use the tag to decide which selector to apply."),(0,i.kt)("p",null,"Each generic selector is implemented as a procedure that checks the tag of its argument and calls the appropriate procedure for handling data of that type."),(0,i.kt)("p",null,"Since each data object is tagged with its type, the selectors operate on the data in a generic manner. That is, each selector is defined to have a behavior that depends upon the particular type of data it is applied to."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Factory Pattern")),(0,i.kt)("h3",{id:"data-directed-programming-and-additivity"},"Data-Directed Programming and Additivity"),(0,i.kt)("p",null,"The general strategy of checking the type of a datum and calling an appropriate procedure is called ",(0,i.kt)("em",{parentName:"p"},"dispatching on type"),"."),(0,i.kt)("p",null,"This is a powerful strategy for obtaining modularity in system design. On the other hand, implementing the dispatch has two significant weaknesses:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"the generic interface procedures must know about all the different representations."),(0,i.kt)("li",{parentName:"ol"},"no two procedures in the entire system have the same name even though the individual representations can be designed separately.")),(0,i.kt)("p",null,"To understand how data-directed programming works, begin with the observation that whenever we deal with a set of generic operations that are common to a set of different types, we are, in effect, dealing with a two-dimensional table that contains the possible operations on one axis and the possible types on the other axis. The entries in the table are the procedures that implement each operation for each type of argument presented."),(0,i.kt)("h4",{id:"message-passing"},"Message passing"),(0,i.kt)("p",null,"The key idea of data-directed programming is to handle generic operations in programs by dealing explicitly with operation-and-type tables."),(0,i.kt)("p",null,"The style of programming organizes the required dispatching on type by having each operation take care of its own dispatching. In effect, this decomposes the operation-and-type table into rows, with each generic operation procedure representing a row of the table."),(0,i.kt)("p",null,"An alternative implementation strategy is to decompose the table into columns and, instead of using ",(0,i.kt)("em",{parentName:"p"},"intelligent operations")," that dispatch on data types, to work with ",(0,i.kt)("em",{parentName:"p"},"intelligent data objects")," that dispatch on operation names. We can do this by arranging things so that a data object is represented as a procedure that takes as input the required operation name and performs the operation indicated."),(0,i.kt)("p",null,"This style of programming is called ",(0,i.kt)("em",{parentName:"p"},"message passing"),". The name comes from the image that a data object is an entity that receives the requested operation name as a ",(0,i.kt)("em",{parentName:"p"},"message"),". Message passing is not a mathematical trick but a useful technique for organizing systems with generic operations."),(0,i.kt)("h2",{id:"systems-with-generic-operations"},"Systems with Generic Operations"),(0,i.kt)("p",null,"Generic interface procedures helps programmers to link the code that specifies the data operations to the several representations. The same idea is not only suitable to define operations that are generic over different representations but also to define operations that are generic over different kinds of arguments."),(0,i.kt)("h3",{id:"generic-arithmetic-operations"},"Generic Arithmetic Operations"),(0,i.kt)("p",null,"Creating a table to store types and operations."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Operator overloading")),(0,i.kt)("h3",{id:"combining-data-of-different-types"},"Combining Data of Different Types"),(0,i.kt)("p",null,"We have gone to great pains to introduce barriers between parts of our programs so that they can be developed and understood separately. We would like to introduce the cross-type operations in some carefully controlled way, so that we can support them without seriously violating our module boundaries."),(0,i.kt)("p",null,"One way to handle cross-type operations is to design a different procedure for each possible combination of types for which the operation is valid."),(0,i.kt)("p",null,"This technique works, but it is cumbersome. With such a system, the cost of introducing a new type is not just the construction of the package of procedures for that type but also the construction and installation of the procedures that implement the cross-type operations."),(0,i.kt)("h4",{id:"coercion"},"Coercion"),(0,i.kt)("p",null,"In the general situation of completely unrelated operations acting on completely unrelated types, implementing explicit cross-type operations, cumbersome though it may be, is the best that one can hope for."),(0,i.kt)("p",null,"Often the different data types are not completely independent, and there may be ways by which objects of one type may be viewed as being of another type. This process is called ",(0,i.kt)("em",{parentName:"p"},"coercion"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"type casting")),(0,i.kt)("p",null,"In general, we can implement this idea by designing coercion procedures that transform an object of one type into an equivalent object of another type."),(0,i.kt)("p",null,"Although we still need to write coercion procedures to relate the types (possibly n",(0,i.kt)("sup",null,"2")," procedures for a system with ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," types), we need to write only one procedure for each pair of types rather than a different procedure for each collection of types and each generic operation. What we are counting on here is the fact that the appropriate transformation between types depends only on the types themselves, not on the operation to be applied."),(0,i.kt)("p",null,"On the other hand, there may be applications for which our coercion scheme is not general enough. Even when neither of the objects to be combined can be converted to the type of the other it may still be possible to perform the operation by converting both objects to a third type."),(0,i.kt)("h4",{id:"hierarchies-of-types"},"Hierarchies of types"),(0,i.kt)("p",null,"Often there is more ",(0,i.kt)("em",{parentName:"p"},"global")," structure in how the different types relate to each other, this is a so-called ",(0,i.kt)("em",{parentName:"p"},"hierarchy of types"),"."),(0,i.kt)("h4",{id:"inadequacies-of-hierarchies"},"Inadequacies of hierarchies"),(0,i.kt)("p",null,"In general, a type may have more than one subtype, or more than one supertype."),(0,i.kt)("p",null,"This multiple-supertypes issue is particularly thorny, since it means that there is no unique way to ",(0,i.kt)("em",{parentName:"p"},"raise")," a type in the hierarchy. Finding the ",(0,i.kt)("em",{parentName:"p"},"correct")," supertype in which to apply an operation to an object may involve considerable searching through the entire type network on the part of a procedure such as ",(0,i.kt)("em",{parentName:"p"},"apply-generic"),". Since there generally are multiple subtypes for a type, there is a similar problem in coercing a value ",(0,i.kt)("em",{parentName:"p"},"down")," the type hierarchy."))}h.isMDXComponent=!0}}]);