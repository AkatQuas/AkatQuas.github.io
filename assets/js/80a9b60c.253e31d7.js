"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5009],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>f});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),s=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=s(e.components);return r.createElement(l.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),u=s(t),h=a,f=u["".concat(l,".").concat(h)]||u[h]||d[h]||i;return t?r.createElement(f,o(o({ref:n},c),{},{components:t})):r.createElement(f,o({ref:n},c))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=h;var p={};for(var l in n)hasOwnProperty.call(n,l)&&(p[l]=n[l]);p.originalType=e,p[u]="string"==typeof e?e:a,o[1]=p;for(var s=2;s<i;s++)o[s]=t[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},41430:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>p,toc:()=>s});var r=t(87462),a=(t(67294),t(3905));const i={title:"The token input stream",sidebar_position:3,tags:["interpreter"]},o=void 0,p={unversionedId:"interpreter-in-js/token-input-stream",id:"interpreter-in-js/token-input-stream",title:"The token input stream",description:"The tokenizer (also called \u201clexer\u201d) operates on a character input stream and returns a stream object with the same interface, but the values returned by peek() / next() will be tokens. A token is an object with two properties",source:"@site/docs/interpreter-in-js/token-input-stream.md",sourceDirName:"interpreter-in-js",slug:"/interpreter-in-js/token-input-stream",permalink:"/docs/interpreter-in-js/token-input-stream",draft:!1,tags:[{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",sidebarPosition:3,frontMatter:{title:"The token input stream",sidebar_position:3,tags:["interpreter"]},sidebar:"tutorialSidebar",previous:{title:"The character input stream",permalink:"/docs/interpreter-in-js/character-input-stream"},next:{title:"The AST",permalink:"/docs/interpreter-in-js/parser"}},l={},s=[],c={toc:s};function u(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The tokenizer (also called \u201clexer\u201d) operates on a ",(0,a.kt)("inlineCode",{parentName:"p"},"character input stream")," and returns a stream object with the same interface, but the values returned by ",(0,a.kt)("inlineCode",{parentName:"p"},"peek() / next()")," will be tokens. A token is an object with two properties: type and value. Here are some examples with supported tokens:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'{ type: "punc", value: "(" }           // punctuation: parens, comma, semicolon etc.\n{ type: "num", value: 5 }              // numbers\n{ type: "str", value: "Hello World!" } // strings\n{ type: "kw", value: "lambda" }        // keywords\n{ type: "var", value: "a" }            // identifiers\n{ type: "op", value: "!=" }            // operators\n')),(0,a.kt)("p",null,"Whitespaces and comments are skipped over, no tokens are returned."),(0,a.kt)("p",null,"In order to write the tokenizer we need to look more closely into the syntax of our language. The idea is to notice that depending on the current character (as returned by ",(0,a.kt)("inlineCode",{parentName:"p"},"input.peek()"),") we can decide what kind of token to read:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"First off, skip over whitespace."),(0,a.kt)("li",{parentName:"ul"},"If ",(0,a.kt)("inlineCode",{parentName:"li"},"input.eof()")," then return ",(0,a.kt)("inlineCode",{parentName:"li"},"null"),"."),(0,a.kt)("li",{parentName:"ul"},"If it's a sharp sign ",(0,a.kt)("inlineCode",{parentName:"li"},"#"),", skip comment (retry after the end of line)."),(0,a.kt)("li",{parentName:"ul"},"If it's a quote then read a string."),(0,a.kt)("li",{parentName:"ul"},"If it's a digit, then we proceed to read a number."),(0,a.kt)("li",{parentName:"ul"},'If it\'s a "letter", then read an identifier or a keyword token.'),(0,a.kt)("li",{parentName:"ul"},"If it's one of the punctuation characters, return a punctuation token."),(0,a.kt)("li",{parentName:"ul"},"If it's one of the operator characters, return an operator token."),(0,a.kt)("li",{parentName:"ul"},"If none of the above, error out with ",(0,a.kt)("inlineCode",{parentName:"li"},"input.croak()"),".")),(0,a.kt)("p",null,"So here's the \u201cread_next\u201d function \u2014 the \u201ccore\u201d of the tokenizer \u2014 which implements the above:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"function read_next() {\n  read_while(is_whitespace);\n  if (input.eof()) return null;\n  var ch = input.peek();\n  if (ch == '#') {\n    skip_comment();\n    return read_next();\n  }\n  if (ch == '\"') return read_string();\n  if (is_digit(ch)) return read_number();\n  if (is_id_start(ch)) return read_ident();\n  if (is_punc(ch))\n    return {\n      type: 'punc',\n      value: input.next(),\n    };\n  if (is_op_char(ch))\n    return {\n      type: 'op',\n      value: read_while(is_op_char),\n    };\n  input.croak('Can not handle character: ' + ch);\n}\n")),(0,a.kt)("p",null,'This is a "dispatcher" function and it\'s what ',(0,a.kt)("inlineCode",{parentName:"p"},"next()")," will call in order to fetch the next token. Note it uses many utilities that are focused on particular token types, like ",(0,a.kt)("inlineCode",{parentName:"p"},"read_string()"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"read_number()")," etc. There's no point to complicate the dispatcher with code from those functions, even if we never call them elsewhere."),(0,a.kt)("p",null,"Another thing to notice is that we don't consume all the input stream in one step. Each time the parser will call for next token, we read one token. In case of a parse error we don't even reach the end of the stream."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"read_ident()")," will read characters as long as they are allowed as part of an identifier(",(0,a.kt)("inlineCode",{parentName:"p"},"is_id"),"). Identifiers must start with a letter, or ",(0,a.kt)("inlineCode",{parentName:"p"},"\u03bb")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"_"),", and can contain further such characters, or digits, or one of the following: ",(0,a.kt)("inlineCode",{parentName:"p"},"? ! - < > ="),". Therefore, ",(0,a.kt)("inlineCode",{parentName:"p"},"foo-bar")," will not be read as three tokens but as a single identifier (a ",(0,a.kt)("inlineCode",{parentName:"p"},'"var"')," token)."),(0,a.kt)("p",null,"Also, the ",(0,a.kt)("inlineCode",{parentName:"p"},"read_ident()")," function will check the identifier against the list of known keywords, and if it's there it will return a ",(0,a.kt)("inlineCode",{parentName:"p"},'"kw"')," token rather than a ",(0,a.kt)("inlineCode",{parentName:"p"},'"var"')," one."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"function TokenStream(input) {\n  var current = null;\n  var keywords = ' if then else lambda \u03bb true false ';\n  function is_keyword(x) {\n    return keywords.indexOf(' ' + x + ' ') >= 0;\n  }\n  function is_digit(ch) {\n    return /[0-9]/i.test(ch);\n  }\n  function is_id_start(ch) {\n    return /[a-z\u03bb_]/i.test(ch);\n  }\n  function is_id(ch) {\n    return is_id_start(ch) || '?!-<>=0123456789'.indexOf(ch) >= 0;\n  }\n  function is_op_char(ch) {\n    return '+-*/%=&|<>!'.indexOf(ch) >= 0;\n  }\n  function is_punc(ch) {\n    return ',;(){}[]'.indexOf(ch) >= 0;\n  }\n  function is_whitespace(ch) {\n    return ' \\t\\n'.indexOf(ch) >= 0;\n  }\n  function read_while(predicate) {\n    var str = '';\n    while (!input.eof() && predicate(input.peek())) {\n      str += input.next();\n    }\n    return str;\n  }\n  function read_number() {\n    var has_dot = false;\n    var number = read_while(function (ch) {\n      if (ch == '.') {\n        if (has_dot) return false;\n        has_dot = true;\n        return true;\n      }\n      return is_digit(ch);\n    });\n    return { type: 'num', value: parseFloat(number) };\n  }\n  function read_ident() {\n    var id = read_while(is_id);\n    return {\n      type: is_keyword(id) ? 'kw' : 'var',\n      value: id,\n    };\n  }\n  function read_escaped(end) {\n    var escaped = false,\n      str = '';\n    input.next();\n    while (!input.eof()) {\n      var ch = input.next();\n      if (escaped) {\n        str += ch;\n        escaped = false;\n      } else if (ch == '\\\\') {\n        escaped = true;\n      } else if (ch == end) {\n        break;\n      } else {\n        str += ch;\n      }\n    }\n    return str;\n  }\n  function read_string() {\n    return { type: 'str', value: read_escaped('\"') };\n  }\n  function skip_comment() {\n    read_while(function (ch) {\n      return ch != '\\n';\n    });\n    input.next();\n  }\n  function read_next() {\n    read_while(is_whitespace);\n    if (input.eof()) return null;\n    var ch = input.peek();\n    if (ch == '#') {\n      skip_comment();\n      return read_next();\n    }\n    if (ch == '\"') return read_string();\n    if (is_digit(ch)) return read_number();\n    if (is_id_start(ch)) return read_ident();\n    if (is_punc(ch))\n      return {\n        type: 'punc',\n        value: input.next(),\n      };\n    if (is_op_char(ch))\n      return {\n        type: 'op',\n        value: read_while(is_op_char),\n      };\n    input.croak('Can not handle character: ' + ch);\n  }\n  function peek() {\n    return current || (current = read_next());\n  }\n  function next() {\n    var tok = current;\n    current = null;\n    return tok || read_next();\n  }\n  function eof() {\n    return peek() == null;\n  }\n  return {\n    next: next,\n    peek: peek,\n    eof: eof,\n    croak: input.croak,\n  };\n}\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The ",(0,a.kt)("inlineCode",{parentName:"p"},"next()")," function doesn't always call ",(0,a.kt)("inlineCode",{parentName:"p"},"read_next()"),", because it might have been peeked before (in which case ",(0,a.kt)("inlineCode",{parentName:"p"},"read_next()")," was already called and the stream advanced). Therefore, we need a ",(0,a.kt)("inlineCode",{parentName:"p"},"current")," variable which keeps track of the current token.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"We only support decimal numbers with the usual notation (no ",(0,a.kt)("inlineCode",{parentName:"p"},"1E5")," stuff, no hex, no octal). But, if we ever need more, the changes go only in ",(0,a.kt)("inlineCode",{parentName:"p"},"read_number()")," and are pretty easy to do.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Unlike JavaScript, the only characters that cannot appear unquoted in a string are the quote character itself and the backslash. You need to backslash them. Otherwise, string can contain hard newlines, tabs, and whatnot. We don't interpret the usual escapes like ",(0,a.kt)("inlineCode",{parentName:"p"},"\\n"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"\\t")," etc. though again, the changes would be pretty trivial (in ",(0,a.kt)("inlineCode",{parentName:"p"},"read_string()"),")."))),(0,a.kt)("p",null,"Next, we will move on to the parser."))}u.isMDXComponent=!0}}]);