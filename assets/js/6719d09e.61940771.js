"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4433],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=c(n),d=o,m=h["".concat(l,".").concat(d)]||h[d]||u[d]||i;return n?a.createElement(m,r(r({ref:t},p),{},{components:n})):a.createElement(m,r({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},42943:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(87462),o=(n(67294),n(3905));const i={title:"Learn some Golang",categories:["programming language","golang"],tags:["golang"]},r=void 0,s={permalink:"/blog/2020/09/24/golang",source:"@site/blog/2020-09-24-golang.md",title:"Learn some Golang",description:"I start from this online tutorial, which is a good and comprehensive tutorial.",date:"2020-09-24T00:00:00.000Z",formattedDate:"September 24, 2020",tags:[{label:"golang",permalink:"/blog/tags/golang"}],readingTime:21.865,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Learn some Golang",categories:["programming language","golang"],tags:["golang"]},prevItem:{title:"Wander in webpack",permalink:"/blog/2020/12/06/wander-in-webpack"},nextItem:{title:"Fullstack Starter Project Boilerplate",permalink:"/blog/2020/04/01/fullstack-starter"}},l={authorsImageUrls:[]},c=[{value:"some example files",id:"some-example-files",level:3},{value:"Basic Syntax and Grammar in GO",id:"basic-syntax-and-grammar-in-go",level:2},{value:"Reflection",id:"reflection",level:2},{value:"Go Concurrency",id:"go-concurrency",level:2},{value:"scheduler in go",id:"scheduler-in-go",level:3},{value:"select",id:"select",level:3},{value:"buffered channels",id:"buffered-channels",level:2},{value:"nil channel",id:"nil-channel",level:2},{value:"Shared Memory and Shared Variables",id:"shared-memory-and-shared-variables",level:2},{value:"Sharing memory using goroutines",id:"sharing-memory-using-goroutines",level:2},{value:"Catching race conditions",id:"catching-race-conditions",level:2},{value:"The context package",id:"the-context-package",level:2},{value:"Worker pool",id:"worker-pool",level:2},{value:"Code Testing, Optimization, Profiling",id:"code-testing-optimization-profiling",level:2},{value:"Network Programming",id:"network-programming",level:2},{value:"TCP client",id:"tcp-client",level:3},{value:"UDP client",id:"udp-client",level:3},{value:"Remote Procedure Call (RPC)",id:"remote-procedure-call-rpc",level:3},{value:"Examples for Closures and Anonymous Goroutines",id:"examples-for-closures-and-anonymous-goroutines",level:2}],p={toc:c};function h(e){let{components:t,...i}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"I start from ",(0,o.kt)("a",{parentName:"p",href:"https://www.digitalocean.com/community/tutorial_series/how-to-code-in-go"},"this online tutorial"),", which is a good and comprehensive tutorial."),(0,o.kt)("p",null,"Most content is excerpt from ",(0,o.kt)("a",{parentName:"p",href:"https://www.packtpub.com/product/mastering-go-second-edition/9781838559335"},"Mastering Go"),". You'd better buy one if you like the book."),(0,o.kt)("p",null,"You'd really check it out, ",(0,o.kt)("a",{parentName:"p",href:"/docs/concurrency-in-go/index"},"Concurrency In Depth"),"."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/AkatQuas/kiddo-plays/tree/master/golanger"},"Project on GitHub"),"."),(0,o.kt)("h1",{id:"useful-tips"},"Useful tips"),(0,o.kt)("p",null,"go version go1.14.4 darwin/amd64"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"go doc --help\n\n# go doc fmt\n\n# go doc fmt.Printf\n\ngo tool compile <source.go>\n\ngo tool compile -pack <source.go>\n\n# allow to detect race conditions, concurrency\ngo tool compile -race <source.go>\n\n# go tool compile hello.go\n\n# go tool compile -pack hello.go\n\n# go tool compile -race hello.go\n\n# The -W parameter tells the go tool compile command to\n# print the `debug parse tree` after the type checking\ngo tool compile -W <source.go>\n")),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"some-example-files"},"some example files"),(0,o.kt)("p",null,"Detailed on Garbage Collector in GO : ",(0,o.kt)("a",{target:"_blank",href:n(34151).Z},"garbageCollector.go"),"."),(0,o.kt)("p",null,"Glance at the package ",(0,o.kt)("inlineCode",{parentName:"p"},"unsafe"),": ",(0,o.kt)("a",{target:"_blank",href:n(80422).Z},"unsafe.go"),"."),(0,o.kt)("p",null,"Glance at the keyword ",(0,o.kt)("inlineCode",{parentName:"p"},"defer"),": ",(0,o.kt)("a",{target:"_blank",href:n(58971).Z},"simple-defer.go"),", ",(0,o.kt)("a",{target:"_blank",href:n(49104).Z},"flow-control"),"."),(0,o.kt)("p",null,"Glance at the built-in functions ",(0,o.kt)("inlineCode",{parentName:"p"},"panic")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"recover"),": ",(0,o.kt)("a",{target:"_blank",href:n(55913).Z},"panicRecover"),", ",(0,o.kt)("a",{target:"_blank",href:n(49104).Z},"flow-control"),", ",(0,o.kt)("a",{target:"_blank",href:n(24273).Z},"error-handling"),"."),(0,o.kt)("p",null,"Glance at the package ",(0,o.kt)("inlineCode",{parentName:"p"},"time"),": ",(0,o.kt)("a",{target:"_blank",href:n(25682).Z},"dateAndTime.go"),"."),(0,o.kt)("p",null,"Glance at the package ",(0,o.kt)("inlineCode",{parentName:"p"},"strings"),": ",(0,o.kt)("a",{target:"_blank",href:n(76908).Z},"useStrings.go"),"."),(0,o.kt)("p",null,"Find out more information about the functions of the ",(0,o.kt)("inlineCode",{parentName:"p"},"runtime")," package by visiting ",(0,o.kt)("a",{parentName:"p",href:"https://golang.org/pkg/runtime/"},"https://golang.org/pkg/runtime/"),"."),(0,o.kt)("h2",{id:"basic-syntax-and-grammar-in-go"},"Basic Syntax and Grammar in GO"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'// using for loop to simulate while lopp\nfor {\n  if (condition) {\n    break\n  }\n}\n\n// using for loop to simulate do...while loop\nfor ok := true; ok; ok = anExpression {\n\n}\n\nfunc differentS1AndS2() {\n  s1 := []int{1, 2}\n  s2 := s1[:]\n  s1[1] = 4\n  // at this time, s1 and s2 both point to the same internal array\n  fmt.Printf("%v %[1]T\\n", &s2)\n  fmt.Printf("%v\\n", &s1)\n  s1 = append(s1, 5, 7,9,10)\n  // at this time, s1 is different from s2\n  fmt.Printf("%v %[1]T\\n", &s2)\n  fmt.Printf("%v\\n", &s1)\n}\n')),(0,o.kt)("p",null,"Go has its own way of supporting ",(0,o.kt)("inlineCode",{parentName:"p"},"tuples"),", which mainly allows functions to return ",(0,o.kt)("em",{parentName:"p"},"multiple values")," without needing to ",(0,o.kt)("em",{parentName:"p"},"group")," them in structures as is the case in C."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"new")," returns the memory address of the allocated object. Put simply, ",(0,o.kt)("inlineCode",{parentName:"p"},"new")," returns a pointer!"),(0,o.kt)("p",null,"The main difference between ",(0,o.kt)("inlineCode",{parentName:"p"},"new")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"make")," is that variables created with ",(0,o.kt)("inlineCode",{parentName:"p"},"make")," are properly initialized without just zeroing the allocated memory space. Additionally, ",(0,o.kt)("inlineCode",{parentName:"p"},"make")," can only be applied to maps, channels, and slices, and it does not return a memory address, which means that ",(0,o.kt)("inlineCode",{parentName:"p"},"make")," does not return a ",(0,o.kt)("em",{parentName:"p"},"pointer"),"."),(0,o.kt)("p",null,"A Go ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," is a read-only ",(0,o.kt)("inlineCode",{parentName:"p"},"byte")," ",(0,o.kt)("inlineCode",{parentName:"p"},"slice")," that can hold any type of bytes, and it can have an arbitrary length."),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"rune")," is an ",(0,o.kt)("inlineCode",{parentName:"p"},"int32")," value, and therefore it is a Go type that is used for representing a Unicode code point. A Unicode code point or code position is a numerical value that is usually used for representing single Unicode characters; however, it can also have alternative meanings, such as providing formatting information."),(0,o.kt)("p",null,"A Go ",(0,o.kt)("em",{parentName:"p"},"package")," is a Go source file that begins with the ",(0,o.kt)("inlineCode",{parentName:"p"},"package")," keyword followed by the name of the package."),(0,o.kt)("p",null,"A Go ",(0,o.kt)("em",{parentName:"p"},"type method")," is a function with a special ",(0,o.kt)("em",{parentName:"p"},"receiver")," argument. We declare methods as ordinary functions with an additional parameter that appears in front of the function name. This particular parameter ",(0,o.kt)("strong",{parentName:"p"},"connects")," the function to the type of that extra parameter. As a result, that parameter is called the ",(0,o.kt)("em",{parentName:"p"},"receiver")," of the method."),(0,o.kt)("p",null,"A type assertion is the ",(0,o.kt)("inlineCode",{parentName:"p"},"x.(T)")," notation where ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," is of interface type and ",(0,o.kt)("inlineCode",{parentName:"p"},"T")," is a type. Additionally, the actual value stored in ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," is of type ",(0,o.kt)("inlineCode",{parentName:"p"},"T"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"T")," must satisfy the interface type of ",(0,o.kt)("inlineCode",{parentName:"p"},"x"),"!"),(0,o.kt)("p",null,"Type assertions help you do two things. The first thing is to check whether an interface value keeps a particular type. When used this way, a type assertion returns two values: the underlying value, and a bool value. Although the underlying value is what you might want to use, the Boolean value tells you whether the type assertion was successful or not! The second thing a type assertion does is to allow you to use the concrete value stored in an interface or assign it to a new variable. This means that if there is an int variable in an interface, you can get that value using type assertion."),(0,o.kt)("p",null,"Glance at the usage of ",(0,o.kt)("inlineCode",{parentName:"p"},"interfaces"),": ",(0,o.kt)("a",{target:"_blank",href:n(10846).Z},"interfacesAssertion.go"),"."),(0,o.kt)("h2",{id:"reflection"},"Reflection"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Reflection")," is an advanced Go feature that allows you to dynamically learn the type of an arbitrary object as well as information about its structure. Go offers the ",(0,o.kt)("inlineCode",{parentName:"p"},"reflect")," package for working with reflection."),(0,o.kt)("p",null,"Reflection is necessary for the implementation of packages such as ",(0,o.kt)("inlineCode",{parentName:"p"},"fmt"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"text/template"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"html/template"),". In the ",(0,o.kt)("inlineCode",{parentName:"p"},"fmt")," package, reflection saves you from having to deal explicitly with every data type that exists."),(0,o.kt)("p",null,"Consequently, you might need to use reflection when you want to be as ",(0,o.kt)("em",{parentName:"p"},"generic")," as possible, or when you want to make sure you will be able to deal with data types that do not exist at the time you are writing your code. Additionally, reflection is handy when working with values of types that do not implement a common interface."),(0,o.kt)("p",null,"The stars of the ",(0,o.kt)("inlineCode",{parentName:"p"},"reflect")," package are two types named reflect.Value and reflect.Type. The former type is used for storing values of any type, whereas the latter type is used for representing Go types."),(0,o.kt)("p",null,"Reflection should be used sparingly for three main reasons."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The first reason is that extensive use of reflection will make your programs hard to read and maintain. A potential solution to this problem is the good documentation; however, developers are famous for not having the time to write the required documentation."),(0,o.kt)("li",{parentName:"ol"},"The second reason is that the Go code which uses reflection will make your programs slower. Generally speaking, Go code that is made to work with a particular data type will always be faster than Go code that uses reflection to work dynamically with any Go data type. Additionally, such dynamic code will make it difficult for tools to refactor or analyze your code."),(0,o.kt)("li",{parentName:"ol"},"The last reason is that reflection errors cannot be caught at build time and are reported at runtime as a panic. This means that reflection errors can potentially crash your programs!")),(0,o.kt)("p",null,"Glance at the package ",(0,o.kt)("inlineCode",{parentName:"p"},"reflection"),": ",(0,o.kt)("a",{target:"_blank",href:n(33028).Z},"reflection.go"),"."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"go-concurrency"},"Go Concurrency"),(0,o.kt)("p",null,"Go offers its own unique and innovative way of achieving concurrency, which comes in the form of ",(0,o.kt)("strong",{parentName:"p"},"goroutines")," and ",(0,o.kt)("strong",{parentName:"p"},"channels"),"."),(0,o.kt)("p",null,"Goroutines are the smallest Go entities that can be executed on their own in a Go program, which implies that goroutines are not autonomous entities like Unix processes\u2014goroutines live in threads that live in Unix processes."),(0,o.kt)("p",null,"Whilst channels can get data from goroutines in a concurrent and efficient way and thus allow goroutines to have a point of reference and communicate with each other."),(0,o.kt)("p",null,"Everything in Go is executed using goroutines; this makes perfect sense since Go is a concurrent programming language by design. Therefore, when a Go program starts its execution, its single goroutine calls the ",(0,o.kt)("inlineCode",{parentName:"p"},"main()")," function, which starts the actual program execution."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"You should never make any assumptions about the order in which your goroutines will be executed.")),(0,o.kt)("p",null,"The Unix kernel scheduler is responsible for the execution of the threads of a program."),(0,o.kt)("p",null,"On the other hand, the Go runtime has its own scheduler, which is responsible for the execution of the goroutines using a technique known as ",(0,o.kt)("em",{parentName:"p"},"m:n scheduling"),", where ",(0,o.kt)("em",{parentName:"p"},"m")," goroutines are executed using ",(0,o.kt)("em",{parentName:"p"},"n")," operating system threads using multiplexing. The Go scheduler is the Go component responsible for ",(0,o.kt)("em",{parentName:"p"},"the way, and the order")," in which the goroutines of a Go program get executed. This makes the Go scheduler a really important part of the Go programming language, as everything in a Go program is executed as a goroutine."),(0,o.kt)("p",null,"It is a very common misconception that ",(0,o.kt)("em",{parentName:"p"},"concurrency")," is the same thing as ",(0,o.kt)("em",{parentName:"p"},"parallelism"),"\u2014this is just not true! ",(0,o.kt)("em",{parentName:"p"},"Parallelism")," is the ",(0,o.kt)("em",{parentName:"p"},"simultaneous execution of multiple entities of some kind"),", whereas ",(0,o.kt)("em",{parentName:"p"},"concurrency")," is a way of structuring your components so that they ",(0,o.kt)("em",{parentName:"p"},"can be executed independently when possible"),"."),(0,o.kt)("p",null,"It is only when you build software components concurrently that you can safely execute them in parallel, when and if your operating system, and your hardware permit it. In a valid concurrent design, adding concurrent entities makes the whole system run faster because more things can run in parallel. So, the desired parallelism comes from a better concurrent expression and implementation of the problem. So, the developer should not think about parallelism, but about breaking things into independent components that solve the initial problem when combined."),(0,o.kt)("p",null,"You can define a new goroutine using the ",(0,o.kt)("inlineCode",{parentName:"p"},"go")," keyword followed by ",(0,o.kt)("em",{parentName:"p"},"a function name")," or the full definition of ",(0,o.kt)("em",{parentName:"p"},"an anonymous function"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"go")," keyword ",(0,o.kt)("strong",{parentName:"p"},"makes the function call to return immediately, while the function starts running in the background as a goroutine, and the rest of the program continues its execution"),"."),(0,o.kt)("p",null,"However, you cannot control or make any assumptions about the order in which your goroutines are going to be executed because this depends on the ",(0,o.kt)("em",{parentName:"p"},"scheduler of the operating system"),", ",(0,o.kt)("em",{parentName:"p"},"the Go scheduler"),", and ",(0,o.kt)("em",{parentName:"p"},"the load of the operating system"),"."),(0,o.kt)("p",null,"Glance at the package ",(0,o.kt)("inlineCode",{parentName:"p"},"sync")," in goroutine: ",(0,o.kt)("a",{target:"_blank",href:n(18634).Z},"goroutinesSync.go"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// Although both functions implement the same functionality,\n// their definitions are slightly different.\n// The difference is created by the `<-` symbol found on\n// the right of the `chan` keyword in the definition of the `f2()` function.\n// This denotes that the `c` channel can be used for writing only.\nfunc f1(c chan int, x int) {\n  fmt.Println(x)\n  c <- x\n}\n// `c` is send-only\nfunc f2(c chan<- int, x int) {\n  fmt.Println(x)\n  c <- x\n}\n\n// `out` is send-only, `in` is receive-only\nfunc f1(out chan<- int64, in <-chan int64) {\n  fmt.Println(x)\n  fmt.Println(<-out) // invalid\n  out <- x\n  in <- x // invalid\n}\n// `out`, `in` are bidirectional\nfunc f2(out chan int64, in chan int64) {\n  fmt.Println(x)\n  c <- x\n}\n")),(0,o.kt)("h3",{id:"scheduler-in-go"},"scheduler in go"),(0,o.kt)("p",null,"Go works using the ",(0,o.kt)("em",{parentName:"p"},"m:n scheduler")," (or ",(0,o.kt)("em",{parentName:"p"},"M:N scheduler"),") that schedules goroutines using OS threads."),(0,o.kt)("p",null,"Go uses the ",(0,o.kt)("em",{parentName:"p"},"fork-join concurrency model"),". The fork part of the model states that a child branch can be created at any point of a program. Analogously, the join part of the Go concurrency model is where the child branch will end and join with its parent. Among other things, both ",(0,o.kt)("inlineCode",{parentName:"p"},"sync.Wait()")," statements and channels that collect the results of goroutines are join points, whereas any new goroutine creates a child branch."),(0,o.kt)("p",null,"The ",(0,o.kt)("em",{parentName:"p"},"fair scheduling strategy")," shares evenly all the load between the available processors."),(0,o.kt)("p",null,"A goroutine in Go is a ",(0,o.kt)("em",{parentName:"p"},"task"),", whereas everything after the calling statement of a goroutine is a ",(0,o.kt)("em",{parentName:"p"},"continuation"),". In the ",(0,o.kt)("em",{parentName:"p"},"work stealing strategy")," used by Go scheduler, a (logical) processor that is underutilized looks for additional work from other processors. When it finds such jobs, it steals them from the other processor(s), hence the name, ",(0,o.kt)("em",{parentName:"p"},"work stealing strategy"),". Additionally, the work-stealing algorithm of Go queues and steals continuations. A ",(0,o.kt)("em",{parentName:"p"},"stalling join")," is a point where a thread of execution stalls at a join and starts looking for other work to do. Although both task stealing and continuation stealing have stalling joins, continuations happen more often than tasks; therefore, the Go algorithm works with continuations rather than tasks."),(0,o.kt)("p",null,"The main disadvantage of continuation stealing is that it requires extra work from the compiler of the programming language. Fortunately, Go provides that extra help and therefore uses ",(0,o.kt)("em",{parentName:"p"},"continuation stealing")," in its work-stealing algorithm. One of the benefits of continuation stealing is that you get the same results when using just functions or a single thread with multiple goroutines. This makes perfect sense as only one thing is executed at any given time in both cases."),(0,o.kt)("p",null,"Now, let's return back to the ",(0,o.kt)("em",{parentName:"p"},"m:n scheduling algorithm")," used in Go."),(0,o.kt)("p",null,"The Go scheduler works using three main kinds of entities: OS threads (M) that are related to the operating system in use, goroutines (G), and logical processors (P). The number of processors that can be used by a Go program is specified by the ",(0,o.kt)("inlineCode",{parentName:"p"},"GOMAXPROCS")," environment variable\u2014at any given time there are most ",(0,o.kt)("inlineCode",{parentName:"p"},"GOMAXPROCS")," processors."),(0,o.kt)("p",null,"The following figure illustrates this point:"),(0,o.kt)("img",{src:"/images/golang/go-scheduler.png",alt:"go scheduler"}),(0,o.kt)("p",null,"There are two different kinds of queues: a global queue and a local queue attached to each logical processor."),(0,o.kt)("p",null,"Goroutines from the global queue are assigned to the queue of a logical processor in order to be executed. As a result, the Go scheduler needs to check the global queue in order to avoid executing goroutines that are only located at the local queue of each logical processor. However, the global queue is not checked all the time, which means that it does not have an advantage over the local queues."),(0,o.kt)("p",null,"Additionally, each logical processor can have multiple threads, and ",(0,o.kt)("em",{parentName:"p"},"the stealing occurs between the local queues of the available logical processors"),". Finally, keep in mind that the Go scheduler is allowed to create more OS threads when needed. OS threads are pretty expensive, however, which means that dealing with OS threads too much might slow down your Go applications."),(0,o.kt)("h3",{id:"select"},"select"),(0,o.kt)("p",null,"In practice, this means that ",(0,o.kt)("inlineCode",{parentName:"p"},"select")," allows a goroutine to ",(0,o.kt)("em",{parentName:"p"},"wait")," on multiple communications operations. Therefore, the main benefit is that ",(0,o.kt)("inlineCode",{parentName:"p"},"select")," gives you the power to work with multiple channels using a single ",(0,o.kt)("inlineCode",{parentName:"p"},"select")," block. As a consequence, you can have nonblocking operations on channels."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The biggest problem when using multiple channels and the ",(0,o.kt)("inlineCode",{parentName:"p"},"select")," keyword is ",(0,o.kt)("strong",{parentName:"p"},"deadlocks"),", which needs extra care during the design and the development process.")),(0,o.kt)("p",null,"You should checkout the file ",(0,o.kt)("a",{target:"_blank",href:n(26638).Z},"selectSimple.go"),"."),(0,o.kt)("p",null,"The biggest advantage of ",(0,o.kt)("inlineCode",{parentName:"p"},"select")," is that it can connect and manage multiple channels. As channels connect goroutines, ",(0,o.kt)("inlineCode",{parentName:"p"},"select")," connects channels that connect goroutines. Therefore, the ",(0,o.kt)("inlineCode",{parentName:"p"},"select")," statement is one of the most important part of the Go concurrency model."),(0,o.kt)("p",null,"You should checkout the file ",(0,o.kt)("a",{target:"_blank",href:n(68749).Z},"selectTimeout.go"),", which use ",(0,o.kt)("inlineCode",{parentName:"p"},"timeout")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"select")," to stop or return from goroutine earlier."),(0,o.kt)("p",null,"If you send a message to a closed channel, the program will ",(0,o.kt)("em",{parentName:"p"},"panic"),". However, if you try to read from a closed channel, you will get the ",(0,o.kt)("em",{parentName:"p"},"zero value")," of the ",(0,o.kt)("em",{parentName:"p"},"type")," of that channel. So, after closing a channel, you can no longer write to it, but you can still read from it. Finally, if you try to close a nil channel, your program will panic."),(0,o.kt)("p",null,"In order to be able to close a channel, the channel must not be receive-only. Additionally, a ",(0,o.kt)("inlineCode",{parentName:"p"},"nil")," channel always blocks, which means that trying to read or write from a ",(0,o.kt)("inlineCode",{parentName:"p"},"nil")," channel will block. This property of channels can be very useful when you want to disable a branch of a select statement by assigning the ",(0,o.kt)("inlineCode",{parentName:"p"},"nil")," value to a channel variable."),(0,o.kt)("h2",{id:"buffered-channels"},"buffered channels"),(0,o.kt)("p",null,"Buffered channels are channels that allow the Go scheduler to put jobs in the queue quickly in order to be able to deal with more requests."),(0,o.kt)("p",null,"The technique presented here works as follows: All incoming requests are forwarded to a channel, which processes them one by one. When the channel is done processing a request, it sends a message to the original caller saying that it is ready to process a new one. So, the capacity of the buffer of the channel restricts the number of simultaneous requests that it can keep."),(0,o.kt)("h2",{id:"nil-channel"},"nil channel"),(0,o.kt)("p",null,"The nil channels are a special kind of channel because they will always block."),(0,o.kt)("p",null,"You can read the usages of ",(0,o.kt)("em",{parentName:"p"},"buffered channels")," and ",(0,o.kt)("em",{parentName:"p"},"nil channel")," in this list ",(0,o.kt)("a",{target:"_blank",href:n(56886).Z},"channelUsages"),"."),(0,o.kt)("p",null,"An ",(0,o.kt)("a",{target:"_blank",href:n(40229).Z},"example")," to use channel to ordering some goroutine execution."),(0,o.kt)("h2",{id:"shared-memory-and-shared-variables"},"Shared Memory and Shared Variables"),(0,o.kt)("p",null,"Shared memory and shared variables are the most common ways for Unix threads to communicate with each other."),(0,o.kt)("p",null,"A ",(0,o.kt)("strong",{parentName:"p"},"Mutex")," variable, which is an abbreviation for ",(0,o.kt)("em",{parentName:"p"},"mutual exclusion")," variable, is mainly used for thread synchronization and for protecting shared data when multiple writes can occur at the same time. A mutex works like a buffered channel of capacity one, which allows at most one goroutine to access a shared variable at any given time. This means that there is no way for two or more goroutines to try to update that variable simultaneously."),(0,o.kt)("p",null,"A ",(0,o.kt)("strong",{parentName:"p"},"critical section")," of a concurrent program is the code that cannot be executed simultaneously by all processes, threads, or, in this case, by all goroutines. It is the code that needs to be protected by mutexes. Therefore, identifying the critical sections of your code will make the whole programming process so much simpler that you should pay attention to this task."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"A critical section cannot be embedded in another critical section when both critical sections use the same sync.Mutex or sync.RWMutex variable. Put simply avoid, at almost any cost, spreading mutexes across functions because that makes it really hard to see whether you are embedding or not!")),(0,o.kt)("p",null,"A simple ",(0,o.kt)("a",{target:"_blank",href:n(81111).Z},"example"),", with a lot of comments, to illustrate the ",(0,o.kt)("inlineCode",{parentName:"p"},"sync.Mutex")," usage."),(0,o.kt)("p",null,"However, the programme would fall into deadlock if you forget to unlock ",(0,o.kt)("inlineCode",{parentName:"p"},"sync.Mutex"),", as the ",(0,o.kt)("a",{target:"_blank",href:n(73654).Z},"list")," shows."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"sync.RWMutex")," type is another kind of mutex, to be honest, it is an improved version of ",(0,o.kt)("inlineCode",{parentName:"p"},"sync.Mutex"),". In other words, ",(0,o.kt)("inlineCode",{parentName:"p"},"sync.RWMutex")," is based on ",(0,o.kt)("inlineCode",{parentName:"p"},"sync.Mutex")," with the necessary additions and improvements."),(0,o.kt)("p",null,"Although only ",(0,o.kt)("em",{parentName:"p"},"one writer")," is allowed to perform write operations using a ",(0,o.kt)("inlineCode",{parentName:"p"},"sync.RWMutex")," mutex, you can have ",(0,o.kt)("em",{parentName:"p"},"multiple readers")," owning a ",(0,o.kt)("inlineCode",{parentName:"p"},"sync.RWMutex")," mutex. However, there is one thing of which you should be aware: until ",(0,o.kt)("em",{parentName:"p"},"all the readers")," of a ",(0,o.kt)("inlineCode",{parentName:"p"},"sync.RWMutex")," mutex unlock that mutex, you cannot lock it for writing."),(0,o.kt)("p",null,"The functions that can help you work with a ",(0,o.kt)("inlineCode",{parentName:"p"},"sync.RWMutex")," mutex are ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"RLock()"))," and ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"RUnlock()")),", which are used for locking and unlocking the mutex, respectively, for ",(0,o.kt)("em",{parentName:"p"},"reading purposes"),"."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Lock()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Unlock()")," functions used in a ",(0,o.kt)("inlineCode",{parentName:"p"},"sync.Mutex")," mutex should still be used when you want to lock and unlock a ",(0,o.kt)("inlineCode",{parentName:"p"},"sync.RWMutex")," mutex for ",(0,o.kt)("em",{parentName:"p"},"writing purposes"),"."),(0,o.kt)("p",null,"A simple ",(0,o.kt)("a",{target:"_blank",href:n(18465).Z},"example"),", with a lot of comments, to illustrate the ",(0,o.kt)("inlineCode",{parentName:"p"},"sync.RWMutex")," usage."),(0,o.kt)("h2",{id:"sharing-memory-using-goroutines"},"Sharing memory using goroutines"),(0,o.kt)("p",null,"Although shared memory is the traditional way that threads use to communicate with each other, Go comes with built-in synchronization features that allow a single goroutine to own a shared piece of data. This means that other goroutines must send messages to this single goroutine that owns the shared data, which prevents the corruption of the data."),(0,o.kt)("p",null,"Such a goroutine is called a ",(0,o.kt)("strong",{parentName:"p"},"monitor goroutine"),". In Go terminology, this is ",(0,o.kt)("em",{parentName:"p"},"sharing memory by communicating")," instead of ",(0,o.kt)("em",{parentName:"p"},"communicating by sharing memory"),"."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Simply ",(0,o.kt)("em",{parentName:"p"},"sharing memory")," brings us the problems such as race condition, read-write competition. While using ",(0,o.kt)("em",{parentName:"p"},"communicating"),", using ",(0,o.kt)("inlineCode",{parentName:"p"},"channel")," for example, we are sharing the data / message between goroutines.")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"That said, Go does provide traditional locking mechanisms in the sync package. Most locking issues can be solved using either channels or traditional locks."),(0,o.kt)("p",{parentName:"blockquote"},"So which should you use? Use whichever is most expressive and/or most simple.")),(0,o.kt)("p",null,"A simple ",(0,o.kt)("a",{target:"_blank",href:n(29523).Z},"example"),", with a lot of comments, to illustrate how we can implement shared memory among goroutines using goroutine and channels."),(0,o.kt)("h2",{id:"catching-race-conditions"},"Catching race conditions"),(0,o.kt)("p",null,"Using the ",(0,o.kt)("inlineCode",{parentName:"p"},"-race")," flag when running or building a Go source file will turn on the Go ",(0,o.kt)("strong",{parentName:"p"},"race detector"),", which will make the compiler create a modified version of a typical executable file. This modified version can record all accesses to shared variables as well as all synchronization events that take place, including calls to ",(0,o.kt)("inlineCode",{parentName:"p"},"sync.Mutex")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"sync.WaitGroup"),". After analyzing the relevant events, the race detector prints a report that can help you identify potential problems so that you can correct them."),(0,o.kt)("p",null,"A simple ",(0,o.kt)("a",{target:"_blank",href:n(16648).Z},"example"),", with a lot of comments, to illustrate how we can detect the race condition. Using ",(0,o.kt)("inlineCode",{parentName:"p"},"sync.Mutex"),", we can get rid of the race condition since we locked it."),(0,o.kt)("h2",{id:"the-context-package"},"The context package"),(0,o.kt)("p",null,"The main purpose of the ",(0,o.kt)("inlineCode",{parentName:"p"},"context")," package is to define the ",(0,o.kt)("inlineCode",{parentName:"p"},"Context")," type and support ",(0,o.kt)("em",{parentName:"p"},"cancellation"),"! Yes, you heard that right; the main purpose of the context package is supporting cancellation because there are times that, for some reason, you want to abandon what you are doing. Also, it would be very helpful to be able to include some extra information about your cancelling decisions."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Context")," type is an interface with four methods, named ",(0,o.kt)("inlineCode",{parentName:"p"},"Deadline()"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Done()"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Err()"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"Value()"),". The good news is that you do not need to implement all of these functions of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Context")," interface\u2014you just need to modify a ",(0,o.kt)("inlineCode",{parentName:"p"},"Context")," variable using functions such as ",(0,o.kt)("inlineCode",{parentName:"p"},"context.WithCancel()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"context.WithTimeout()"),"."),(0,o.kt)("p",null,"A simple ",(0,o.kt)("a",{target:"_blank",href:n(96234).Z},"example"),", with a lot of comments, to illustrate how we can create a context with ",(0,o.kt)("inlineCode",{parentName:"p"},"context.Background()"),", how the ",(0,o.kt)("inlineCode",{parentName:"p"},"cancel()")," function is called to ",(0,o.kt)("em",{parentName:"p"},"cancel")," the context."),(0,o.kt)("p",null,"An advanced ",(0,o.kt)("a",{target:"_blank",href:n(95390).Z},"example"),", with a lot of comments, to illustrate how we can create a context with ",(0,o.kt)("inlineCode",{parentName:"p"},"context.Background()"),", how the ",(0,o.kt)("inlineCode",{parentName:"p"},"cancel()")," function is called to ",(0,o.kt)("em",{parentName:"p"},"cancel")," the ",(0,o.kt)("inlineCode",{parentName:"p"},"http.Request"),"."),(0,o.kt)("h2",{id:"worker-pool"},"Worker pool"),(0,o.kt)("p",null,"Generally speaking, a ",(0,o.kt)("em",{parentName:"p"},"Worker pool")," is a set of threads that are about to process jobs assigned to them. We replace the threads with goroutines to implement the worker pool. However, threads do not usually die after serving a request because the cost of ending a thread and creating a new one is too high, whereas goroutines do ",(0,o.kt)("em",{parentName:"p"},"die")," after finishing their job."),(0,o.kt)("p",null,"As you will see in the ",(0,o.kt)("a",{target:"_blank",href:n(91339).Z},"example"),", worker pools are implemented with the help of buffered channels, because they allow you to limit the number of goroutines running at the same time."),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{target:"_blank",href:n(91339).Z},"example")," will implement a simple task: it will process integer numbers and print their square values using a single goroutine for serving each request."),(0,o.kt)("h2",{id:"code-testing-optimization-profiling"},"Code Testing, Optimization, Profiling"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Code optimization")," is the process where you try to discover the parts of your code that have a big influence on the performance of the entire program in order to make them ",(0,o.kt)("em",{parentName:"p"},"run faster")," or ",(0,o.kt)("em",{parentName:"p"},"use fewer resources"),"."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The general advice for optimization is that you must ",(0,o.kt)("em",{parentName:"p"},"optimize bug-free code only"),".")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Profiling")," is a process of dynamic program analysis that measures various values related to program execution in order to give you a better understanding on the behavior of your program."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The single most important thing to remember is that if you want to profile Go code, you will need to import the ",(0,o.kt)("inlineCode",{parentName:"p"},"runtime/pprof")," standard Go package, either directly or indirectly. You can find the help page of the pprof tool by executing the ",(0,o.kt)("inlineCode",{parentName:"p"},"go tool pprof -help")," command.")),(0,o.kt)("p",null,"Go supports two kinds of profiling: ",(0,o.kt)("strong",{parentName:"p"},"CPU profiling")," and ",(0,o.kt)("strong",{parentName:"p"},"memory profiling"),"."),(0,o.kt)("p",null,"Two examples: ",(0,o.kt)("a",{target:"_blank",href:n(99969).Z},"using native package to profile"),", ",(0,o.kt)("a",{target:"_blank",href:n(94063).Z},"using third-party package to profile"),"."),(0,o.kt)("p",null,"Go allows you to write tests for your Go code in order to detect bugs. Strictly speaking, this section is about ",(0,o.kt)("strong",{parentName:"p"},"automated testing"),", which involves writing extra code to verify whether the real code; that is, the production code, works as expected or not. Thus, the result of a test function is either ",(0,o.kt)("em",{parentName:"p"},"PASS")," or ",(0,o.kt)("em",{parentName:"p"},"FAIL"),"."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Always put the testing code in a different source file. There is no need to create a huge source file that is hard to read and maintain.")),(0,o.kt)("p",null,"An ",(0,o.kt)("a",{target:"_blank",href:n(53960).Z},"example")," with its ",(0,o.kt)("a",{target:"_blank",href:n(15979).Z},"test file")," show how to do some test in Go."),(0,o.kt)("h2",{id:"network-programming"},"Network Programming"),(0,o.kt)("p",null,"Some useful snippets on network programming in go could be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/AkatQuas/kiddo-plays/tree/master/golanger/mastering-go-archive/network"},"here"),"."),(0,o.kt)("p",null,"You cannot create a TCP or UDP client or server in Go without using the functionality offered by the ",(0,o.kt)("inlineCode",{parentName:"p"},"net")," package."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"net.Dial()")," function is used for connecting to a network as a client, whereas the ",(0,o.kt)("inlineCode",{parentName:"p"},"net.Listen()")," function is used for telling a Go program to accept network connections and thus act as a server. The first parameter of both functions is the network type, but this is where their similarities end. The return value of both the ",(0,o.kt)("inlineCode",{parentName:"p"},"net.Dial()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"net.Listen()")," functions is of the ",(0,o.kt)("inlineCode",{parentName:"p"},"net.Conn")," type, which implements the ",(0,o.kt)("inlineCode",{parentName:"p"},"io.Reader")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"io.Writer")," interfaces."),(0,o.kt)("h3",{id:"tcp-client"},"TCP client"),(0,o.kt)("p",null,"TCP stands for Transmission Control Protocol, and its principal characteristic is that it is a reliable protocol."),(0,o.kt)("p",null,"The TCP header of each packet includes ",(0,o.kt)("em",{parentName:"p"},"source port")," and ",(0,o.kt)("em",{parentName:"p"},"destination port")," fields. These two fields, plus the source and destination IP addresses, are combined to identify uniquely a single TCP connection."),(0,o.kt)("p",null,"Examples: ",(0,o.kt)("a",{target:"_blank",href:n(48664).Z},"TCP client 1"),", ",(0,o.kt)("a",{target:"_blank",href:n(83549).Z},"TCP client 2"),", ",(0,o.kt)("a",{target:"_blank",href:n(54912).Z},"TCP server 1"),", ",(0,o.kt)("a",{target:"_blank",href:n(23104).Z},"TCP server 2"),", ",(0,o.kt)("a",{target:"_blank",href:n(40236).Z},"TCP server with goroutines"),", ",(0,o.kt)("a",{target:"_blank",href:n(84378).Z},"TCP server 2 with goroutines"),"."),(0,o.kt)("h3",{id:"udp-client"},"UDP client"),(0,o.kt)("p",null,"The biggest difference between UDP and TCP is that UDP is not reliable by design. This also means that in general, UDP is simpler than TCP because UDP does not need to keep the state of a UDP connection."),(0,o.kt)("p",null,"Examples: ",(0,o.kt)("a",{target:"_blank",href:n(51852).Z},"UDP client"),", ",(0,o.kt)("a",{target:"_blank",href:n(13490).Z},"UDP server"),"."),(0,o.kt)("h3",{id:"remote-procedure-call-rpc"},"Remote Procedure Call (RPC)"),(0,o.kt)("p",null,"Remote Procedure Call (RPC) is a client-server mechanism for Interprocess communication that uses TCP/IP."),(0,o.kt)("h2",{id:"examples-for-closures-and-anonymous-goroutines"},"Examples for Closures and Anonymous Goroutines"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'var wg sync.WaitGroup\nsalutation := "hello"\nwg.Add(1)\ngo func() {\n  defer wg.Done()\n  salutation = "welcome"\n}()\nwg.Wait()\nfmt.Println(salutation) // salutation is modified to "welcome"\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'// Compile warning: loop variable salutation captured by func literal\n//\n// output: the order is non-deterministic, but the salutation is "good day"\n// 2 good day\n// 0 good day\n// 1 good day\nvar wg sync.WaitGroup\nfor i, salutation := range []string{"hello", "greetings", "good day"} {\n  wg.Add(1)\n  go func(index int) {\n    defer wg.Done()\n    fmt.Println(i, salutation)\n  }(i)\n}\nwg.Wait()\n')),(0,o.kt)("p",null,"In the above example, the goroutine is running a closure that has closed over the iteration variable ",(0,o.kt)("inlineCode",{parentName:"p"},"salutation"),", which has a type of ",(0,o.kt)("inlineCode",{parentName:"p"},"string"),". As our loop iterates, ",(0,o.kt)("inlineCode",{parentName:"p"},"salutation")," is being assigned to the next string value in the slice literal. Because the goroutines being scheduled may run at any point in time in the future, it is undetermined what values will be printed from within the goroutine. This means the ",(0,o.kt)("inlineCode",{parentName:"p"},"salutation")," variable falls out of scope. This is an interesting side note about how Go manages memory. The Go runtime is observant enough to know that a reference to the salutation variable is still being held, and therefore will transfer the memory to the heap so that the goroutines can continue to access it."),(0,o.kt)("p",null,"Usually, the ",(0,o.kt)("em",{parentName:"p"},"loop")," exits before any ",(0,o.kt)("em",{parentName:"p"},"goroutines")," begin running, so salutation is transferred to the heap holding a reference to the last value in the slice, ",(0,o.kt)("inlineCode",{parentName:"p"},'"good day"'),"."),(0,o.kt)("p",null,"The proper way to write this loop is to pass a copy of ",(0,o.kt)("inlineCode",{parentName:"p"},"salutation")," into the closure so that by the time the goroutine is run, it will be operating on the data from its iteration of the loop."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'// output: order is non-deterministic\n// hello\n// good day\n// greetings\nvar wg sync.WaitGroup\nfor _, salutation := range []string{"hello", "greetings", "good day"} {\n  wg.Add(1)\n  go func(salutation string) { // declare a parameter, which shadow the original salutation variable\n    defer wg.Done()\n    fmt.Println(salutation)\n  }(salutation) // pass in the current iteration\u2019s variable to the closure\n}\nwg.Wait()\n')))}h.isMDXComponent=!0},48664:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/TCPclient-231f2f97b2b51de299f689ae117ef6ce.go"},83549:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/TCPclient_other-9d3d5c8d2c868a55768d1727fb90ea2b.go"},54912:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/TCPserver-1878d58c6a064756e67f56e020a9c667.go"},84378:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/TCPserver_go_example-35dfe4208adc0909b188ce8d67d7bdf0.go"},40236:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/TCPserver_goroutine-7d18e0e217f0ed2d15c853e609131c68.go"},23104:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/TCPserver_other-5deff9c4149b312245570dc1e8fdbc95.go"},51852:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/UDPclient-fa0d5b6319789155d873140dee2e5101.go"},13490:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/UDPserver-8a345264f5cc716963ed53449bae9cf2.go"},40229:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/channelInOrder-5dc2654e0a454e3e5f010a171da56396.go"},56886:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/channelUsages-4e123ed0c2cf7b5f2b5bbd46dce5757d.go"},96234:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/contextSimple-02c1cce91913ebf19579df55d9b6caf4.go"},95390:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/contextWithHttp-5678eaa8b6b2891d0cfe9822193dc639.go"},25682:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/dateAndTime-2fe7952c00666bb4b6454393ed241029.go"},24273:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/error-handling-c89010eee682068f59bcc3e9f16f69f7.go"},49104:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/flow-control-57cf03c4e5988334a4db776b503e0931.go"},34151:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/garbageCollector-d2f9122a3b5919c53d591960ebf2c52b.go"},29523:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/goroutinesSharedMemory-ec3ea0c27734e649f557eb158c2916b4.go"},18634:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/goroutinesSync-708e9d20c19d72f6f2f39d987cf7b30a.go"},10846:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/interfacesAssertion-961d0bbf5cfa14a5558d44ee1ebd4aaa.go"},73654:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/mutexDeadlocked-b2204daf0d8c396cfd32f5df8b66b0e7.go"},81111:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/mutexSimple-b59bcbf3f5cffdc6d3cb8dab37d174f1.go"},55913:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/panicRecover-98a22e5404fe853fe494e58510900aff.go"},99969:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/profileMe-3669093bb548ac44265b4ccb92cdee19.go"},94063:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/profileMeBetter-4785219f0321a9cb864ed3614d9ae71f.go"},16648:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/raceCatch-6dcff5a8b0478205dd087b14f07e2106.go"},33028:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/reflection-76ca84c49e7c8f6b1dad15f3edff47ab.go"},18465:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/rwMutexSimple-b7470840edc28c4147f661f7576d15f0.go"},26638:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/selectSimple-4afe2cbb04415452d867771b0d7fb96a.go"},68749:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/selectTimeout-fa3af3f1445a17683f9ed4e20dcf31fd.go"},58971:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/simple-defer-b7232cf53097e1e94073ffd476050c9c.go"},53960:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/testMe-a8e3cdd25c37084af9865521d6355cc3.go"},15979:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/testMe_test-a752f156497f0d3b0eac59ef54198aca.go"},80422:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/unsafe-3634ac4d40fb1fe3f5430875ba9d97c6.go"},76908:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/useStrings-01a1de9a4b880ed64e3a40ed16b5a5e3.go"},91339:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/workerPool-cd8ea427d300dd8a401a352f89e7c481.go"}}]);