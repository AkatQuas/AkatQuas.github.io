"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2648],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>u});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),i=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},c=function(e){var t=i(e.components);return n.createElement(p.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=i(a),h=r,u=m["".concat(p,".").concat(h)]||m[h]||d[h]||o;return a?n.createElement(u,l(l({ref:t},c),{},{components:a})):n.createElement(u,l({ref:t},c))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,l=new Array(o);l[0]=h;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[m]="string"==typeof e?e:r,l[1]=s;for(var i=2;i<o;i++)l[i]=a[i];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},27876:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>i});var n=a(87462),r=(a(67294),a(3905));const o={title:"14",tags:["lisp","interpreter"]},l=void 0,s={unversionedId:"lisp-interpreter-in-py/chapter-14",id:"lisp-interpreter-in-py/chapter-14",title:"14",description:"This is what we're going to learn today:",source:"@site/docs/lisp-interpreter-in-py/chapter-14.md",sourceDirName:"lisp-interpreter-in-py",slug:"/lisp-interpreter-in-py/chapter-14",permalink:"/docs/lisp-interpreter-in-py/chapter-14",draft:!1,tags:[{label:"lisp",permalink:"/docs/tags/lisp"},{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",frontMatter:{title:"14",tags:["lisp","interpreter"]},sidebar:"tutorialSidebar",previous:{title:"13 Introduction to semantic analysis",permalink:"/docs/lisp-interpreter-in-py/chapter-13"},next:{title:"Structure and Interpretation of Computer Programs",permalink:"/docs/sicp/index"}},p={},i=[{value:"Scopes and scoped symbol tables",id:"scopes-and-scoped-symbol-tables",level:2},{value:"Procedure declarations with formal parameters",id:"procedure-declarations-with-formal-parameters",level:2},{value:"Procedure Symbols",id:"procedure-symbols",level:2},{value:"Nested Scopes",id:"nested-scopes",level:2},{value:"Scope tree: Chaining scoped symbol tables",id:"scope-tree-chaining-scoped-symbol-tables",level:2},{value:"Nested scopes and name resolution",id:"nested-scopes-and-name-resolution",level:2},{value:"Source-to-source compiler",id:"source-to-source-compiler",level:2},{value:"Quick Reference",id:"quick-reference",level:2}],c={toc:i};function m(e){let{components:t,...o}=e;return(0,r.kt)("wrapper",(0,n.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is what we're going to learn today:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Scopes, why scopes useful, how to implement them in code with symbol tables")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Nested scopes, how chained scoped symbol tables are used to implement nested scopes")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"How to parse procedure declarations with formal parameters and how to represent a procedure symbol in code.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"How to extend the ",(0,r.kt)("em",{parentName:"p"},"semantic analyzer")," to do semantic checks in the presence of nested scopes")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Learn more about ",(0,r.kt)("em",{parentName:"p"},"name resolution")," and how the semantic analyzer resolves names to their declarations when a program has nested scopes.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"How to build a ",(0,r.kt)("em",{parentName:"p"},"scope tree"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"How to write the very own ",(0,r.kt)("em",{parentName:"p"},"source-to-source compiler")))),(0,r.kt)("h2",{id:"scopes-and-scoped-symbol-tables"},"Scopes and scoped symbol tables"),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"scope")," is a textual region of a program where a name can be used."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"program Main;\n    var x, y : integer;\nbegin\n    x := x + y;\nend.\n")),(0,r.kt)("p",null,"In Pascal, the ",(0,r.kt)("em",{parentName:"p"},"PROGRAM")," keyword (case-insensitive) introduces a new scope which is commonly called a ",(0,r.kt)("em",{parentName:"p"},"global scope"),", so the program above has one ",(0,r.kt)("em",{parentName:"p"},"global scope")," and the declared variables x and y are visible and accessible in the whole program."),(0,r.kt)("p",null,"When we talk about the scope of a variable, we actually talk about the scope of its declaration."),(0,r.kt)("p",null,"Pascal programs are said to be ",(0,r.kt)("em",{parentName:"p"},"lexically scoped")," (or ",(0,r.kt)("em",{parentName:"p"},"statically scoped"),") because you can look at the source code, and without even executing the program, determine purely based on the textual rules which names(references) resolve or refer to which declarations. In Pascal, lexcial keywords like ",(0,r.kt)("em",{parentName:"p"},"program")," and ",(0,r.kt)("em",{parentName:"p"},"end")," demarcate the textual boundaries of a scope:"),(0,r.kt)("img",{src:"./imgs/lsbasi_part14_img04.png",alt:""}),(0,r.kt)("p",null,"Why are scopes useful?"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Every scope creates an isolated namespace, which means that variables declared in a scope cannot be accessed from outside of it.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Re-use the same name in different scopes and know exactly, just by looking at the program source code, what declaration the name refers to at every point in the program.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"In a nested scope you can re-declare a variable with the same name as in the outer scope, thus effectively hiding the outer declaration, which gives you control over access to different variables from the outer scope."))),(0,r.kt)("p",null,"In addition to the ",(0,r.kt)("em",{parentName:"p"},"global scope"),", Pascal supports nested procedures, and every procedure declaration introduces a new scope, which means that Pascal supports nested scopes."),(0,r.kt)("p",null,"When we talk about nested scopes, it's convenient to talk about scope levels to show their nesting relationships. It's also convenient to refer to scopes by name. We'll use both scope levels and scope names when we start our discussion of nested scopes."),(0,r.kt)("p",null,"Let's take a look at the following sample program and subscript every name in the program to make it clear:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"At what level each variable (symbol) is declared"),(0,r.kt)("li",{parentName:"ol"},"To which declaration and at what level a variable name refers to:")),(0,r.kt)("img",{src:"./imgs/lsbasi_part14_img05.png",alt:""}),(0,r.kt)("p",null,"From the picture above we can see several things:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We have a single scope, the ",(0,r.kt)("em",{parentName:"li"},"global")," scope, introduced by the PROGRAM keyword"),(0,r.kt)("li",{parentName:"ul"},"Global ",(0,r.kt)("em",{parentName:"li"},"scope")," is at level 1"),(0,r.kt)("li",{parentName:"ul"},"Variables (symbols) x and y are declared at level 1 (the ",(0,r.kt)("em",{parentName:"li"},"global")," scope)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"integer")," built-in type is also declared at level 1"),(0,r.kt)("li",{parentName:"ul"},"The program name Main has a subscript 0. Why is the program's name at level zero, you might wonder? This is to make it clear that the program's name is not in the ",(0,r.kt)("em",{parentName:"li"},"global scope")," and it's in some other outer scope, that has level zero."),(0,r.kt)("li",{parentName:"ul"},"The scope of the variables x and y is the whole program, as shown by the vertical lines"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("em",{parentName:"li"},"scope information table")," shows for every level in the program the corresponding scope level, scope name, and names declared in the scope. The purpose of the table is to summarize and visually show different information about scopes in a program.")),(0,r.kt)("p",null,"To represent a scope in code, we'll need a ",(0,r.kt)("em",{parentName:"p"},"scoped symbol table"),", which is basically a symbol table with a few modifications."),(0,r.kt)("p",null,"From now on, we'll use the word ",(0,r.kt)("em",{parentName:"p"},"scope")," both to mean the concept of a scope as well as to refer to the scoped symbol table which is an implementation of the scope in code."),(0,r.kt)("p",null,"Even though in our code a scope is represented by an instance of the ",(0,r.kt)("em",{parentName:"p"},"ScopedSymbolTable")," class, we'll use the variable named ",(0,r.kt)("em",{parentName:"p"},"scope")," throughout the code for convenience. So when you see a variable ",(0,r.kt)("em",{parentName:"p"},"scope")," in the code of the interpreter, you should know that it actually refers to a ",(0,r.kt)("em",{parentName:"p"},"scoped symbol table"),"."),(0,r.kt)("p",null,"Now, let's enhance our ",(0,r.kt)("em",{parentName:"p"},"SymbolTable")," class by renaming it to ",(0,r.kt)("em",{parentName:"p"},"ScopedSymbolTable")," class, adding two new fields ",(0,r.kt)("em",{parentName:"p"},"scope_level")," and ",(0,r.kt)("em",{parentName:"p"},"scope_name"),", and updating the scoped symbol table's constructor. And at the same time, let's update the ",(0,r.kt)("inlineCode",{parentName:"p"},"__str__")," method to print additional information, namely the ",(0,r.kt)("em",{parentName:"p"},"scope_level")," and ",(0,r.kt)("em",{parentName:"p"},"scope_name"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class ScopedSymbolTable(object):\n    def __init__(self, scope_name, scope_level):\n        self._symbols = OrderedDict()\n        self.scope_name = scope_name\n        self.scope_level = scope_level\n        self._init_builtins()\n\n    def _init_builtins(self):\n        self.insert(BuiltinTypesSymbol('INTEGER'))\n        self.insert(BuiltinTypesSymbol('REAL'))\n\n    def __str__(self):\n        h1 = 'SCOPE (SCOPED SYMBOL TABLE)'\n        lines = ['\\n', h1, '=' * len(h1)]\n        for header_name, header_value in (\n            ('Scope name' , self.scope_name),\n            ('Scope level', self.scope_level)\n        ):\n            lines.append('%-15s: %s' % (header_name, header_value))\n\n        h2 = 'Scope (Scoped symbol table) contents'\n        lines.extend([h2, '-' *len(h2)])\n        lines.extend(\n            ('%7s: %r ' % (key , value)) for key ,value in self._symbols.items()\n        )\n        lines.append('\\n')\n        s = '\\n'.join(lines)\n        return s\n\n    __repr__ = __str__\n\n    def insert(self, symbol):\n        print('Insert: %s' % symbol.name)\n        self._symbols[symbol.name] = symbol\n\n    def lookup(self, name):\n        print('Lookup: %s' % name)\n        symbol = self._symbols.get(name)\n        # 'symbol' is either an instance of the Symbol class or None\n        return symbol\n")),(0,r.kt)("p",null,"We need to update the semantic analyzer to use the variable ",(0,r.kt)("em",{parentName:"p"},"scope")," instead of ",(0,r.kt)("em",{parentName:"p"},"symtab"),", and remove the semantic check that was checking source programs for duplicate identifiers from the ",(0,r.kt)("em",{parentName:"p"},"visit_VarDecl")," method to reduce the noise in the program output."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class SemanticAnalyzer(NodeVisitor):\n    def __init__(self):\n        self.scope = ScopedSymbolTable(scope_name='global', scope_level=1)\n\n    ...\n")),(0,r.kt)("h2",{id:"procedure-declarations-with-formal-parameters"},"Procedure declarations with formal parameters"),(0,r.kt)("p",null,"A sample code that contains a procedure declaration:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"program Main;\n   var x, y: real;\n\n   procedure Alpha(a : integer);\n      var y : integer;\n   begin\n      x := a + x + y;\n   end;\n\nbegin { Main }\n\nend.  { Main }\n")),(0,r.kt)("p",null,"You can see the procedure here comes with a parameter. Let's tackle this first by making a quick detour and learning how to handle formal procedure parameters."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"ASIDE ",(0,r.kt)("em",{parentName:"p"},"Formal parameters")," are parameters that show up in the declaration of a procedure. ",(0,r.kt)("em",{parentName:"p"},"Arguments")," (aka ",(0,r.kt)("em",{parentName:"p"},"actual parameters"),") are different variables and expressions passed to a procedure in a particular procedure call.")),(0,r.kt)("p",null,"We have many changes to make to support procedure declarations with parameters:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Add the ",(0,r.kt)("em",{parentName:"p"},"Param AST")," node"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Param(AST):\n    def __init__(self, var_node, type_node):\n        self.var_node = var_node\n        self.type_node = type_node\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Update the ",(0,r.kt)("em",{parentName:"p"},"ProcedureDecl")," node's constructor to take an additional argument: ",(0,r.kt)("em",{parentName:"p"},"params")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class ProcedureDecl(AST):\n    def __init__(self, proc_name, params, block_node):\n        self.proc_name = proc_name\n        self.params = params  # a list of Param nodes\n        self.block_node = block_node\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Update the ",(0,r.kt)("em",{parentName:"p"},"declarations")," rule to reflect changes in the procedure declaration sub-rule"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def declarations(self):\n    """declarations : (VAR (variable_declaration SEMI)+)*\n                | (PROCEDURE ID (LPAREN formal_parameter_list RPAREN)? SEMI block SEMI)*\n                | empty\n    """\n'))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("em",{parentName:"p"},"formal_parameter_list")," rule and method"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def formal_parameter_list(self):\n    """ formal_parameter_list : formal_parameters\n                            | formal_parameters SEMI formal_parameter_list\n    """\n'))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Add the ",(0,r.kt)("em",{parentName:"p"},"formal_parameters")," rule and method"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def formal_parameters(self):\n    """ formal_parameters : ID (COMMA ID)* COLON type_spec """\n    param_nodes = []\n')))),(0,r.kt)("p",null,"With these additions of the above methods and rules our parser will be able to parse procedure declarations like the following sample code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"procedure Foo;\n\nprocedure Foo(a : INTEGER);\n\nprocedure Foo(a, b : INTEGER);\n\nprocedure Foo(a, b : INTEGER; c : REAL);\n")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"center"},(0,r.kt)("img",{src:"./imgs/lsbasi_part14_img06.png",alt:""})))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"AST")))),(0,r.kt)("h2",{id:"procedure-symbols"},"Procedure Symbols"),(0,r.kt)("p",null,"As with variable declarations, and built-in type declarations, there is a separate category of symbols for procedures. Let's create a separate symbol class for procedure symbols:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class ProcedureSymbol(Symbol):\n    def __init__(self, name, params=None):\n        super().__init__(name)\n        # a list of formal parameters\n        self.params = params if params is not None else []\n\n    def __str__(self):\n        return '<{class_name}(name={name}, parameters={params})>'.format(\n            class_name=self.__class__.__name__,\n            name=self.name,\n            params=self.params,\n        )\n\n    __repr__ = __str__\n")),(0,r.kt)("p",null,"Procedure symbols have a name (the procedure's name), their category is procedure (encoded in the class name), and the type is ",(0,r.kt)("em",{parentName:"p"},"None")," because in Pascal procedures don't return anything."),(0,r.kt)("p",null,"Procedure symbols also carry additional information about procedure declarations, namely they contain information about the procedure's formal parameters."),(0,r.kt)("p",null,"With the addition of procedure symbols, our new symbol hierarchy looks like this:"),(0,r.kt)("img",{src:"./imgs/lsbasi_part14_img07.png",alt:""}),(0,r.kt)("h2",{id:"nested-scopes"},"Nested Scopes"),(0,r.kt)("p",null,"Now time to get back to the program and the discussion of nested scopes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"program Main;\n   var x, y: real;\n\n   procedure Alpha(a : integer);\n      var y : integer;\n   begin\n      x := a + x + y;\n   end;\n\nbegin { Main }\n\nend.  { Main }\n")),(0,r.kt)("p",null,"By declaring a new procedure, we introduce a new scope, and this scope is nested within the ",(0,r.kt)("em",{parentName:"p"},"global scope")," introduced by the ",(0,r.kt)("em",{parentName:"p"},"PROGRAM")," statement, so this is a case where we have nested scopes in a Pascal program."),(0,r.kt)("p",null,"The scope of a procedure is the whole body of the procedure. The beginning of the procedure scope is marked by the ",(0,r.kt)("em",{parentName:"p"},"PROCEDURE")," keyword and the end is marked by the ",(0,r.kt)("em",{parentName:"p"},"END")," keyword and a semicolon."),(0,r.kt)("p",null,"Let's subscript names in the program and show some additional information:"),(0,r.kt)("img",{src:"./imgs/lsbasi_part14_img08.png",alt:""}),(0,r.kt)("p",null,"Some observation from the picture above:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Tow scope level: level 1 and level 2")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("em",{parentName:"p"},"nesting relationships")," diagram visually shows that the scope ",(0,r.kt)("em",{parentName:"p"},"Alpha")," is nested within the ",(0,r.kt)("em",{parentName:"p"},"global scope"),", hence there are two levels: the ",(0,r.kt)("em",{parentName:"p"},"global scope")," at level 1, and the ",(0,r.kt)("em",{parentName:"p"},"Alpha")," scope at level 2.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The scope level of the procedure declaration ",(0,r.kt)("em",{parentName:"p"},"Alpha")," is one less than the level of the variables declared inside the procedure ",(0,r.kt)("em",{parentName:"p"},"Alpha"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The variable declaration of y inside ",(0,r.kt)("em",{parentName:"p"},"Alpha")," hides the declaration of y in the ",(0,r.kt)("em",{parentName:"p"},"global scope"),". You can see the hole in the vertical bar for y",(0,r.kt)("sub",null,"1")," and you can see that the scope of the y",(0,r.kt)("sub",null,"2")," variable declaration is the Alpha procedure's whole body.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The scope information table shows scope levels, scope names for those levels, and respective names declared in those scopes.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"In the picture, we omitted showing the scope of the ",(0,r.kt)("em",{parentName:"p"},"integer")," and ",(0,r.kt)("em",{parentName:"p"},"real")," types (except in the scope information table) because they are always declared at scope level 1, the ",(0,r.kt)("em",{parentName:"p"},"global scope"),"."))),(0,r.kt)("p",null,"Now on discussing implementation details."),(0,r.kt)("p",null,"First, let's focus on variable and procedure declarations. Then, we'll discuss variable references and how ",(0,r.kt)("em",{parentName:"p"},"name resolution")," works in teh presence of nested scopes."),(0,r.kt)("p",null,"For our discussion, we'll use a stripped down version of the program. The following version does not have variable references, it only has variable and procedure declarations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"program Main;\n   var x, y: real;\n\n   procedure Alpha(a : integer);\n      var y : integer;\n   begin\n\n   end;\n\nbegin { Main }\n\nend.  { Main }\n")),(0,r.kt)("p",null,"From the code, we have two scopes: the ",(0,r.kt)("em",{parentName:"p"},"global scope")," and the scope introduced by the procedure ",(0,r.kt)("em",{parentName:"p"},"Alpha"),". Following our approach we should now have two scoped symbol tables: one for the ",(0,r.kt)("em",{parentName:"p"},"global scope")," and one for the ",(0,r.kt)("em",{parentName:"p"},"Alpha scope"),"."),(0,r.kt)("p",null,"We'll extend the semantic analyzer to create a separate scoped symbol table for every scope instead of just for the ",(0,r.kt)("em",{parentName:"p"},"global scope"),". The scope construction will happen when walking the AST."),(0,r.kt)("p",null,"We're going to update the ",(0,r.kt)("em",{parentName:"p"},"visit_Program")," method and add the ",(0,r.kt)("em",{parentName:"p"},"visit_ProcedureDecl")," method to create scoped symbol tables."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def visit_Program(self,node):\n    print('ENTER scope: global')\n    global_scope = ScopedSymbolTable(\n        scope_name='global',\n        scope_level=1\n    )\n    self.current_scope = global_scope\n\n    # visit subtree\n    self.visit(node.block)\n\n    print(global_scope)\n    print('LEAVE scope: global')\n")),(0,r.kt)("p",null,"The method has quite a few changes:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"When visiting the node in AST, we first print what scope we're entering, in this case ",(0,r.kt)("em",{parentName:"p"},"global"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Create a separate ",(0,r.kt)("em",{parentName:"p"},"scoped symbol table")," to represent the ",(0,r.kt)("em",{parentName:"p"},"global scope"),". When constructing an instance of ",(0,r.kt)("em",{parentName:"p"},"ScopedSymbolTable"),", we explicitly pass the scope name and scope level arguments to the class constructor.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Assign the newly created scope to the instance variable ",(0,r.kt)("em",{parentName:"p"},"current_scope"),". Other visitor methods that insert and look up symbols in scoped symbol tables will use the ",(0,r.kt)("em",{parentName:"p"},"current_scope"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Visit a subtree (block).")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Before leaving the ",(0,r.kt)("em",{parentName:"p"},"global scope")," we print the contents of the ",(0,r.kt)("em",{parentName:"p"},"global scope")," (scoped symbol table)")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Print the message when leaving the global scope"))),(0,r.kt)("p",null,"Now let's add the ",(0,r.kt)("em",{parentName:"p"},"visit_ProcedureDecl")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def visit_ProcedureDecl(self, node):\n    proc_name = node.proc_name\n    proc_symbol = ProcedureSymbol(proc_name)\n    self.current_scope.insert(proc_symbol)\n\n    print('ENTER scope: %s ' % proc_name)\n\n    # Scope for parameters and Local variables\n    procedure_scope = ScopedSymbolTable(\n        scope_name=proc_name,\n        scope_level=2\n    )\n    self.current_scope = procedure_scope\n\n    # Insert parameters into the procedure scope\n    for param in node.params:\n        param_type = self.current_scope.lookup(param.type_node.value)\n        param_name = param.var_node.value\n        var_symbol = VarSymbol(param_name, param_type)\n        self.current_scope.insert(var_symbol)\n        proc_symbol.params.append(var_symbol)\n\n    self.visit(node.block_node)\n\n    print(procedure_scope)\n    print('LEAVE scope: %s' %s proc_name)\n")),(0,r.kt)("p",null,"Let's go over the contents of the method:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The first thing that the method does is create a procedure symbol and insert it into the current scope, which is the ",(0,r.kt)("em",{parentName:"p"},"global")," scope for our sample program.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Prints the message about entering the procedure scope.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Then create a new scope for the procedure's parameters and variable declarations.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Assign the procedure scope to the ",(0,r.kt)("em",{parentName:"p"},"self.current_scope")," variable indicating that this is our current scope and all symbol operations (",(0,r.kt)("em",{parentName:"p"},"insert")," and ",(0,r.kt)("em",{parentName:"p"},"lookup"),") will use the current scope.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Then handle procedure formal parameters by inserting them into the current scope and adding them to the procedure symbol.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Then visit the rest of the AST subtree - the body of the procedure.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Finally, print the message about leaving the scope before leaving the node and moving to another AST node, if any."))),(0,r.kt)("p",null,"Now, what we need to do is update other semantic analyzer visitor methods to use ",(0,r.kt)("em",{parentName:"p"},"self.current_scope")," when inserting and looking up symbols"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def visit_VarDecl(self, node):\n    type_name = node.type_node.value\n    type_symbol = self.current_scope.lookup(type_name)\n\n    # We have all the information we need to create a variable symbol.\n    # Create the symbol and insert it into the symbol table.\n    var_name = node.var_node.value\n    var_symbol = VarSymbol(var_name, type_symbol)\n\n    self.current_scope.insert(var_symbol)\n\ndef visit_Var(self, node):\n    var_name = node.value\n    var_symbol = self.current_scope.lookup(var_name)\n    if var_symbol is None:\n        raise Exception(\n            \"Error: Symbol(identifier) not found '%s' \" % var_name\n        )\n")),(0,r.kt)("p",null,"Both the ",(0,r.kt)("em",{parentName:"p"},"visit_VarDeal")," and ",(0,r.kt)("em",{parentName:"p"},"visit_Var")," will now use the ",(0,r.kt)("em",{parentName:"p"},"current_scope")," to insert and/or look up symbols."),(0,r.kt)("p",null,"We also need to update the semantic analyzer and set the ",(0,r.kt)("em",{parentName:"p"},"current_scope")," to ",(0,r.kt)("em",{parentName:"p"},"None")," in the constructor:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class SemanticAnalyzer(NodeVisitor):\n    def __init__(self):\n        self.current_scope = None\n\n    def visit_Block(self, node):\n        for declaration in node.declarations:\n            self.visit(declaration)\n        self.visit(node.compound_statement)\n\n    def visit_Program(self, node):\n        print('ENTER scope: global')\n        global_scope = ScopedSymbolTable(\n            scope_name='global',\n            scope_level=1,\n        )\n        self.current_scope = global_scope\n\n        # visit subtree\n        self.visit(node.block)\n\n        print(global_scope)\n        print('LEAVE scope: global')\n\n    def visit_Compound(self, node):\n        for child in node.children:\n            self.visit(child)\n\n    def visit_NoOp(self, node):\n        pass\n\n    def visit_BinOp(self, node):\n        self.visit(node.left)\n        self.visit(node.right)\n\n    def visit_ProcedureDecl(self, node):\n        proc_name = node.proc_name\n        proc_symbol = ProcedureSymbol(proc_name)\n        self.current_scope.insert(proc_symbol)\n\n        print('ENTER scope: %s' %  proc_name)\n        # Scope for parameters and local variables\n        procedure_scope = ScopedSymbolTable(\n            scope_name=proc_name,\n            scope_level=2,\n        )\n        self.current_scope = procedure_scope\n\n        # Insert parameters into the procedure scope\n        for param in node.params:\n            param_type = self.current_scope.lookup(param.type_node.value)\n            param_name = param.var_node.value\n            var_symbol = VarSymbol(param_name, param_type)\n            self.current_scope.insert(var_symbol)\n            proc_symbol.params.append(var_symbol)\n\n        self.visit(node.block_node)\n\n        print(procedure_scope)\n        print('LEAVE scope: %s' %  proc_name)\n\n    def visit_VarDecl(self, node):\n        type_name = node.type_node.value\n        type_symbol = self.current_scope.lookup(type_name)\n\n        # We have all the information we need to create a variable symbol.\n        # Create the symbol and insert it into the symbol table.\n        var_name = node.var_node.value\n        var_symbol = VarSymbol(var_name, type_symbol)\n\n        self.current_scope.insert(var_symbol)\n\n    def visit_Assign(self, node):\n        # right-hand side\n        self.visit(node.right)\n        # left-hand side\n        self.visit(node.left)\n\n    def visit_Var(self, node):\n        var_name = node.value\n        var_symbol = self.current_scope.lookup(var_name)\n        if var_symbol is None:\n            raise Exception(\n                \"Error: Symbol(identifier) not found '%s'\" % var_name\n            )\n")),(0,r.kt)("h2",{id:"scope-tree-chaining-scoped-symbol-tables"},"Scope tree: Chaining scoped symbol tables"),(0,r.kt)("p",null,"Now every scope is represented by a separate scoped symbol table, how do we express in code that the scope ",(0,r.kt)("em",{parentName:"p"},"B")," is nested within the ",(0,r.kt)("em",{parentName:"p"},"global scope"),"?"),(0,r.kt)("p",null,"Chain the tables together."),(0,r.kt)("p",null,"Let's take a look at the following ",(0,r.kt)("em",{parentName:"p"},"scope tree"),":"),(0,r.kt)("img",{src:"./imgs/lsbasi_part14_img11.png",alt:""}),(0,r.kt)("p",null,"So how to do that?"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Update the ",(0,r.kt)("em",{parentName:"p"},"ScopedSymbolTable")," class and add a variable ",(0,r.kt)("em",{parentName:"p"},"enclosing_scope")," that will hold a pointer to the scope's enclosing scope.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Update the ",(0,r.kt)("em",{parentName:"p"},"visit_Program")," and ",(0,r.kt)("em",{parentName:"p"},"visit_ProcedureDecl")," methods to create an actual link to the scope's enclosing scope using the updated version of the ",(0,r.kt)("em",{parentName:"p"},"ScopedSymbolTable")," class."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class ScopedSymbolTable(object):\n    def __init__(self, scoped_name, scope_level, enclosing_scope=None):\n        self._symbols = OrderedDict()\n        self.scope_name = scope_name\n        self.scope_level = scope_level\n        self.enclosing_scope = enclosing_scope\n        self._init_builtins()\n\n    def _init_builtins(self):\n        self.insert(BuiltinTypeSymbol('INTEGER'))\n        self.insert(BuiltinTypeSymbol('REAL'))\n\n    def __str__(self):\n        h1 = 'SCOPE (SCOPED SYMBOL TABLE)'\n        lines = ['\\n', h1, '=' * len(h1)]\n        for header_name, header_value in (\n            ('Scope name', self.scope_name),\n            ('Scope level', self.scope_level),\n            ('Enclosing scope',\n             self.enclosing_scope.scope_name if self.enclosing_scope else None\n            )\n        ):\n            lines.append('%-15s: %s' % (header_name, header_value))\n        h2 = 'Scope (Scoped symbol table) contents'\n        lines.extend([h2, '-' * len(h2)])\n        lines.extend(\n            ('%7s: %r' % (key, value))\n            for key, value in self._symbols.items()\n        )\n        lines.append('\\n')\n        s = '\\n'.join(lines)\n        return s\n\n    __repr__ = __str__\n\n    def insert(self, symbol):\n        print('Insert: %s ' % symbol.name)\n        self._symbol[symbol.name] = symbol\n\n    def lookup(self, name):\n        print('Lookup: %s ' % name)\n        symbol = self._symbols.get(name)\n        # 'symbol' is either an instance of the Symbol or None\n        return symbol\n\ndef visit_Program(self, node):\n    print('ENTER scope: global')\n    global_scope = ScopedSymbolTable(\n        scope_name='global',\n        scope_level=1,\n        enclosing_scope=self.current_scope, # None\n    )\n    self.current_scope = global_scope\n\n    # visit subtree\n    self.visit(node.block)\n\n    print(global_scope)\n\n    self.current_scope = self.current_scope.enclosing_scope\n    print('LEAVE scope: global')\n")),(0,r.kt)("p",null,"There are a couple of things worth mentioning and repeating:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Explicitly pass the ",(0,r.kt)("em",{parentName:"p"},"self.current_scope")," as the ",(0,r.kt)("em",{parentName:"p"},"enclosing_scope")," argument when creating a scope")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Assign the newly created global scope to the variable ",(0,r.kt)("em",{parentName:"p"},"self.current_scope"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Restore the variable ",(0,r.kt)("em",{parentName:"p"},"self.current_scope")," to its previous value right before leaving the ",(0,r.kt)("em",{parentName:"p"},"Program")," node."))),(0,r.kt)("p",null,"And, updating the ",(0,r.kt)("em",{parentName:"p"},"visit_ProcedureDecl")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def visit_ProcedureDecl(self,node):\n    proc_name = node.proc_name\n    proc_symbol = ProcedureSymbol(proc_name)\n    self.current_scope.insert(proc_symbol)\n\n    print('ENTER scope: %s' %  proc_name)\n    # Scope for parameters and local variables\n    procedure_scope = ScopedSymbolTable(\n        scope_name=proc_name,\n        scope_level=self.current_scope.scope_level+1,\n        enclosing_scope=self.current_scope\n    )\n\n    self.current_scope = procedure_scope\n\n    for param in node.params:\n        param_type = self.current_scope.lookup(param.type_node.value)\n        param_name = param.var_node.value\n        var_symbol = VarSymbol(param_name, param_type)\n        self.current_scope.insert(var_symbol)\n        proc_symbol.params.append(var_symbol)\n\n    self.visit(node.block_node)\n\n    print(procedure_scope)\n    self.current_scope = self.current_scope.enclosing_scope\n    print('LEAVE scope: %s ' % proc_name)\n")),(0,r.kt)("p",null,"The main changes are:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Explicitly pass the ",(0,r.kt)("em",{parentName:"p"},"self.current_scope")," as an ",(0,r.kt)("em",{parentName:"p"},"enclosing_scope")," argument when creating a scope.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Calculate the level automatically based on the scope level of the procedure's enclosing scope: increment by one!")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Restore the value of the ",(0,r.kt)("em",{parentName:"p"},"self.current_scope")," to its previous value right before leaving the ",(0,r.kt)("em",{parentName:"p"},"ProcedureDecl")," node."))),(0,r.kt)("p",null,"Let's consider why it is important to set and restore the value of the ",(0,r.kt)("em",{parentName:"p"},"self.current_scope")," variable. Just take a look at the following program, where we have two procedure declarations in the ",(0,r.kt)("em",{parentName:"p"},"global scope"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"program Main;\n   var x, y : real;\n\n   procedure AlphaA(a : integer);\n      var y : integer;\n   begin { AlphaA }\n\n   end;  { AlphaA }\n\n   procedure AlphaB(a : integer);\n      var b : integer;\n   begin { AlphaB }\n\n   end;  { AlphaB }\n\nbegin { Main }\n\nend.  { Main }\n")),(0,r.kt)("p",null,"The nesting relationship diagram for the sample program looks like this:"),(0,r.kt)("img",{src:"./imgs/lsbasi_part14_img12.png",alt:""}),(0,r.kt)("p",null,"The way our semantic analyzer walks the tree is depth first, left-to-right, so it will traverse the ",(0,r.kt)("em",{parentName:"p"},"ProcedureDecl")," node for ",(0,r.kt)("em",{parentName:"p"},"AlphaA")," first and then it will visit the ",(0,r.kt)("em",{parentName:"p"},"ProcedureDecl")," node for ",(0,r.kt)("em",{parentName:"p"},"AlphaB"),". The problem here is that if we don't restore the ",(0,r.kt)("em",{parentName:"p"},"self.current_scope")," before leaving ",(0,r.kt)("em",{parentName:"p"},"AlphaA")," the ",(0,r.kt)("em",{parentName:"p"},"self.current_scope")," will be left pointing to ",(0,r.kt)("em",{parentName:"p"},"AlphaA")," instead of the ",(0,r.kt)("em",{parentName:"p"},"global scope")," and, as a result, the semantic analyzer will create the scope ",(0,r.kt)("em",{parentName:"p"},"AlphaB")," at level 3, as if it was nested within the scope ",(0,r.kt)("em",{parentName:"p"},"AlphaA"),", which is, of course, incorrect."),(0,r.kt)("p",null,"To construct a scope tree correctly, we need to follow a really simple procedure:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"When ENTER a ",(0,r.kt)("em",{parentName:"p"},"Program")," or ",(0,r.kt)("em",{parentName:"p"},"ProcedureDecl")," node, create a new scope and assign it to the ",(0,r.kt)("em",{parentName:"p"},"self.current_scope"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"When about to LEAVE the ",(0,r.kt)("em",{parentName:"p"},"Program")," or ",(0,r.kt)("em",{parentName:"p"},"ProcedureDecl")," node, we restore the value of the ",(0,r.kt)("em",{parentName:"p"},"self.current_scope")))),(0,r.kt)("p",null,"Just think of the ",(0,r.kt)("em",{parentName:"p"},"self.current_scope")," as a stack pointer and a ",(0,r.kt)("em",{parentName:"p"},"scope tree")," as a collection of stacks."),(0,r.kt)("p",null,"So, if correctly constructed, the ",(0,r.kt)("em",{parentName:"p"},"scope tree")," would look like this:"),(0,r.kt)("img",{src:"./imgs/lsbasi_part14_img13.png",alt:""}),(0,r.kt)("p",null,"Now, let's continue and talk about how ",(0,r.kt)("em",{parentName:"p"},"name resolution")," works when we have nested scopes."),(0,r.kt)("h2",{id:"nested-scopes-and-name-resolution"},"Nested scopes and name resolution"),(0,r.kt)("p",null,"Here is a sample program with some variable references:"),(0,r.kt)("img",{src:"./imgs/lsbasi_part14_img14.png",alt:""}),(0,r.kt)("p",null,"The assignment statement, ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," resolves to a declaration at level 1, ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," resolves to a declaration at level 2 and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," also resolves to a declaration at level 2."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Lexically (statically) scoped")," languages like Pascal follow the most closely nested scope rule when it comes to name resolution. It means that, in every scope, a name refers to its closest lexically declaration. For our assignment statement, let's go over every variable reference and see how the rule works in practice:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The semantic analyzer visits the right-hand side of the assignment first. We begin our search for a's declaration in the closest lexically scope, which is the ",(0,r.kt)("em",{parentName:"p"},"Alpha")," scope. The ",(0,r.kt)("em",{parentName:"p"},"Alpha")," scope contains variable declarations in the ",(0,r.kt)("em",{parentName:"p"},"Alpha")," procedure including the procedure's formal parameters. We find the declaration of a in the ",(0,r.kt)("em",{parentName:"p"},"Alpha")," scope: it\u2019s the formal parameter a of the ",(0,r.kt)("em",{parentName:"p"},"Alpha")," procedure - a variable symbol that has type integer."),(0,r.kt)("img",{src:"./imgs/lsbasi_part14_img16.png",alt:""})),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Again, first we search for the declaration of x in the closest lexically scope. The closest lexically scope is the ",(0,r.kt)("em",{parentName:"p"},"Alpha")," scope at level 2. The scope contains declarations in the ",(0,r.kt)("em",{parentName:"p"},"Alpha")," procedure including the procedure's formal parameters. We don't find x at this scope level (in the ",(0,r.kt)("em",{parentName:"p"},"Alpha")," scope), so we go up the chain to the ",(0,r.kt)("em",{parentName:"p"},"global scope")," and continue our search there. Our search succeeds because the ",(0,r.kt)("em",{parentName:"p"},"global scope")," has a variable symbol with the name x in it:"),(0,r.kt)("img",{src:"./imgs/lsbasi_part14_img17.png",alt:""})),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Now look at the variable reference ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," from the arithmetic expression ",(0,r.kt)("inlineCode",{parentName:"p"},"a + x + y"),". We find its declaration in the closest lexically scope, which is the ",(0,r.kt)("em",{parentName:"p"},"Alpha")," scope. In the ",(0,r.kt)("em",{parentName:"p"},"Alpha")," scope the variable ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," has type integer (if there weren't a declaration for ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," in the Alpha scope we would scan the text and find ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," in the outer/global scope and it would have real type in that case):"),(0,r.kt)("img",{src:"./imgs/lsbasi_part14_img18.png",alt:""})),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Finally, the variable x from the left-hand side of the assignment statement ",(0,r.kt)("inlineCode",{parentName:"p"},"x := a + x + y;"),". It resolves to the same declaration as the variable reference x in the arithmetic expression on the right-hand side:"),(0,r.kt)("img",{src:"./imgs/lsbasi_part14_img19.png",alt:""}))),(0,r.kt)("p",null,"How to implement that behavior of looking in the current scope, and then looking in the enclosing scope, and so on until either find the symbol we're looking for or we've reached the top of the scope tree and there are no more scopes left? We simply need to extend the ",(0,r.kt)("em",{parentName:"p"},"lookup")," method in the ",(0,r.kt)("em",{parentName:"p"},"ScopedSymbolTable")," class to continue its search up the chain in the scope tree:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def lookup(self,name):\n    print('Lookup: %s. (Scope name: %s)' % (name, self.scope_name))\n    # 'symbol' is either an instance of the Symbol class or None\n    symbol = self._symbols.get(name)\n\n    if symbol is not None:\n        return symbol\n\n    # recursively go up the chain and lookup the name\n    if self.enclosing_scope is not None:\n        return self.enclosing_scope.lookup(name)\n")),(0,r.kt)("p",null,"The way the updated ",(0,r.kt)("em",{parentName:"p"},"lookup")," method works:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Search for a symbol by name in the current scope. If the symbol is found, then return it.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"If the symbol is not found, recursively traverse the tree and search for the symbol in the scopes up the chain. You don't have to do the lookup recursively, you can rewrite it into an iterative form; the important part is to follow the link from a nested scope to its enclosing scope and search for the symbol there and up the tree until either the symbol is found or there are no more scopes left because you've reached the top of the scope tree.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("em",{parentName:"p"},"lookup")," method also prints the scope name, in parentheses, where the lookup happens to make it clearer that lookup goes up the chain to search for a symbol, if it can't find it in the current scope."))),(0,r.kt)("h2",{id:"source-to-source-compiler"},"Source-to-source compiler"),(0,r.kt)("p",null,"We will start by talking about definitions. For the purpose of this article, we define a ",(0,r.kt)("em",{parentName:"p"},"source-to-source compiler")," as a compiler that translates a program in some source language into a program in the same (or almost the same) source language."),(0,r.kt)("p",null,"So, if you write a translator that takes as an input a Pascal program and outputs a Pascal program, possibly modified, or enhanced, the translator in this case is called a ",(0,r.kt)("em",{parentName:"p"},"source-to-source compiler"),"."),(0,r.kt)("p",null,"A good example of a source-to-source compiler for us to study would be a compiler that takes a Pascal program as an input and outputs a Pascal-like program where every name is subscripted with a corresponding scope level, and, in addition to that, every variable reference also has a type indicator. So we want a source-to-source compiler that would take the following Pascal program:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"program Main;\n   var x, y: real;\n\n   procedure Alpha(a : integer);\n      var y : integer;\n   begin\n      x := a + x + y;\n   end;\n\nbegin { Main }\n\nend.  { Main }\n")),(0,r.kt)("p",null,"and turn it into the following Pascal-like program:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"program Main0;\n   var x1 : REAL;\n   var y1 : REAL;\n   procedure Alpha1(a2 : INTEGER);\n      var y2 : INTEGER;\n\n   begin\n      <x1:REAL> := <a2:INTEGER> + <x1:REAL> + <y2:INTEGER>;\n   end; {END OF Alpha}\n\nbegin\n\nend. {END OF Main}\n")),(0,r.kt)("p",null,"Here is the list of modifications our source-to-source compiler should make to an input Pascal program:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Every declaration should be printed on a separate line, so if we have multiple declarations in the input Pascal program, the compiled output should have each declaration on a separate line. We can see in the text above, for example, how the ",(0,r.kt)("em",{parentName:"p"},"line var x, y : real;")," gets converted into multiple lines.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Every name should get subscripted with a number corresponding to the scope level of the respective declaration.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Every variable reference, in addition to being subscripted, should also be printed in the following form: ",(0,r.kt)("inlineCode",{parentName:"p"},"<var_name_with_subscript:type>"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The compiler should also add a comment at the end of every block in the form ",(0,r.kt)("inlineCode",{parentName:"p"},"{END OF \u2026 }"),", where the ellipses will get substituted either with a program name or procedure name. That will help us identify the textual boundaries of procedures faster."))),(0,r.kt)("p",null,"As you can see from the generated output above, this source-to-source compiler could be a useful tool for understanding how name resolution works, especially when a program has nested scopes, because the output generated by the compiler would allow us to quickly see to what declaration and in what scope a certain variable reference resolves to. This is good help when learning about symbols, nested scopes, and name resolution."),(0,r.kt)("p",null,"All we need to do now is extend the semantic analyzer a bit to generate the enhanced output. You can see the full source code of the compiler ",(0,r.kt)("a",{target:"_blank",href:a(68323).Z},"here"),". It is basically a semantic analyzer on drugs, modified to generate and return strings for certain AST nodes."),(0,r.kt)("p",null,"For the following program, for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"program Main;\n   var x, y : real;\n   var z : integer;\n\n   procedure AlphaA(a : integer);\n      var y : integer;\n   begin { AlphaA }\n      x := a + x + y;\n   end;  { AlphaA }\n\n   procedure AlphaB(a : integer);\n      var b : integer;\n   begin { AlphaB }\n   end;  { AlphaB }\n\nbegin { Main }\nend.  { Main }\n")),(0,r.kt)("p",null,"The compiler generates the following output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"program Main0;\n   var x1 : REAL;\n   var y1 : REAL;\n   var z1 : INTEGER;\n   procedure AlphaA1(a2 : INTEGER);\n      var y2 : INTEGER;\n\n   begin\n      <x1:REAL> := <a2:INTEGER> + <x1:REAL> + <y2:INTEGER>;\n   end; {END OF AlphaA}\n   procedure AlphaB1(a2 : INTEGER);\n      var b2 : INTEGER;\n\n   begin\n\n   end; {END OF AlphaB}\n\nbegin\n\nend. {END OF Main}\n")),(0,r.kt)("p",null,"In the next article we\u2019ll learn about runtime, call stack, implement procedure calls, and write our first version of a recursive factorial function. Stay tuned and see you soon! ",(0,r.kt)("a",{parentName:"p",href:"https://ruslanspivak.com/lsbasi-part14/"},"However, there is no next yet"),"."),(0,r.kt)("h2",{id:"quick-reference"},"Quick Reference"))}m.isMDXComponent=!0},68323:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/files/src2src-compiler-bcce06c16deae0273d4a30d318cb2978.py"}}]);