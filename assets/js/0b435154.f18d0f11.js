"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5331],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(a),m=i,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||r;return a?n.createElement(h,s(s({ref:t},p),{},{components:a})):n.createElement(h,s({ref:t},p))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,s=new Array(r);s[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[d]="string"==typeof e?e:i,s[1]=o;for(var c=2;c<r;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},74921:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var n=a(87462),i=(a(67294),a(3905));const r={title:"Distributed Tracing",categories:["infrastructure","opentracinng"],tags:["opentracing","microservice"]},s=void 0,o={permalink:"/blog/2021/03/21/distributed-tracing",source:"@site/blog/2021-03-21-distributed-tracing.md",title:"Distributed Tracing",description:"Microservice provides a powerful architecture, but not without its own challenges, especially with regard to debugging and observing distributed transactions across complex networks \u2014 simply because there are no in-memory calls or stack traces to do so.",date:"2021-03-21T00:00:00.000Z",formattedDate:"March 21, 2021",tags:[{label:"opentracing",permalink:"/blog/tags/opentracing"},{label:"microservice",permalink:"/blog/tags/microservice"}],readingTime:24.59,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Distributed Tracing",categories:["infrastructure","opentracinng"],tags:["opentracing","microservice"]},prevItem:{title:"TypeScript handbook",permalink:"/blog/2021/03/27/ts-handbook"},nextItem:{title:"\u6587\u4ef6\u7cfb\u7edf\u672d\u8bb0",permalink:"/blog/2021/02/03/file-system"}},l={authorsImageUrls:[]},c=[{value:"Traditional monitoring tools",id:"traditional-monitoring-tools",level:2},{value:"Metrics",id:"metrics",level:3},{value:"Logs",id:"logs",level:3},{value:"Distributed tracing",id:"distributed-tracing",level:2},{value:"Important Concepts",id:"important-concepts",level:2},{value:"Span",id:"span",level:3},{value:"Tracer",id:"tracer",level:3},{value:"Fundamentals",id:"fundamentals",level:2},{value:"Request correlation",id:"request-correlation",level:3},{value:"Anatomy of distributed tracing",id:"anatomy-of-distributed-tracing",level:3},{value:"Trace models",id:"trace-models",level:3},{value:"Clock skew adjustment",id:"clock-skew-adjustment",level:3},{value:"Styles of instrumentation",id:"styles-of-instrumentation",level:3},{value:"Instrumentation Quality Checklist",id:"instrumentation-quality-checklist",level:2},{value:"Span Status and Creation",id:"span-status-and-creation",level:3},{value:"Span Boundaries",id:"span-boundaries",level:3},{value:"Attributes",id:"attributes",level:3},{value:"Events",id:"events",level:3},{value:"Tracing in Service meshes",id:"tracing-in-service-meshes",level:2},{value:"Observability via a service mesh",id:"observability-via-a-service-mesh",level:3},{value:"Front service telemetry",id:"front-service-telemetry",level:3},{value:"Sampling trace",id:"sampling-trace",level:2},{value:"Head-based consistent sampling",id:"head-based-consistent-sampling",level:3},{value:"Tail-based consistent sampling",id:"tail-based-consistent-sampling",level:3},{value:"Architecture and deployment modes",id:"architecture-and-deployment-modes",level:2},{value:"Basic architecture: agent + collector + query service",id:"basic-architecture-agent--collector--query-service",level:3},{value:"Streaming architecture",id:"streaming-architecture",level:3},{value:"References",id:"references",level:2}],p={toc:c};function d(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Microservice provides a powerful architecture, but not without its own challenges, especially with regard to debugging and observing distributed transactions across complex networks \u2014 simply because there are no in-memory calls or stack traces to do so."),(0,i.kt)("p",null,"This is where distributed tracing comes into the picture. Distributed tracing provides a solution for describing and analyzing the cross-process transactions."),(0,i.kt)("p",null,"Distributed tracing, also called distributed request tracing, is a method used to profile and monitor applications, especially those built using a microservice architecture. Distributed tracing helps pinpoint where failures occur and what causes poor performance."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Some content extracted from ",(0,i.kt)("a",{parentName:"p",href:"https://tracing.cloudnative101.dev/docs/index.html"},"Learning Distributed Tracing 101"),", ",(0,i.kt)("a",{parentName:"p",href:"https://www.packtpub.com/product/mastering-distributed-tracing/9781788628464"},"Mastering Distributed Tracing")," and ",(0,i.kt)("a",{parentName:"p",href:"https://www.oreilly.com/library/view/distributed-tracing-in/9781492056621/"},"Distributed Tracing in Practice"),".")),(0,i.kt)("h2",{id:"traditional-monitoring-tools"},"Traditional monitoring tools"),(0,i.kt)("p",null,"Traditional monitoring tools are designed for monolith systems, observing the health and behavior of a single application instance."),(0,i.kt)("p",null,"They may be able to tell us a story about that single instance, but they know almost nothing about the distributed transaction that passed through it. These tools lack the context of the request."),(0,i.kt)("h3",{id:"metrics"},"Metrics"),(0,i.kt)("p",null,"Metrics, or stats, are numerical measures recorded by the application, such as counters, gauges, or timers."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Memory usage, CPU saturation, etc.")),(0,i.kt)("p",null,"Metrics are very cheap to collect, since numeric values can be easily aggregated to reduce the overhead of transmitting that data to the monitoring system."),(0,i.kt)("p",null,"They are also fairly accurate, which is why they are very useful for the actual monitoring (as the dictionary defines it) and alerting."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"However, by aggregating data, we are throwing away all the context we had about the individual transactions.")),(0,i.kt)("h3",{id:"logs"},"Logs"),(0,i.kt)("p",null,"Logging is an even more basic observability tool than metrics."),(0,i.kt)("p",null,"Logs struggle with microservices because each log stream only tells us about a single instance of a service."),(0,i.kt)("p",null,"However, when it comes to the concurrency and asynchronous programming, logs become more complex."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Evolution of concurrency",src:a(4826).Z,width:"1168",height:"732"})),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf"},"Image Original Address")," at page 4."),(0,i.kt)("p",null,"Observing the behavior of such a system from the logs is very difficult, unless we annotate all logs with some kind of unique id representing the request rather than the thread, a technique (something like tracing logs across threads) that actually gets us close to how distributed tracing (tracing services across networks) works."),(0,i.kt)("h2",{id:"distributed-tracing"},"Distributed tracing"),(0,i.kt)("p",null,"Distributed tracing takes a request-centric view. It captures the detailed execution of causally-related activities performed by the components of a distributed system as it processes a given request."),(0,i.kt)("p",null,"Distributed tracing works in a nutshell just like:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Tracing infrastructure attaches contextual metadata to each request and ensures that metadata is passed around during the request execution, even when one component communicates with another over a network.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"At various trace points in the code, the instrumentation records events annotated with relevant information, such as the URL of an HTTP request or an SQL statement of a database query.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Recorded events are tagged with the contextual metadata and explicit causality references to prior events."))),(0,i.kt)("p",null,"That deceptively simple technique allows the tracing infrastructure to ",(0,i.kt)("strong",{parentName:"p"},"reconstruct the whole path of the request"),", ",(0,i.kt)("em",{parentName:"p"},"through the components of a distributed system"),", ",(0,i.kt)("em",{parentName:"p"},"as a graph of events and causal edges between them"),", which we call a ",(0,i.kt)("strong",{parentName:"p"},"trace"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"A trace allows us to reason about how the system was processing the request."),(0,i.kt)("p",{parentName:"blockquote"},"By taking a request-centric view, tracing helps to illuminate different behaviors of the system.")),(0,i.kt)("h2",{id:"important-concepts"},"Important Concepts"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Opentrace Data model")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/opentracing/specification/blob/master/specification.md#the-opentracing-data-model"},"The OpenTracing Semantic Specification #data model")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# Causal relationships between Spans in a single Trace\n[Span A]  \u2190\u2190\u2190(the root span)\n            |\n     +------+------+\n     |             |\n [Span B]      [Span C] \u2190\u2190\u2190(Span C is a `ChildOf` Span A)\n     |             |\n [Span D]      +---+-------+\n               |           |\n           [Span E]    [Span F] >>> [Span G] >>> [Span H]\n                                       \u2191\n                                       \u2191\n                                       \u2191\n                         (Span G `FollowsFrom` Span F)\n\n# Temporal relationships between Spans in a single Trace\n\u2013\u2013|\u2013\u2013\u2013\u2013\u2013\u2013\u2013|\u2013\u2013\u2013\u2013\u2013\u2013\u2013|\u2013\u2013\u2013\u2013\u2013\u2013\u2013|\u2013\u2013\u2013\u2013\u2013\u2013\u2013|\u2013\u2013\u2013\u2013\u2013\u2013\u2013|\u2013\u2013\u2013\u2013\u2013\u2013\u2013|\u2013\u2013\u2013\u2013\u2013\u2013\u2013|\u2013> time\n\n [Span A\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7]\n   [Span B\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7]\n      [Span D\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7]\n    [Span C\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7\xb7]\n         [Span E\xb7\xb7\xb7\xb7\xb7\xb7\xb7]        [Span F\xb7\xb7] [Span G\xb7\xb7] [Span H\xb7\xb7]\n\n\n")),(0,i.kt)("h3",{id:"span"},"Span"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/opentracing/specification/blob/master/specification.md#span"},"Specification on Span")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"operation name"),(0,i.kt)("li",{parentName:"ul"},"start timestamp and end timestamp"),(0,i.kt)("li",{parentName:"ul"},"Tags"),(0,i.kt)("li",{parentName:"ul"},"Logs"),(0,i.kt)("li",{parentName:"ul"},"SpanContext",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Span ID"),(0,i.kt)("li",{parentName:"ul"},"Trace ID"),(0,i.kt)("li",{parentName:"ul"},"BaggageItems(key-value pairs)")))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"What is the difference between a span ",(0,i.kt)("em",{parentName:"strong"},"tag")," and a span ",(0,i.kt)("em",{parentName:"strong"},"log"),"?")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"They are both annotating the span with some contextual information."),(0,i.kt)("li",{parentName:"ul"},"Tags typically apply to the whole span, while logs represent some events that happened during the span execution."),(0,i.kt)("li",{parentName:"ul"},"A log always has a timestamp that falls within the span's start-end time interval. (The tracing system does not explicitly track causality between logged events the way it keeps tracks of causality relationships between spans, because it can be inferred from the timestamps.)")),(0,i.kt)("p",null,"The OpenTracing Specification defines semantic data conventions that prescribe certain well-known tag names and log fields for common scenarios. Instrumentation is encouraged to use those names to ensure that the data reported to the tracing system is well-defined and portable across different tracing backends."),(0,i.kt)("h3",{id:"tracer"},"Tracer"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/opentracing/specification/blob/master/specification.md#tracer"},"Specification on Tracer")),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"Tracer")," is the actual implementation that will record the ",(0,i.kt)("inlineCode",{parentName:"p"},"Spans")," and publish them somewhere."),(0,i.kt)("p",null,"Once a ",(0,i.kt)("inlineCode",{parentName:"p"},"Tracer")," instance is obtained, it can be used to manually create ",(0,i.kt)("inlineCode",{parentName:"p"},"Span"),", or pass it to existing instrumentation for frameworks and libraries."),(0,i.kt)("h2",{id:"fundamentals"},"Fundamentals"),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(10231).Z,width:"1402",height:"736"})),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf"},"Image Original Address")," at page 16."),(0,i.kt)("h3",{id:"request-correlation"},"Request correlation"),(0,i.kt)("p",null,"The basic concept of distributed tracing appears to be very straightforward:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Instrumentation is inserted into chosen points of the program's code (trace points) and produces profiling data when executed"),(0,i.kt)("li",{parentName:"ul"},"The profiling data is collected in a central location, correlated to the specific execution (request), arranged in the causality order, and combined into a trace that can be visualized or further analyzed")),(0,i.kt)("p",null,"There are three most common approaches: black-box inference, domain-specific schemas, and metadata propagation."),(0,i.kt)("p",null,"The instrumentation trace points could annotate the data they produce with a global identifier ",(0,i.kt)("em",{parentName:"p"},"execution identifier")," that is unique for each traced request."),(0,i.kt)("p",null,"Then the tracing infrastructure receiving the annotated profiling data could easily reconstruct the full execution of the request, by grouping the records by the execution identifier."),(0,i.kt)("p",null,"The global execution identifier needs to be passed along the execution flow. This is achieved via a process known as ",(0,i.kt)("em",{parentName:"p"},"metadata propagation")," or ",(0,i.kt)("em",{parentName:"p"},"distributed context propagation"),"."),(0,i.kt)("p",null,"Metadata propagation in a distributed system consists of two parts: ",(0,i.kt)("em",{parentName:"p"},"in-process propagation")," and ",(0,i.kt)("em",{parentName:"p"},"inter-process propagation"),"."),(0,i.kt)("p",null,"In-process propagation is responsible for making the metadata available to trace points inside a given program. It needs to be able to carry the context between the inbound and outbound network calls, dealing with possible thread switches or asynchronous behavior, which are common in modern applications."),(0,i.kt)("p",null,"Inter-process propagation is responsible for transferring metadata over network calls when components of a distributed system communicate to each other during the execution of a given request.Inter-process propagation is typically done by decorating communication frameworks with special tracing middleware that encodes metadata in the network messages, for example, in HTTP headers, Kafka records headers, and so on."),(0,i.kt)("p",null,"The key disadvantage of metadata propagation-based tracing is the expectation of a white-box system whose components can be modified accordingly. And, it is more scalable and provides much higher accuracy of the data compared to black-box techniques."),(0,i.kt)("h3",{id:"anatomy-of-distributed-tracing"},"Anatomy of distributed tracing"),(0,i.kt)("p",null,"The following diagram shows a typical organization of distributed tracing systems, built around metadata propagation."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Anatomy of distributed tracing",src:a(67157).Z,width:"1404",height:"796"})),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf"},"Image Original Address")," at page 17."),(0,i.kt)("p",null,"Special trace points at the edges of the microservice, which we can call ",(0,i.kt)("em",{parentName:"p"},"inject trace points")," and ",(0,i.kt)("em",{parentName:"p"},"extract trace points"),", are also responsible for encoding and decoding metadata for passing it across process boundaries."),(0,i.kt)("p",null,"The Tracing API is implemented by a concrete tracing library that reports the collected data to the tracing backend, usually with some in-memory batching to reduce the communications overhead."),(0,i.kt)("p",null,"Reporting is always done asynchronously in the background, off the critical path of the business requests. The tracing backend receives the tracing data, normalizes it to a common trace model representation, and puts it in a persistent trace storage."),(0,i.kt)("p",null,"Because tracing data for a single request usually arrives from many hosts, the trace storage is often organized to store individual pieces incrementally, indexed by the execution identifier. This allows for later reconstruction of the whole trace for the purpose of visualization, or additional processing through aggregations and data mining."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Preserving causality")),(0,i.kt)("p",null,"Tracing systems need to capture causality that allows assembling the data captured by the trace points in the correct sequence."),(0,i.kt)("p",null,"Most tracing systems elect to preserve Lamport's happens-before relation, denoted as ",(0,i.kt)("inlineCode",{parentName:"p"},"\u2192")," and formally defined as the least strict partial order on events, such that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If events ",(0,i.kt)("inlineCode",{parentName:"li"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"b")," occur in the same process, then ",(0,i.kt)("inlineCode",{parentName:"li"},"a \u2192 b")," if the occurrence of event ",(0,i.kt)("inlineCode",{parentName:"li"},"a")," preceded the occurrence of event ",(0,i.kt)("inlineCode",{parentName:"li"},"b")),(0,i.kt)("li",{parentName:"ul"},"If event ",(0,i.kt)("inlineCode",{parentName:"li"},"a")," is the sending of a message and event ",(0,i.kt)("inlineCode",{parentName:"li"},"b")," is the reception of the message sent in event ",(0,i.kt)("inlineCode",{parentName:"li"},"a"),", then ",(0,i.kt)("inlineCode",{parentName:"li"},"a \u2192 b"))),(0,i.kt)("p",null,"Most of today's industrial-grade tracing infrastructures use ",(0,i.kt)("strong",{parentName:"p"},"dynamic metadata"),", which can be fixed-width or variable-width."),(0,i.kt)("p",null,"Most tracing systems use ",(0,i.kt)("strong",{parentName:"p"},"fixed-width dynamic metadata"),", where, in addition to the execution identifier, they record a unique ID (for example, a random 64-bit value) of the event captured by the trace point. When the next trace point is executed, it stores the inbound event ID as part of its tracing data, and replaces it with its own ID."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Causality using id or trace segment",src:a(62592).Z,width:"1340",height:"890"})),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf"},"Image Original Address")," at page 18."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Propagating Context")),(0,i.kt)("p",null,"In order to create traces, we will need some way to communicate certain details about our spans to other services or other parts of our process. The mechanism by which we communicate these details to other services is generally known as ",(0,i.kt)("em",{parentName:"p"},"context propagation"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Interprocess propagation")),(0,i.kt)("p",null,"In distributed RPCs, it\u2019s popular to send the trace context between services in an HTTP header, and have the child service create a span with a defined parent-child relationship."),(0,i.kt)("p",null,"We\u2019re ",(0,i.kt)("em",{parentName:"p"},"injecting")," the span context into the transport, and ",(0,i.kt)("em",{parentName:"p"},"extracting")," it back out."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"These inject and extract operations happen at the edge of the service in code\u2014you\u2019d generally want to use some sort of middleware in the HTTP service that would automatically perform these operations when a new request is created or received.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Intraprocess propagation")),(0,i.kt)("p",null,"We can create parent-child relations between spans using a span context. An easy way to do it through a mechanism known as a ",(0,i.kt)("em",{parentName:"p"},"scope manager"),"."),(0,i.kt)("h3",{id:"trace-models"},"Trace models"),(0,i.kt)("p",null,"The purpose of the ",(0,i.kt)("em",{parentName:"p"},"Collection/Normalization")," component is to receive tracing data from the trace points in the applications and convert it to some normalized ",(0,i.kt)("em",{parentName:"p"},"trace model"),", before saving it in the trace storage."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Event model")),(0,i.kt)("p",null,'The following diagram illustrates an event graph observed from the execution of an RPC request/response by a client-server application. It includes events collected at different layers of the stack, from application-level events (for example, "client send" and "server receive") to events in the TCP/IP stack.'),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Trace representation of an RPC request in the event model",src:a(79555).Z,width:"1258",height:"660"})),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf"},"Image Original Address")," at page 19."),(0,i.kt)("p",null,"Event model is useful for describing what happened, but they don't directly lead to actionable data."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Span model")),(0,i.kt)("p",null,"Span model is a simplified trace model."),(0,i.kt)("p",null,"The traces are represented as trees, where tree nodes are basic units of work referred to as spans. The edges in the tree indicate causal relationships between a span and its parent span."),(0,i.kt)("p",null,"Each span is a simple log of timestamped records, including its start and end time, a human-readable operation name, and zero or more intermediary application-specific annotations in the form of (timestamp, description) pairs, which are equivalent to the info events in the previous example."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Trace representation of an RPC request in the event model",src:a(19604).Z,width:"1252",height:"474"})),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf"},"Image Original Address")," at page 21."),(0,i.kt)("p",null,"Each span is assigned a unique ID (for example, a random 64-bit value), which is propagated via metadata along with the execution ID. When a new span is started, it records the ID of the previous span as its ",(0,i.kt)("em",{parentName:"p"},"parent ID"),", thus capturing the causality."),(0,i.kt)("p",null,"Effectively, traces in this model look like distributed stack traces, a concept very intuitive to all developers."),(0,i.kt)("h3",{id:"clock-skew-adjustment"},"Clock skew adjustment"),(0,i.kt)("p",null,"Clearly, we cannot trust the timestamps to be actually correct, but this is not what we often look for when we analyze distributed traces."),(0,i.kt)("p",null,"It is more important that timestamps in the trace are correctly aligned relative to each other."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When the timestamps are from the same process, such as the start of the ",(0,i.kt)("inlineCode",{parentName:"p"},"server")," span and the extra info annotations in the following diagram, we can assume that their relative positions are correct.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The timestamps from different processes on the same host are generally incomparable because even though they are not subject to the hardware clock skew, the accuracy of the timestamps depends on many other factors, such as what programming language is used for a given process and what time libraries it is using and how.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In the end, the clock skew adjustment process is always heuristic, since we typically don't have other reliable signals to calculate it precisely."))),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Clock skew adjustment",src:a(38350).Z,width:"1256",height:"704"})),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"\u03b4",(0,i.kt)("sub",null,"1")," or \u03b4",(0,i.kt)("sub",null,"2")," are just estimated;")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf"},"Image Original Address")," at page 21."),(0,i.kt)("h3",{id:"styles-of-instrumentation"},"Styles of instrumentation"),(0,i.kt)("p",null,"In a microservices-based application, most instrumentation trace points occur next to process boundaries, where the communications are performed by the means of some frameworks, such as RPC libraries."),(0,i.kt)("p",null,"If we instrument the frameworks, we need to do it only once and then reuse that instrumentation across the application. This means is usually reserved for special cases where some unique application logic warrants it to monitor access to some custom shared resource."),(0,i.kt)("p",null,"Another style of instrumentation commonly referred to as ",(0,i.kt)("em",{parentName:"p"},"agent-based"),", which promises automatic, zero-touch instrumentation of the applications."),(0,i.kt)("p",null,"In dynamic languages, like Python and JavaScript, it is often done through a technique known as ",(0,i.kt)("em",{parentName:"p"},"monkey-patching"),", which involves dynamic modification of classes or modules at runtime, transparently to the application. The tracing instrumentation agent might replace that function with a wrapper that would create a client-side tracing span, invoke the original function, and then finish the span, annotated with the results of the request, such as the HTTP status code."),(0,i.kt)("p",null,"In Java applications, where dynamic code modifications like that are not allowed, a similar effect is achieved though byte code manipulation."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"When frameworks are designed with extensibility in mind, adding the tracing code in the form of middleware, interceptors, filters, and so on is generally very straightforward.")),(0,i.kt)("h2",{id:"instrumentation-quality-checklist"},"Instrumentation Quality Checklist"),(0,i.kt)("p",null,"When instrumenting an existing service or creating guidelines on how to instrument new services, it can be useful to have a checklist of items that are important to ensuring quality instrumentation throughout the entire application."),(0,i.kt)("h3",{id:"span-status-and-creation"},"Span Status and Creation"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"All error conditions under a given span appropriately set the span status to an error state."),(0,i.kt)("li",{parentName:"ul"},"RPC framework result codes are mapped to span status (i.e., Internal Error, Not Found, etc.)."),(0,i.kt)("li",{parentName:"ul"},"All spans that are started are also finished, even in the case of unrecoverable errors if possible."),(0,i.kt)("li",{parentName:"ul"},"Spans should only represent work that is semantically important to the request life cycle of a service; try not to create spans around endpoints only receiving synthetic traffic, like a /status or /health endpoint.")),(0,i.kt)("h3",{id:"span-boundaries"},"Span Boundaries"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Egress and ingress spans have appropriate labels (SpanKind is set)."),(0,i.kt)("li",{parentName:"ul"},"Egress and ingress spans have appropriate relationships (client/server, consumer/producer)."),(0,i.kt)("li",{parentName:"ul"},"Internal spans are appropriately labeled and do not imply a remote call.")),(0,i.kt)("h3",{id:"attributes"},"Attributes"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Spans include a version attribute for the service they represent."),(0,i.kt)("li",{parentName:"ul"},"Spans that represent work by a dependency have an attribute for that dependency's version."),(0,i.kt)("li",{parentName:"ul"},"Spans should include attributes identifying underlying infrastructure:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Hostname / FQDN"),(0,i.kt)("li",{parentName:"ul"},"Container name, if appropriate"),(0,i.kt)("li",{parentName:"ul"},"Runtime version"),(0,i.kt)("li",{parentName:"ul"},"Application server version, if applicable"),(0,i.kt)("li",{parentName:"ul"},"Region or availability zone"))),(0,i.kt)("li",{parentName:"ul"},"Attributes are namespaced where appropriate (i.e., to prevent collisions between key names where the semantic meaning of the key differs between services in a request)."),(0,i.kt)("li",{parentName:"ul"},"Attributes with numerical values should include the unit of measurement in the key name (i.e, payload_size_kb versus payload_size)."),(0,i.kt)("li",{parentName:"ul"},"Attributes should not contain any PII.")),(0,i.kt)("h3",{id:"events"},"Events"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Useful and descriptive event messages that would be useful for upstream or downstream service users should be added:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Request-response payloads (sanitized)"),(0,i.kt)("li",{parentName:"ul"},"Stack traces, exceptions, and error messages"))),(0,i.kt)("li",{parentName:"ul"},"Long-running operations (such as waiting for a mutex) should be wrapped in events; one when the operation begins, and one when it ends.")),(0,i.kt)("h2",{id:"tracing-in-service-meshes"},"Tracing in Service meshes"),(0,i.kt)("p",null,"The pattern of consolidating inter-service communication functionality into a reusable component is not new."),(0,i.kt)("p",null,"There was a fairly popular style, called Enterprise Service Bus, dating back to early 2000s:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Route messages between services"),(0,i.kt)("li",{parentName:"ul"},"Monitor and control routing of message exchange between services"),(0,i.kt)("li",{parentName:"ul"},"Resolve contention between communicating service components"),(0,i.kt)("li",{parentName:"ul"},"Control deployment and versioning of services"),(0,i.kt)("li",{parentName:"ul"},"Marshal use of redundant services"),(0,i.kt)("li",{parentName:"ul"},"Provide commodity services like event handling, data transformation and mapping, message and event queuing and sequencing, security or exception handling, protocol conversion, and enforcing proper quality of communication services")),(0,i.kt)("p",null,"Often, the real implementation is something like central layer or hub through which all the inter-service communications were proxyed."),(0,i.kt)("p",null,"Recently, a new architectural pattern known as a ",(0,i.kt)("strong",{parentName:"p"},"sidecar")," hash merged:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A sidecar can be implemented in its own language, independent of the main application."),(0,i.kt)("li",{parentName:"ul"},"A sidecar is collocated with the main application, so there is no significant latency between them (but a small latency does exist)."),(0,i.kt)("li",{parentName:"ul"},"Each sidecar handles just a single instance of a single service, so a misbehaving sidecar process may affect the health of that instance but will not affect the rest of the application (although a bad global configuration change may theoretically affect all sidecars at once)."),(0,i.kt)("li",{parentName:"ul"},"A sidecar acts as an extension mechanism for the main application, even if the application itself provides no extension capabilities. For example, a third-party application may not expose any monitoring signals, but a sidecar can compensate for that."),(0,i.kt)("li",{parentName:"ul"},"A sidecar's life cycle and identity are tied to the main application's life cycle and identity, which allows the sidecar to take on such duties as authentication and transport-level security.")),(0,i.kt)("p",null,"The term ",(0,i.kt)("em",{parentName:"p"},"service mesh")," often refers to the use of the sidecar pattern to provide the infrastructure for microservices communications."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"A ",(0,i.kt)("em",{parentName:"p"},"service mesh")," is a configurable infrastructure layer designed to support interprocess communication among services. It performs this through ",(0,i.kt)("em",{parentName:"p"},"sidercar proxies"),", processes that live along-side each service instance and handle all interprocess communication for their associated service."),(0,i.kt)("p",{parentName:"blockquote"},"In addition to service communications, the service mesh and its sidecars can handle monitoring, security, service discovery, load balancing, encryption, and more."),(0,i.kt)("p",{parentName:"blockquote"},"In essence, service mesh instrumentation is agnostic to the transport layer of each service. As long as the traffic is being passed through the sidecar, it will be traced.")),(0,i.kt)("p",null,"Service mesh platforms typically provide two separate components, the ",(0,i.kt)("em",{parentName:"p"},"data plane")," and the ",(0,i.kt)("em",{parentName:"p"},"control plane"),"."),(0,i.kt)("p",null,"The job of data plane is to translate, forward, and observe every network packet that goes in and out of the service instance. Examples of network proxies that can be used as a service mesh data plane include Envoy, Linkerd, NGINX, HAProxy, and Traefik."),(0,i.kt)("p",null,"The control plane decides how the data plane should perform its tasks. It provides policy and configuration for all the network proxies (data plane) that run in a service mesh."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The control plane in charge of these decisions, such as:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"how does the proxy know where to find service X on the network?"),(0,i.kt)("li",{parentName:"ul"},"Where does it get the configuration parameters for load balancing, timeouts, and circuit breaking?"),(0,i.kt)("li",{parentName:"ul"},"Who configures the authentication and authorization settings?"))),(0,i.kt)("h3",{id:"observability-via-a-service-mesh"},"Observability via a service mesh"),(0,i.kt)("p",null,"If we place a service mesh in the path of every network request between the services in an application, it makes it an ideal place to collect consistent, standardized telemetry about the application."),(0,i.kt)("p",null,"This standardized observability alone may be enough to compensate for a small performance loss introduced by going through a proxy for every request because it dramatically enhances the operational properties of the system, making it easier to monitor and troubleshoot."),(0,i.kt)("h3",{id:"front-service-telemetry"},"Front service telemetry"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"                  |              |\n                  |     WAN      |\n                  |              |\n                  |              |\n+----------+      |  trace data  |      +---------------------+\n|          +--------------------------\x3e |   Tracing backend   |\n|  Client  |      |              |      +---------------------+\n|          +-------------+       |\n+----------+      |      |       |\n                  |   app data   |      +---------------------+\n                  |      +------------\x3e |   Service backend   |\n                  |              |      +---------------------+\n                  |              |\n                  |              |\n                  |              |\n                  |              |      +---------------------+\n                  |              |      |   Tracing backend   |\n                  |              |      +---+-----------------+\n                  |              |          ^\n                  |              |          |  synthesized span\n+----------+      |              |          |\n|          |      |  App data    |      +---+-----------------+\n|  Client  +--------------------------\x3e |   Service backend   |\n|          |      |  Timing info |      +---------------------+\n+----------+      |              |\n                  |              |\n                  |              |\n                  |              |\n                  |              |\n                  |              |  +---+\n                  |              |  |   |\n+----------+      |  trace data  |  |   |      +---------------------+\n|          +------------------------+ P +----\x3e |   Tracing backend   |\n|  Client  |      |              |  | r |      +---------------------+\n|          +-------------+       |  | o |\n+----------+      |      |       |  | x |\n                  |   app data   |  | y |      +---------------------+\n                  |      +----------+   +----\x3e |   Service backend   |\n                  |              |  |   |      +---------------------+\n                  |              |  |   |\n                  |              |  +---+\n                  |              |\n")),(0,i.kt)("h2",{id:"sampling-trace"},"Sampling trace"),(0,i.kt)("p",null,"While the impact on the application is small, the cost of processing and storing trace data can be large."),(0,i.kt)("p",null,"The value of traces is often in the details they provide, whether following requests across services or in the tags and events associated with spans."),(0,i.kt)("p",null,"A trace can become much larger than the request and response that it describes, so storing every trace would be expensive from an infrastructure point of view."),(0,i.kt)("p",null,"However, not all trace data offers the same value. Traces representing slow or failed requests may offer a lot more value."),(0,i.kt)("p",null,"Most tracing systems employ various forms of sampling to capture only a certain portion of the observed traces to reduce impact caused by tracing on the application's latency and throughput."),(0,i.kt)("p",null,"Most of the sampling methods share a common characteristic of trying to make a sampling decision at the level of the whole trace, not its individual spans. This is often referred to as ",(0,i.kt)("em",{parentName:"p"},"consistent")," or ",(0,i.kt)("em",{parentName:"p"},"coherent")," sampling."),(0,i.kt)("h3",{id:"head-based-consistent-sampling"},"Head-based consistent sampling"),(0,i.kt)("p",null,"Head-based consistent sampling, also known as upfront sampling, makes the sampling decision once per trace at the beginning of the trace. This sampling scheme is consistent because it ensures that either all spans of a given trace are captured by the tracing system or none of them are."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The decision is usually made by the tracing libraries running inside the application, because consulting the tracing backend at the point of creating the first span would put the tracing infrastructure onto the critical path of the business requests, which is highly undesirable for performance and reliability reasons.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Probabilistic sampling")),(0,i.kt)("p",null,"In probabilistic sampling, the sampling decision is made based on a coin toss with a certain probability."),(0,i.kt)("p",null,"Probabilistic samplers are by far the most popular in the tracing systems using head-based sampling."),(0,i.kt)("details",null,(0,i.kt)("summary",null," pseudo code "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"class ProbabilisticSampler(probability: Double) {\n  def isSampled: Boolean = {\n    if (Math.random() < probability) {\n      return true\n    } else {\n      return false\n    }\n  }\n\n  val boundary: Double = Long.MaxValue * probability\n  def isSampled(traceId: Long): Boolean = {\n    if (traceId < boundary) {\n      return true\n    } else {\n      return false\n    }\n  }\n}\n"))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Rate limiting sampling")),(0,i.kt)("p",null,"The rate limiter ensures that only a fixed number of traces are sampled per given time interval, for example, 10 traces per second or one trace per minute."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Rate limiting sampling can be useful in microservices that have very uneven traffic patterns, because probabilistic sampling can only be configured with a single probability value, which could be too small during low-traffic periods and too large during high-traffic periods.")),(0,i.kt)("details",null,(0,i.kt)("summary",null," pseudo code "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"class RateLimiter(creditsPerSecond: Double, maxBalance: Double) {\n  val creditsPerNanosecond = creditsPerSecond / 1e9\n  val balance: Double = 0\n  var lastTick = System.nanoTime()\n\n  def withdraw(amount: Double): Boolean = {\n    val currentTime = System.nanoTime()\n    val elapsedTime = currentTime - lastTick\n    lastTick = currentTime\n    balance += elapsedTime * creditsPerNanosecond\n    if (balance > maxBalance) {\n      balance = maxBalance\n    }\n    if (balance >= amount) {\n      balance -= amount\n      return true\n    }\n\n    return false\n  }\n}\n\nclass RateLimitSampler(tracesPerSecond: Double) {\n  val limiter = new RateLimiter(\n    creditsPerSecond=tracesPerSecond,\n    maxBalance=Math.max(tracesPerSecond, 1.0)\n  )\n\n  def isSampled: Boolean = {\n    return limiter.withdraw(1.0)\n  }\n}\n"))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Guaranteed-throughput probabilistic sampling")),(0,i.kt)("p",null,"This is a combination of a probabilistic sampler for normal operations and an additional rate limiter for low-traffic periods."),(0,i.kt)("p",null,'The rate limiter is only consulted when the probabilistic sampler decides not to sample. This ensures that a given trace point is sampled with at least a certain minimal rate, hence the name "guaranteed throughput."'),(0,i.kt)("details",null,(0,i.kt)("summary",null," pseudo code "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala"},"class GuaranteedThroughputSampler(\n  probability: Double,\n  minTracesPerSecond: Double\n) {\n  val probabilistic = new ProbabilisticSampler(probability)\n  val lowerBound = new RateLimitingSampler(minTracesPerSecond)\n\n  def isSampled: Boolean = {\n    val prob: Boolean = probabilistic.isSampled()\n    if (prob) {\n      return prob\n    }\n    val rate: Boolean = lowerBound.isSampled()\n    return rate\n  }\n}\n"))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Adaptive sampling")),(0,i.kt)("p",null,"Adaptive sampling techniques try to dynamically adjust sampling parameters throughout the architecture, based on the difference between the actual and the desired rate of trace data generation."),(0,i.kt)("p",null,"They can be implemented in two flavors, depending on whether the observations and adjustments are done locally in the tracers or globally in the tracing backend."),(0,i.kt)("p",null,"The local adaptive sampling is a way to automatically customize sampling probabilities across workloads with different traffic. The tracers are parameterized not by a fixed probability of sampling, but by a desired rate of sampled traces. Then it will automatically adjust their own sampling probability based on the number of traces they end up sampling with the current probability, trying to bring that number close to the target rate."),(0,i.kt)("p",null,"The global adaptive sampling is a way to replace a uniform sampling probability across all services with another uniform parameter for an effective sampling rate, while the actual probability is dynamically adjusted. The target effective rate is still a configuration parameter that needs to be provided to each tracer in each microservice."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Adaptive sampling in Jaeger")),(0,i.kt)("p",null,"The adaptive sampling infrastructure in the collectors calculates the desired sampling probabilities for all services and provides them back to the tracing libraries that periodically poll for that information (dashed lines)."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Adaptive sampling in Jaeger",src:a(54159).Z,width:"1412",height:"772"})),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf"},"Image Original Address")," at page 36."),(0,i.kt)("h3",{id:"tail-based-consistent-sampling"},"Tail-based consistent sampling"),(0,i.kt)("p",null,"It would be nice if we could delay the sampling decision until we see something unusual recorded in the trace, such as an abnormal request latency, or an error, or a call graph branch we have not seen before."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Tail-based sampling")," addresses this problem by making the sampling call at the end of the request execution, when we have the complete trace and can make a more intelligent decision about whether it should be captured for storage or not."),(0,i.kt)("p",null,"Another interesting feature of tail-based sampling is that it almost entirely eliminates the problem of ",(0,i.kt)("em",{parentName:"p"},"oversampling")," and ",(0,i.kt)("em",{parentName:"p"},"overload of the tracing backend"),". Making the sampling decision after collecting the whole trace is equivalent to a pull model, where the tracing backend knows exactly how much data it is requesting and can easily tune it up and down."),(0,i.kt)("p",null,"In the following diagram, all spans for traces T1 and T2 are collected in the first and the second collectors respectively. In this hypothetical example, only the second trace, T2, is considered interesting and sent to the storage, while trace T1 is simply discarded to free up space for newer traces."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"hypothetical architecture for tail-based sampling",src:a(57081).Z,width:"1416",height:"880"})),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf"},"Image Original Address")," at page 38."),(0,i.kt)("h2",{id:"architecture-and-deployment-modes"},"Architecture and deployment modes"),(0,i.kt)("p",null,"Many tracing backends are themselves implemented as microservices-based distributed systems that consist of multiple horizontally-scalable components. Some of those components are optional, which allows different deployment configurations depending on the needs of your architecture."),(0,i.kt)("h3",{id:"basic-architecture-agent--collector--query-service"},"Basic architecture: agent + collector + query service"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Basic architecture of Jaeger backend deployment",src:a(24835).Z,width:"1560",height:"640"})),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf"},"Image Original Address")," at page 60."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Client"),": is the code that runs inside the business application, and is responsible for exporting the data to the tracing backend. The most common implementation is to stash the tracing data into an internal memory buffer, to move it off the critical path of the request, and then send it in batches to the tracing backend asynchronously, for example, from a separate background thread."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Agent"),": implements the sidercar design pattern by encapsulating the logic of submitting data to the collectors, including service discovery and load balancing."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Collector"),": are stateless, horizontally scalable services that perform a number of actions: receiving span data regarding its encoding and protocols, convert and normalize span data to a single internal data model, send the normalized span data to a pluggable persistent storage, and contain the adaptive sampling logic that observes all inbound span traffic and generates sampling strategies."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Query service and UI"),": a stateless component that implements a query API for searching and retrieving traces from storage."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Data mining jobs"),": perform post-processing and aggregation of the trace data, such as building the service dependency graphs or computing tracing quality scores."),(0,i.kt)("h3",{id:"streaming-architecture"},"Streaming architecture"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Streaming architecture of the Jaeger backend deployment",src:a(40744).Z,width:"1564",height:"572"})),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf"},"Image Original Address")," at page 60."),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://tracing.cloudnative101.dev/docs/index.html"},"Learning Distributed Tracing 101"),": A quick guide to distributed tracing.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://github.com/yurishkuro/opentracing-tutorial"},"Opentracing Tutorial By Yuri Shkuro"),": A collection of tutorials for the ",(0,i.kt)("a",{parentName:"p",href:"https://opentracing.io"},"OpenTracing API"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://www.packtpub.com/product/mastering-distributed-tracing/9781788628464"},"Mastering Distributed Tracing By Yuri Shkuro")," provides comprehensive coverage of the tracing field. Solve problems through code instrumentation with open standards, and learn how to profile complex systems.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://www.oreilly.com/library/view/distributed-tracing-in/9781492056621/"},"Distributed Tracing in Practice"),": With this guide, you\u2019ll learn what distributed tracing is and how to use it to understand the performance and operation of your software.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://pjw.io/articles/2018/05/08/opentracing-explanations/"},"OpenTracing \u8be6\u89e3")))),(0,i.kt)("p",null,"Many thanks to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Yuri Shkuro (",(0,i.kt)("a",{parentName:"p",href:"https://twitter.com/yurishkuro"},"@YuriShkuro"),"): Jaeger")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Ben Sigelman (",(0,i.kt)("a",{parentName:"p",href:"https://github.com/bensigelman"},"@bhs"),"): LightStep."))))}d.isMDXComponent=!0},54159:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/adaptive-sampling-in-jaeger-a2de5d62697c5f35978e8ef0dab87d90.png"},67157:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/anatomy-of-distributed-tracing-394c8f99efa86fb62039a9cb258b4d04.png"},24835:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/basic-architecture-of-jaeger-backend-deployment-9d1716c7ddeda6dcf848f8061d918b4e.png"},62592:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/causality-with-dynamic-fixed-width-metadata-4fa07ec1664134089a4124d95018a56a.png"},38350:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/clock-skew-adjustment-50868075e08f70992d57fb9cc5ea2b41.png"},79555:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/event-model-of-an-rpc-request-56b0ff98dad2a29f8550873e9ef2e76b.png"},4826:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/evolution-of-concurrency-c6dc17ee0013291e4dbb9a3a7a3d8e87.png"},57081:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/hypothetical-architecture-for-tail-based-sampling-54263904e26a4c2f3be898836e8b18aa.png"},19604:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/span-model-examples-e0d1f23611d6293abd0ef5c9a1b1c0b7.png"},40744:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/streaming-architecture-of-the-jaeger-backend-deployment-4722b95fc28b91a9ad6d65e25a18e7c2.png"},10231:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/trace-and-execution-121371be84c1865f7722ec79d9d7454a.png"}}]);