"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2721],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>d});var a=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(t),m=o,d=p["".concat(s,".").concat(m)]||p[m]||h[m]||r;return t?a.createElement(d,i(i({ref:n},u),{},{components:t})):a.createElement(d,i({ref:n},u))}));function d(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[p]="string"==typeof e?e:o,i[1]=l;for(var c=2;c<r;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},23946:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var a=t(87462),o=(t(67294),t(3905));const r={title:"Concurrency Patterns in Go",sidebar_position:4},i=void 0,l={unversionedId:"concurrency-in-go/patterns",id:"concurrency-in-go/patterns",title:"Concurrency Patterns in Go",description:"Compose these concurrency primitives properly will help to keep the program scalable and maintainable.",source:"@site/docs/concurrency-in-go/patterns.md",sourceDirName:"concurrency-in-go",slug:"/concurrency-in-go/patterns",permalink:"/docs/concurrency-in-go/patterns",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Concurrency Patterns in Go",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Concurrency Primitives",permalink:"/docs/concurrency-in-go/primitives"},next:{title:"Concurrency at Scale",permalink:"/docs/concurrency-in-go/scalability"}},s={},c=[{value:"Confinement",id:"confinement",level:2},{value:"The for-select Loop",id:"the-for-select-loop",level:2},{value:"<em>Sending iteration variables out on a channel</em>",id:"sending-iteration-variables-out-on-a-channel",level:3},{value:"<em>Looping infinitely waiting to be stopped</em>",id:"looping-infinitely-waiting-to-be-stopped",level:3},{value:"Preventing Goroutine Leaks",id:"preventing-goroutine-leaks",level:2},{value:"The or-channel",id:"the-or-channel",level:2},{value:"Error Handling in Concurrency",id:"error-handling-in-concurrency",level:2},{value:"Pipelines",id:"pipelines",level:2},{value:"Constructing Pipelines with channels",id:"constructing-pipelines-with-channels",level:3},{value:"The or-done-channel",id:"the-or-done-channel",level:3},{value:"The tee-channel",id:"the-tee-channel",level:3},{value:"The bridge-channel",id:"the-bridge-channel",level:3},{value:"Queuing",id:"queuing",level:2},{value:"The <code>context</code> Package",id:"the-context-package",level:2}],u={toc:c};function p(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Compose these concurrency primitives properly will help to keep the program scalable and maintainable."),(0,o.kt)("h2",{id:"confinement"},"Confinement"),(0,o.kt)("p",null,"When working with concurrent code, there are a few different options for safe operation. The two of them are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Synchronization primitives for sharing memory (e.g., sync.Mutex)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Synchronization via communicating (e.g., channels)"))),(0,o.kt)("p",null,"However, there are a couple of other options that are implicitly safe within multiple concurrent processes:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Immutable data")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Data protected by confinement"))),(0,o.kt)("p",null,"In some sense, immutable data is ideal because it is implicitly concurrent-safe. Each concurrent process may operate on the same data, but it may not modify it. If it wants to create new data, it must create a new copy of the data with the desired modifications. This allows not only a lighter cognitive load on the developer, but can also lead to faster programs if it leads to smaller critical sections (or eliminates them altogether). In Go, you can achieve this by writing code that utilizes copies of values instead of pointers to values in memory."),(0,o.kt)("p",null,"Confinement can also allow for a lighter cognitive load on the developer and smaller critical sections. The techniques to confine concurrent values are a bit more involved than simply passing copies of values."),(0,o.kt)("p",null,"Confinement is the simple yet powerful idea of ensuring information is only ever available from one concurrent process. When this is achieved, a concurrent program is implicitly safe and no synchronization is needed. There are two kinds of confinement possible: ",(0,o.kt)("strong",{parentName:"p"},"ad hoc")," and ",(0,o.kt)("strong",{parentName:"p"},"lexical"),"."),(0,o.kt)("p",null,"Ad hoc confinement is when you achieve confinement through a convention\u2014 whether it be set by the languages community, the group you work within, or the codebase you work within, which is difficult to sticking to unless there are some tools to perform static analysis on the code every commits."),(0,o.kt)("p",null,"Lexical confinement involves using lexical scope to expose only the correct data and concurrency primitives for multiple concurrent processes to use."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'chanOwner := func() <-chan int {\n  // instantiate a buffered channel within the lexical scoped.\n  // This confines the scope of the write aspect of the `resultStream`\n  // to prevent other goroutines from writing to it\n  resultStream := make(chan int, 5)\n\n  go func() {\n    defer close(resultStream)\n    for i := 0; i <= 5; i ++ {\n      resultStream <- i\n    }\n  }()\n  // expose read-only aspect for other goroutines\n  return resultStream\n}\n\nconsumer := func(resultStream <-chan int) {\n  // By declaring the read-only usage,\n  // confine the consumer function only read aspect of the channel\n  for result := range resultStream {\n    fmt.Printf("Received: %d\\n", result)\n  }\n  fmt.Println("Done Receiving!")\n}\n\nresultStream := chanOwner()\nconsumer(resultStream)\n')),(0,o.kt)("p",null,"Why pursue confinement if we have synchronization available to us? The answer is improved performance and reduced cognitive load on developers. Synchronization comes with a cost, and if you can avoid it you won't have any critical sections, and therefore you won't have to pay the cost of synchronizing them."),(0,o.kt)("p",null,"Concurrent code that utilizes lexical confinement also has the benefit of usually being simpler to understand than concurrent code without lexically confined variables. This is because within the context of your lexical scope you can write synchronous code."),(0,o.kt)("h2",{id:"the-for-select-loop"},"The for-select Loop"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"for { // Either loop infinitely or range over something\n  select {\n    // Do some work with channels\n  }\n}\n")),(0,o.kt)("h3",{id:"sending-iteration-variables-out-on-a-channel"},(0,o.kt)("em",{parentName:"h3"},"Sending iteration variables out on a channel")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"for _, v := range <iterator> {\n  select {\n    case <-done:\n      return\n    case stringStream <- s:\n  }\n}\n")),(0,o.kt)("h3",{id:"looping-infinitely-waiting-to-be-stopped"},(0,o.kt)("em",{parentName:"h3"},"Looping infinitely waiting to be stopped")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"for {\n  select {\n    case <-done:\n      return\n    default:\n\n  }\n  // Do non-preemptable work\n}\n// or\nfor {\n  select {\n    case <-done:\n      return\n    default:\n      // Do non-preemptable work\n  }\n}\n")),(0,o.kt)("h2",{id:"preventing-goroutine-leaks"},"Preventing Goroutine Leaks"),(0,o.kt)("p",null,"Though the Go runtime handles multiplexing the goroutines onto any number of operating system threads so that we don't often have to worry about that level of abstraction. But goroutines do cost resources, and they are not garbage collected by the runtime, so regardless of how small their memory footprint is, it's important to not to leave them lying about our process."),(0,o.kt)("p",null,"Before we go about ensuring to clean up goroutines, how a goroutine would terminate."),(0,o.kt)("p",null,"The goroutine has a few paths to termination:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"When it has completed its work.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"When it cannot continue its work due to an unrecoverable error.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"When it\u2019s told to stop working, timeout for example."))),(0,o.kt)("p",null,"The third path is something about work cancellation. Mostly, we could even represent this interconnectedness as a graph: whether or not a child goroutine should continue executing might be predicated on knowledge of the state of many other goroutines. The parent goroutine (often the main goroutine) with this full contextual knowledge should be able to tell its child goroutines to terminate."),(0,o.kt)("p",null,"The way to successfully mitigate this is to establish a signal between the parent goroutine and its children that allows the parent to signal cancellation to its children. By convention, this signal is usually a read-only channel named ",(0,o.kt)("inlineCode",{parentName:"p"},"done"),". The parent goroutine passes this channel to the child goroutine and then closes the channel when it wants to cancel the child goroutine."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'// As a convention, this `done` channel is the first parameter.\ndoWork := func(\n  done <-chan interface{},\n  strings <-chan string,\n) <-chan interface{} {\n  terminated := make(chan interface{})\n  go func() {\n    defer fmt.Println("doWork exited.")\n    defer close(terminated)\n    for {\n      select {\n      case s := <-strings:\n        // Do something interesting\n        fmt.Println(s)\n      case <-done:\n        // Once signaled, the goroutine terminates\n        return\n      }\n    }\n  }()\n  return terminated\n}\n\ndone := make(chan interface{})\nterminated := doWork(done, nil)\n\ngo func() {\n  // Cancel the operation\n  time.Sleep(1 * time.Second)\n  fmt.Println("Canceling doWork goroutine...")\n  close(done)\n}()\n\n// the join-point of goroutines spawned\n// from doWork with the main goroutine\n<-terminated\nfmt.Println("All Done.")\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'newRandStream := func(done <-chan interface{}) <-chan int {\n  randStream := make(chan int)\n  go func() {\n    defer fmt.Println("newRandStream Closure exited.")\n    defer close(randStream)\n    for {\n      select {\n      case randStream <- rand.Int():\n      case <-done:\n        return\n      }\n    }\n  }()\n  return randStream\n}\n\ndone := make(chan interface{})\nrandStream := newRandStream(done)\nfmt.Println("3 random ints:")\nfor i := 1; i <= 3; i++ {\n  fmt.Printf("%d: %d\\n", i , <-randStream)\n}\nclose(done)\ntime.Sleep(1 * time.Second)\n')),(0,o.kt)("p",null,"Now that we know how to ensure goroutines don't leak, we can stipulate a convention: ",(0,o.kt)("strong",{parentName:"p"},"If a goroutine is responsible for creating a goroutine, it is also responsible for ensuring it can stop the goroutine"),"."),(0,o.kt)("h2",{id:"the-or-channel"},"The or-channel"),(0,o.kt)("p",null,"At times, you may find yourself wanting to combine one or more ",(0,o.kt)("inlineCode",{parentName:"p"},"done")," channels into a single done channel that closes if any of its component channels close."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'var or func(channels ...<-chan interface{}) <-chan interface{}\n\n// a function takes in a variadic slice of channels\n// and returns a single channel\nor = func(channels ...<-chan interface{}) <-chan interface{} {\n  switch len(channels) {\n  case 0:\n    // set up termination criteria for recursive\n    return nil\n  case 1:\n    // the variadic slice only contains one element\n    return channels[0]\n  }\n\n  orDone := make(chan interface{})\n  // the main body of the function, and where the recursion happens\n  // use a goroutine to return the channel without blocking\n  go func() {\n    defer close(orDone)\n    switch len(channels) {\n    case 2:\n      select {\n      case <-channels[0]:\n      case <-channels[1]:\n      }\n    default:\n      select {\n      case <-channels[0]:\n      case <-channels[1]:\n      case <-channels[2]:\n      // recursively create an or-channel from\n      // all the channels in the slice after\n      // the third index.\n      // By passing in the orDone channel,\n      // so that when goroutines up the tree exit,\n      // goroutines down the tree also exit.\n      case <-or(append(channels[3:], orDone)...):\n      }\n    }\n  }()\n  return orDone\n}\n\n// a small example to use or-funtion\n// to combine channels into a single channel\nsig := func(after time.Duration) <-chan interface{} {\n  c := make(chan interface{})\n  go func() {\n    defer close(c)\n    time.Sleep(after)\n  }()\n  return c\n}\nstart := time.Now()\n<-or (\n  sig(2*time.Hour),\n  sig(5*time.Minute),\n  sig(1*time.Second),\n  sig(1*time.Hour),\n  sig(1*time.Minute),\n)\nfmt.Printf("done after %v", time.Since(start))\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"This is because\u2014despite its place in the tree the or function builds\u2014it will always close first and thus the channels that depend on its closure will close as well.")),(0,o.kt)("p",null,"This pattern is useful to employ at the intersection of modules in your system. At these intersections, you tend to have multiple conditions for canceling trees of goroutines through your call stack. Using the ",(0,o.kt)("inlineCode",{parentName:"p"},"or")," function, you can simply combine these together and pass it down the stack."),(0,o.kt)("h2",{id:"error-handling-in-concurrency"},"Error Handling in Concurrency"),(0,o.kt)("p",null,"Generally, the concurrent processes should send their errors to another part of the program that has complete information about the state of the program, and can make a more informed decision about what to do."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'type Result struct {\n  Error error\n  Response *http.Response\n}\n\ncheckStatus := func(done <-chan interface{}, urls ...string) <-chan Result {\n  results := make(chan Result)\n  go func() {\n    defer close(results)\n    for _, url := range urls {\n      var result Result\n      resp, err := http.Get(url)\n      result = Result{Error: err, Response: resp}\n      select {\n      case <-done:\n      case results <- result:\n      }\n    }\n  }()\n  return results\n}\ndone := make(chan interface{})\ndefer close(done)\n\nerrCount := 0\nurls := []string{"https://badhost", "https://cn.bing.com", "a", "b", "c"}\n\nfor result := range checkStatus(done, urls...) {\n  if result.Error != nil {\n    fmt.Printf("error: %v", result.Error)\n    errCount++\n    if errCount >= 3 {\n      fmt.Println("Too many errors, breaking!")\n      break\n    }\n    continue\n  }\n  fmt.Printf("Response: %v\\n", result.Response.Status)\n}\n')),(0,o.kt)("p",null,"The above is a good example because we've coupled the potential result with the potential error. This represents the complete set of possible outcomes created from the goroutine ",(0,o.kt)("inlineCode",{parentName:"p"},"checkStatus"),", and allows the main goroutine to make decisions about what to do when errors occur."),(0,o.kt)("p",null,"In broader terms, we\u2019ve successfully separated the concerns of error handling from our producer goroutine. This is desirable because the goroutine that spawned the producer goroutine has more context about the running program, and can make more intelligent decisions about what to do with errors."),(0,o.kt)("p",null,"Errors should be considered first-class citizens when constructing values to return from goroutines. If your goroutine can produce errors, those errors should be tightly coupled with your result type, and passed along through the same lines of communication\u2014just like regular synchronous functions."),(0,o.kt)("h2",{id:"pipelines"},"Pipelines"),(0,o.kt)("p",null,"A pipeline is just another tool you can use to form an abstraction in your system. In particular, it is a very powerful tool to use when your program needs to process streams, or batches of data. A pipeline is nothing more than a series of things that take data in, perform an operation on it, and pass the data back out. We call each of these operations a ",(0,o.kt)("em",{parentName:"p"},"stage")," of the pipeline."),(0,o.kt)("p",null,"By using a pipeline, you separate the concerns of each stage, which provides numerous benefits. You can modify stages independent of one another, you can mix and match how stages are combined independent of modifying the stages, you can process each stage concurrent to upstream or downstream stages, and you can fan-out, or rate-limit portions of your pipeline."),(0,o.kt)("p",null,"A stage is just something that takes some data in, performs a transformation on it, and sends some data back out."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"A stage consumes and returns ",(0,o.kt)("em",{parentName:"p"},"the same type"),".")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"A stage must be reified by the language so that it may be passed around. Functions in Go are reified and fit this purpose nicely."))),(0,o.kt)("p",null,"Pipeline stages are very closely related to functional programming and can be considered a subset of monads."),(0,o.kt)("p",null,"Notice how each stage is taking a slice of data and returning a slice of data? These stages are performing what we call ",(0,o.kt)("em",{parentName:"p"},"batch processing"),". This just means that they operate on chunks of data all at once instead of one discrete value at a time. There is another type of pipeline stage that performs ",(0,o.kt)("em",{parentName:"p"},"stream processing"),". This means that the stage receives and emits one element at a time."),(0,o.kt)("h3",{id:"constructing-pipelines-with-channels"},"Constructing Pipelines with channels"),(0,o.kt)("p",null,"Channels can receive and emit values, they can safely be used concurrently, they can be ranged over, and they are reified by the language."),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("p",null,"An example utilizing channels to pipeline.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"// generator converts a discrete set of values\n// into a stream of data on a channel\ngenerator := func(done <-chan interface{}, integers ...int) <-chan int {\n  intStream := make(chan int)\n  go func() {\n    defer close(intStream)\n    for _, i := range integers {\n      select {\n      case <-done:\n        // ensures the program exits cleanly\n        // and never leaks goroutines.\n        return\n      case intStream <- i:\n      }\n    }\n  }()\n  return intStream\n}\n\nmultiply := func (\n  done <-chan interface{},\n  intStream <-chan int,\n  multiplier int,\n) <-chan int {\n  multipliedStream := make(chan int)\n  go func() {\n    defer close(multipliedStream)\n    for i := range intStream {\n      select {\n      case <-done:\n        // ensures the program exits cleanly\n        // and never leaks goroutines.\n        return\n      case multipliedStream <- i * multiplier:\n      }\n    }\n  }()\n  return multipliedStream\n}\n\nadd := func (\n  done <-chan interface{},\n  intStream <-chan int,\n  additive int,\n) <-chan int {\n  addStream := make(chan int)\n  go func() {\n    defer close(addStream)\n    for i := range intStream {\n      select {\n      case <-done:\n        // ensures the program exits cleanly\n        // and never leaks goroutines.\n        return\n      case addStream <- i + multiplier:\n      }\n    }\n  }()\n  return addStream\n}\n\ndone := make(chan interface{})\ndefer close(done)\n\nintStream := generator(done, 1, 2, 4, 3)\npipeline := multiply(done, add(done, multiply(done, intStream, 2), 1), 2)\n\nfor v := range pipeline {\n  fmt.Println(v)\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"repeat := func(\n  done <-chan interface{},\n  values ...interface{},\n) <-chan interface{} {\n  valueStream := make(chan interface{})\n  go func() {\n    defer close(valueStream)\n    for {\n      for _, v := range values {\n        select {\n        case <-done: return\n        case valueStream <- v:\n        }\n      }\n    }\n  }()\n  return valueStream\n}\n\nrepeatFn := func(\n  done <-chan interface{},\n  fn func() interface{},\n) <-chan interface{} {\n  valueStream := make(chan interface{})\n  go func() {\n    defer close(valueStream)\n    for {\n      for _, v := range values {\n        select {\n        case <-done: return\n        case valueStream <- fn():\n        }\n      }\n    }\n  }()\n  return valueStream\n}\n"))),(0,o.kt)("p",null,"If one of your stages is computationally expensive, this will certainly eclipse this performance overhead. So to help mitigate this, we adopt the ",(0,o.kt)("em",{parentName:"p"},"fan-out, fan-in")," technique."),(0,o.kt)("p",null,"Sometimes, stages in the pipeline can be particularly computationally expensive. When it happens, upstream stages in the pipeline can become blocked while waiting for the expensive stages to complete."),(0,o.kt)("p",null,"It would be interesting to reuse a single stage of our pipeline on multiple goroutines in an attempt to parallelize pulls from an upstream stage"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Fan-out")," is a term to describe the process of starting multiple goroutines to handle input from the pipeline, and ",(0,o.kt)("em",{parentName:"p"},"fan-in")," is a term to describe the process of combining multiple results into one channel."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The ",(0,o.kt)("em",{parentName:"p"},"fan-out, fan-in")," technique works only when the input and output is order-independence, because there's no guarantee in what order concurrent copies of the stage will run.")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Fan-in")," means ",(0,o.kt)("em",{parentName:"p"},"multiplexing")," or joining together multiple streams of data into a single stream. The algorithm to do so is relatively simple:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"fanIn := func (\n  done <-chan interface{},\n  channels ...<-chan interface{},\n) <-chan interface{} {\n  var wg sync.WaitGroup\n  multiplexedStream := make(chan interface{})\n\n  multiplex := func (c <-chan interface{}) {\n    defer wg.Done()\n    for i := range c {\n      select {\n      case <-done:\n        return\n      case multiplexedStream <- i:\n      }\n    }\n  }\n\n  // Select from all the channels\n  wg.Add(len(channels))\n  for _, c := range channels {\n    go multiplex(c)\n  }\n\n  // Wait for all the reads to complete\n  go func() {\n    wg.Wait()\n    close(multiplexedStream)\n  }()\n\n  return multiplexedStream\n}\n")),(0,o.kt)("p",null,"In a nutshell, ",(0,o.kt)("em",{parentName:"p"},"fanning in")," involves creating one multiplexed channel consumers will read from, and then spinning up one goroutine for every incoming channel, and one goroutine to close the multiplexed channel when the incoming channels have all been closed."),(0,o.kt)("h3",{id:"the-or-done-channel"},"The or-done-channel"),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("p",null,"At times, you will be working with channels from disparate parts of your system. Unlike with pipelines, you can't make any assertions about how a channel will behave when code you\u2019re working with is canceled via its ",(0,o.kt)("inlineCode",{parentName:"p"},"done")," channel.")),(0,o.kt)("p",null,"We encapsulate the verbosity of creating or-done-channel:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"orDone := func(done, c <-chan interface{}) <-chan interface{} {\n  valStream := make(chan interface{})\n  go func() {\n    defer close(valStream)\n    for {\n      select {\n      case <-done:\n        return\n      case v, ok := <-c:\n        if ok == false {\n          return\n        }\n        select {\n        case valStream <- v:\n        case <-done:\n        }\n      }\n    }\n  }()\n  return valStream\n}\n"))),(0,o.kt)("h3",{id:"the-tee-channel"},"The tee-channel"),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("p",null,"Sometimes you may want to split values coming in from a channel so that you can send them off into two separate areas of your codebase.")),(0,o.kt)("p",null,"Taking its name from the ",(0,o.kt)("inlineCode",{parentName:"p"},"tee")," command in Unix-like systems, the ",(0,o.kt)("em",{parentName:"p"},"tee-channel")," does just this. You can pass it a channel to read from, and it will return two separate channels that will get the same value:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"tee := func (\n  done <-chan interface{},\n  in <-chan interface{},\n) (_, _ <-chan interface{}) {\n  out1 := make(chan interface{})\n  out2 := make(chan interface{})\n\n  go func() {\n    defer close(out1)\n    defer close(out2)\n    for val := range orDone(done, in) {\n      // use local versions of out1 and out2,\n      // so we shadow these variables.\n      var out1, out2 = out1, out2\n\n      // use one select statement so that\n      // writes to out1 and out2 don't block each other.\n      //  To ensure both are written to,\n      // we\u2019ll perform two iterations of the select statement:\n      // one for each outbound channel.\n      for i := 0; i < 2; i++ {\n        select {\n        case <-done:\n        case out1<-val:\n          out1 = nil\n        case out2<-val:\n          out2 = nil\n        }\n\n        // Once we\u2019ve written to a channel,\n        // we set its shadowed copy to nil\n        // so that further writes will block\n        // and the other channel may continue\n      }\n    }\n  }()\n  return out1, out2\n}\n"))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h3",{id:"the-bridge-channel"},"The bridge-channel"),(0,o.kt)("p",null,"In some circumstances, you may find yourself wanting to consume values from a sequence of channels:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"<-chan <-chan interface{}\n")),(0,o.kt)("p",null,"As a consumer, the code may not care about the fact that its values come from a sequence of channels. In that case, dealing with a channel of channels can be cumbersome. If we instead define a function that can destructure the channel of channels into a simple channel\u2014a technique called ",(0,o.kt)("em",{parentName:"p"},"bridging")," the channels\u2014this will make it much easier for the consumer to focus on the problem at hand.")),(0,o.kt)("p",null,"Here\u2019s how we can achieve that:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"bridge := func(\n  done <-chan interface{},\n  chanStream <-chan <-chan interface{},\n) <-chan interface{} {\n  // This is the bridge that will return all values\n  valStream := make(chan interface{})\n  go func() {\n    defer close(valStream)\n    // this loop is responsible for pulling\n    // channels off of chanStream and providing\n    // them to a nested loop for use\n    for {\n      var stream <-chan interface{}\n      select {\n      case maybeStream, ok := <-chanStream:\n        if ok == false {\n          return\n        }\n      case <-done:\n        return\n      }\n\n      // this loop is responsible for reading values off the channel\n      // and repeating those values onto valStream\n      for val := range orDone(done, stream) {\n        select {\n        case valStream <- val:\n        case <-done:\n        }\n      }\n    }\n  }()\n  return valStream\n}\n"))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("h2",{id:"queuing"},"Queuing"),(0,o.kt)("p",null,"Sometimes it\u2019s useful to begin accepting work for your pipeline even though the pipeline is not yet ready for more. This process is called ",(0,o.kt)("em",{parentName:"p"},"queuing"),"."),(0,o.kt)("p",null,"All this means is that once your stage has completed some work, it stores it in a temporary location in memory so that other stages can retrieve it later, and your stage doesn't need to hold a reference to it."),(0,o.kt)("p",null,"Queuing is usually one of the last techniques you want to employ when optimizing the program. Adding queuing prematurely can hide synchronization issues such as deadlocks and livelocks."),(0,o.kt)("p",null,"Queuing will almost never speed up the total runtime of your program; it will only allow the program to behave differently. The runtime of one of stages does not reduced vastly, but rather the time it's in a ",(0,o.kt)("em",{parentName:"p"},"blocking state")," is reduced. This allows the stage to continue doing its job more quickly.")),(0,o.kt)("p",null,"In this way, the true utility of queues is to ",(0,o.kt)("em",{parentName:"p"},"decouple stages")," so that the runtime of one stage has smaller impact on the runtime of another."),(0,o.kt)("p",null,"Usually anytime performing an operation requires an overhead, chunking may increase system performance. Some examples of this are opening database transactions, calculating message checksums, and allocating contiguous space. Aside from chunking, queuing can also help if your algorithm can be optimized by supporting lookbehinds, or ordering."),(0,o.kt)("p",null,"Queuing should be implemented either:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"At the entrance to the pipeline")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"In stages where batching will lead to higher efficiency"))),(0,o.kt)("p",null,"In queuing theory, there's a law that predicts the throughput of the pipeline, which is called ",(0,o.kt)("em",{parentName:"p"},"Little's Law"),"."),(0,o.kt)("p",null,"The Little's Law is commonly expressed as: ",(0,o.kt)("inlineCode",{parentName:"p"},"L=\u03bbW"),", where:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"L = the average number of units in the system."),(0,o.kt)("li",{parentName:"ul"},"\u03bb = the average arrival rate of units."),(0,o.kt)("li",{parentName:"ul"},"W = the average time a unit spends in the system.")),(0,o.kt)("p",null,"This equation only applies to so-called ",(0,o.kt)("em",{parentName:"p"},"stable")," systems. In a pipeline, a stable system is one in which the rate that work enters the pipeline, or ",(0,o.kt)("em",{parentName:"p"},"ingress"),", is equal to the rate in which it exits the system, or ",(0,o.kt)("em",{parentName:"p"},"egress"),"."),(0,o.kt)("p",null,"If the rate of ingress exceeds the rate of egress, your system is ",(0,o.kt)("em",{parentName:"p"},"unstable")," and has entered a ",(0,o.kt)("em",{parentName:"p"},"death-spiral"),". If the rate of ingress is less than the rate of egress, you still have an ",(0,o.kt)("em",{parentName:"p"},"unstable")," system, but all that\u2019s happening is that your resources aren't ",(0,o.kt)("em",{parentName:"p"},"being utilized completely"),"."),(0,o.kt)("p",null,"If we want to decrease ",(0,o.kt)("inlineCode",{parentName:"p"},"W"),", the average time a unit spends in the system by a factor of ",(0,o.kt)("inlineCode",{parentName:"p"},"n"),", we only have one option: to decrease the average number of units in the system: ",(0,o.kt)("inlineCode",{parentName:"p"},"L/n = \u03bb * W/n"),". And we can only decrease the average number of units in the system if we increase the rate of egress. Also, notice that if we add queues to our stages, we\u2019re increasing ",(0,o.kt)("inlineCode",{parentName:"p"},"L"),", which either increases the arrival rate of units (",(0,o.kt)("inlineCode",{parentName:"p"},"nL = n\u03bb * W"),") or increases the average time a unit spends in the system (",(0,o.kt)("inlineCode",{parentName:"p"},"nL = \u03bb * nW"),"). Through Little\u2019s Law, we have proven that ",(0,o.kt)("em",{parentName:"p"},"queuing will not help decrease the amount of time spent in a system"),"."),(0,o.kt)("p",null,"Also, notice that since we\u2019re observing our pipeline as a whole, reducing ",(0,o.kt)("inlineCode",{parentName:"p"},"W")," by a factor of ",(0,o.kt)("inlineCode",{parentName:"p"},"n")," is distributed throughout all stages of our pipeline. In our case, Little\u2019s Law should really be defined like this:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"L = \u03bb\u03a3iWi")),(0,o.kt)("p",null,"That\u2019s another way of saying that your pipeline will only be as fast as your slowest stage. Optimize indiscriminately!")),(0,o.kt)("h2",{id:"the-context-package"},"The ",(0,o.kt)("inlineCode",{parentName:"h2"},"context")," Package"),(0,o.kt)("p",null,"In concurrent programs, it's often necessary to preempt operations because of timeouts, cancellation, or failure of another portion of the system."),(0,o.kt)("p",null,"It would be useful if we could communicate extra information alongside the simple notification to cancel: why the cancellation is occurring, or whether the function has a deadline by which it needs to complete."),(0,o.kt)("p",null,"It turns out that the need to wrap a done channel with this information is very common in systems of any size, and so the Go authors decided to create a standard pattern for doing so, the ",(0,o.kt)("inlineCode",{parentName:"p"},"context")," package."),(0,o.kt)("p",null,"The context package serves two primary purposes:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"To provide an API for canceling branches of the call-graph")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"To provide a data-bag for transporting request-scoped data through the call-graph"))),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"context")," package helps to cancel a function in three aspects:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"A goroutine's parent may want to cancel it.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"A goroutine may want to cancel its children.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Any blocking operations within a goroutine need to be preemptable so that it may be canceled."))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"func WithCancel(parent Context) (ctx Context, cancel CancelFunc)\nfunc WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)\nfunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)\n")),(0,o.kt)("p",null,"All these functions take in a ",(0,o.kt)("inlineCode",{parentName:"p"},"Context")," and return one as well. If the function needs to cancel functions below it in the call-graph in some manner, it will call one of these functions and pass in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Context")," it was given, and then pass the ",(0,o.kt)("inlineCode",{parentName:"p"},"Context")," returned into its children. If the function doesn't need to modify the cancellation behavior, the function simply passes on the ",(0,o.kt)("inlineCode",{parentName:"p"},"Context")," it was given."),(0,o.kt)("p",null,"In this way, successive layers of the call-graph can create a ",(0,o.kt)("inlineCode",{parentName:"p"},"Context")," that adheres to their needs without affecting their parents. This provides a very composable, elegant solution for how to manage branches of your call-graph."),(0,o.kt)("p",null,"In this spirit, instances of a ",(0,o.kt)("inlineCode",{parentName:"p"},"Context")," are meant to flow through your program\u2019s call-graph. In an object-oriented paradigm, it\u2019s common to store references to often-used data as member variables, but it\u2019s important to ",(0,o.kt)("strong",{parentName:"p"},"not do this")," with instances of ",(0,o.kt)("inlineCode",{parentName:"p"},"context.Context"),". Instances of ",(0,o.kt)("inlineCode",{parentName:"p"},"context.Context")," may look equivalent from the out\u2010side, but ",(0,o.kt)("strong",{parentName:"p"},"internally they may change at every stack-frame"),". For this reason, it\u2019s important to ",(0,o.kt)("strong",{parentName:"p"},"always pass instances of ",(0,o.kt)("inlineCode",{parentName:"strong"},"Context"))," into your functions. This way functions have the Context intended for it, and not the Context intended for a stack-frame ",(0,o.kt)("inlineCode",{parentName:"p"},"N")," levels up the stack."),(0,o.kt)("p",null,"At the top of your asynchronous call-graph, your code probably won't have been passed a Context. To start the chain, the context package provides you with two functions to create empty instances of Context:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"func Background() Context\nfunc TODO() Context\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Background")," simply returns an empty ",(0,o.kt)("inlineCode",{parentName:"p"},"Context"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"TODO")," is not meant for use in production, but also returns an empty ",(0,o.kt)("inlineCode",{parentName:"p"},"Context"),"; ",(0,o.kt)("inlineCode",{parentName:"p"},"TODO"),"\u2019s intended purpose is to serve as a placeholder for when you don't know which ",(0,o.kt)("inlineCode",{parentName:"p"},"Context")," to utilize, or if you expect your code to be provided with a ",(0,o.kt)("inlineCode",{parentName:"p"},"Context"),", but the upstream code hasn't yet furnished one."),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("p",null,"An example that uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"done")," channel pattern, and another example that use the ",(0,o.kt)("inlineCode",{parentName:"p"},"context")," package.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n  var wg sync.WaitGroup\n  done := make(chan interface{})\n  defer close(done)\n\n  wg.Add(1)\n  go func() {\n    defer wg.Done()\n    if err := printGreeting(done); err != nil {\n      fmt.Printf("printGreeting result: %v\\n", err)\n      return\n    }\n  }()\n\n  wg.Add(1)\n  go func() {\n    defer wg.Done()\n    if err := printFarewell(done); err != nil {\n      fmt.Printf("printFarewell result: %v\\n", err)\n      return\n    }\n  }()\n\n  // go func() {\n  //   time.Sleep(3 * time.Second)\n  //   done <- 1\n  //   time.Sleep(3 * time.Second)\n  //   done <- 1\n  // }()\n\n  // go func() {\n  //   time.Sleep(3 * time.Second)\n  //   close(done)\n  // }()\n\n  wg.Wait()\n}\n\nfunc printFarewell(done <-chan interface{}) error {\n  farewell, err := genFarewell(done)\n  if err != nil {\n    return err\n  }\n  fmt.Printf("%s world!\\n", farewell)\n  return nil\n}\n\nfunc genFarewell(done <-chan interface{}) (string, error) {\n  switch locale, err := locale(done); {\n  case err != nil:\n    return "", err\n  case locale == "EN/US":\n    return "goodbye", nil\n  }\n  return "", fmt.Errorf("unsupported locale")\n}\n\nfunc printGreeting(done <-chan interface{}) error {\n  greeting, err := genGreeting(done)\n  if err != nil {\n    return err\n  }\n  fmt.Printf("%s world!\\n", greeting)\n  return nil\n}\n\nfunc genGreeting(done <-chan interface{}) (string, error) {\n  switch locale, err := locale(done); {\n  case err != nil:\n    return "", err\n  case locale == "EN/US":\n    return "hello", nil\n  }\n  return "", fmt.Errorf("unsupported locale")\n}\n\nfunc locale(done <-chan interface{}) (string, error) {\n  select {\n  case <-done:\n    return "", fmt.Errorf("locale canceled")\n  case <-time.After(15 * time.Second):\n  }\n  return "EN/US", nil\n}\n')),(0,o.kt)("p",null,"We\u2019ve set up the standard preemption method by creating a done channel and passing it down through our call-graph. If we close the done channel at any point in main, both branches will be canceled."),(0,o.kt)("p",null,"By introducing goroutines in main, we\u2019ve opened up the possibility of controlling this program in a few different and interesting ways. Maybe we want ",(0,o.kt)("inlineCode",{parentName:"p"},"genGreeting")," to time out if it takes too long. Maybe we don't want ",(0,o.kt)("inlineCode",{parentName:"p"},"genFarewell")," to invoke locale if we know its parent is going to be canceled soon. ",(0,o.kt)("em",{parentName:"p"},"At each stack-frame, a function can affect the entirety of the call stack below it"),"."),(0,o.kt)("p",null,"Using the ",(0,o.kt)("inlineCode",{parentName:"p"},"done")," channel pattern, we could accomplish this by wrapping the incoming ",(0,o.kt)("inlineCode",{parentName:"p"},"done")," channel in other ",(0,o.kt)("inlineCode",{parentName:"p"},"done")," channels and then returning if any of them fire, but we wouldn't have the extra information about deadlines and errors a ",(0,o.kt)("inlineCode",{parentName:"p"},"Context")," gives us."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'\nfunc main() {\n  var wg sync.WaitGroup\n  // creates a new Context with context.Background()\n  // and wraps it with context.WithCancel to allow for cancellations.\n  ctx, cancel := context.WithCancel(context.Background())\n  defer cancel()\n\n  wg.Add(1)\n  go func() {\n    defer wg.Done()\n    if err := printGreeting(ctx); err != nil {\n      fmt.Printf("cannot print greeting: %v\\n", err)\n      // main will cancel the Context\n      // if there is an error returned from print Greeting.\n      // if greeting encounter some error, it will cancel the main.ctx\n      cancel()\n    }\n  }()\n\n  wg.Add(1)\n  go func() {\n    defer wg.Done()\n    if err := printFarewell(ctx); err != nil {\n      fmt.Printf("cannot print farewell: %v\\n", err)\n    }\n  }()\n\n  wg.Wait()\n}\n\nfunc printFarewell(ctx context.Context) error {\n  // simply pass the ctx down\n  farewell, err := genFarewell(ctx)\n  if err != nil {\n    return err\n  }\n  fmt.Printf("%s world!\\n", farewell)\n  return nil\n}\n\nfunc genFarewell(ctx context.Context) (string, error) {\n  // simply pass the ctx down\n  switch locale, err := locale(ctx); {\n  case err != nil:\n    return "", err\n  case locale == "EN/US":\n    return "goodbye", nil\n  }\n  return "", fmt.Errorf("unsupported locale")\n}\n\nfunc printGreeting(ctx context.Context) error {\n  greeting, err := genGreeting(ctx)\n  if err != nil {\n    return err\n  }\n  fmt.Printf("%s world!\\n", greeting)\n  return nil\n}\n\nfunc genGreeting(ctx context.Context) (string, error) {\n  // genGreeting wraps its Context with context.WithTimeout.\n  ctx, cancel := context.WithTimeout(ctx, 1*time.Second)\n  defer cancel()\n\n  switch locale, err := locale(ctx); {\n  case err != nil:\n    return "", err\n  case locale == "EN/US":\n    return "hello", nil\n  }\n  return "", fmt.Errorf("unsupported locale")\n}\n\nfunc locale(ctx context.Context) (string, error) {\n  // check to see whether the Context has provided a deadline.\n  // If it did, and the system\u2019s clock has advanced past the deadline,\n  // simply return with a special error defined in the context package,\n  // the `DeadlineExceeded`.\n  if deadline, ok := ctx.Deadline(); ok {\n    if deadline.Sub(time.Now().Add(15 * time.Second)) <= 0 {\n      return "", context.DeadlineExceeded\n    }\n  }\n  select {\n  case <-ctx.Done():\n    // This line returns the reason why the Context was canceled.\n    // This error will bubble all the way up to main,\n    // which will cause the cancellation at `main.cancel` function in goroutine\n    return "", ctx.Err()\n  case <-time.After(15 * time.Second):\n  }\n  return "EN/US", nil\n}\n'))),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("p",null,"Although the difference in these example program is small, it allows the ",(0,o.kt)("inlineCode",{parentName:"p"},"locale")," function to fail fast. In programs that may have a high cost for calling the next bit of functionality, this may save a significant amount of time, but at the very least it also allows the function to fail immediately instead of having to wait for the actual timeout to occur. The only catch is that you have to have some idea of how long your subordinate call-graph will take."),(0,o.kt)("p",null,"This brings us to the other half of what the ",(0,o.kt)("inlineCode",{parentName:"p"},"context")," package provides: a data-bag for a ",(0,o.kt)("inlineCode",{parentName:"p"},"Context")," to store and retrieve request-scoped data.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'\nfunc main() {\n  ProcessRequest("jane", "abc123")\n}\n\nfunc ProcessRequest(userID, authToken string) {\n  ctx := context.WithValue(context.Background(), "userID", userID)\n  HandleResponse(ctx)\n  ctx = context.WithValue(ctx, "authToken", authToken)\n  HandleResponse(ctx)\n}\n\nfunc HandleResponse(ctx context.Context) {\n  fmt.Printf(\n    "handling response for %v (%v)",\n    ctx.Value("userID"),\n    ctx.Value("authToken"),\n  )\n}\n')),(0,o.kt)("p",null,"Notice that both the ",(0,o.kt)("inlineCode",{parentName:"p"},"Context"),"\u2019s key and value are defined as ",(0,o.kt)("inlineCode",{parentName:"p"},"interface{}"),", we lose Go\u2019s type-safety when attempting to retrieve values."),(0,o.kt)("p",null,"For these reasons, the Go authors recommend you follow a few rules when storing and retrieving value from a ",(0,o.kt)("inlineCode",{parentName:"p"},"Context"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n  ProcessRequest("jane", "abc123")\n}\n\ntype ctxKey int\n\nconst (\n  ctxUserId ctxKey = iota\n  ctxAuthToken\n)\n\nfunc UserID(c context.Context) string {\n  return c.Value(ctxUserId).(string)\n}\n\nfunc AuthToken(c context.Context) string {\n  return c.Value(ctxAuthToken).(string)\n}\n\nfunc ProcessRequest(userID, authToken string) {\n  ctx := context.WithValue(context.Background(), ctxUserId, userID)\n  ctx = context.WithValue(ctx, ctxAuthToken, authToken)\n  HandleResponse(ctx)\n}\n\nfunc HandleResponse(ctx context.Context) {\n  fmt.Printf(\n    "handling response for %v (%v)",\n    UserID(ctx),\n    AuthToken(ctx),\n  )\n}\n')),(0,o.kt)("p",null,"We now have a type-safe way to retrieve values from the ",(0,o.kt)("inlineCode",{parentName:"p"},"Context"),". However, this technique does pose a problem."),(0,o.kt)("p",null,"In the previous example, let\u2019s say ",(0,o.kt)("inlineCode",{parentName:"p"},"HandleResponse")," did live in another package named ",(0,o.kt)("inlineCode",{parentName:"p"},"response"),", and let\u2019s say the package ",(0,o.kt)("inlineCode",{parentName:"p"},"ProcessRequest")," lived in a package named ",(0,o.kt)("inlineCode",{parentName:"p"},"process"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"process")," package would have to import the ",(0,o.kt)("inlineCode",{parentName:"p"},"response")," package to make the call to ",(0,o.kt)("inlineCode",{parentName:"p"},"HandleResponse"),", but ",(0,o.kt)("inlineCode",{parentName:"p"},"HandleResponse")," would have no way to access the accessor functions defined in the ",(0,o.kt)("inlineCode",{parentName:"p"},"process")," package because importing ",(0,o.kt)("inlineCode",{parentName:"p"},"process")," would form a circular dependency. Because the types used to store the keys in ",(0,o.kt)("inlineCode",{parentName:"p"},"Context")," are private to the ",(0,o.kt)("inlineCode",{parentName:"p"},"process")," package, the ",(0,o.kt)("inlineCode",{parentName:"p"},"response")," package has no way to retrieve this data!"),(0,o.kt)("p",null,"This coerces the architecture into creating packages centered around data types that are imported from multiple locations. This certainly isn't a bad thing, but it\u2019s something to be aware of.")))}p.isMDXComponent=!0}}]);