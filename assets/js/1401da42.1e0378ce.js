"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8171],{3905:(e,n,t)=>{t.d(n,{Zo:()=>f,kt:()=>_});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=a.createContext({}),p=function(e){var n=a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},f=function(e){var n=p(e.components);return a.createElement(i.Provider,{value:n},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,f=o(e,["components","mdxType","originalType","parentName"]),m=p(t),c=r,_=m["".concat(i,".").concat(c)]||m[c]||d[c]||s;return t?a.createElement(_,l(l({ref:n},f),{},{components:t})):a.createElement(_,l({ref:n},f))}));function _(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var s=t.length,l=new Array(s);l[0]=c;var o={};for(var i in n)hasOwnProperty.call(n,i)&&(o[i]=n[i]);o.originalType=e,o[m]="string"==typeof e?e:r,l[1]=o;for(var p=2;p<s;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},79158:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var a=t(87462),r=(t(67294),t(3905));const s={title:"11",tags:["lisp","interpreter"]},l=void 0,o={unversionedId:"lisp-interpreter-in-py/chapter-11",id:"lisp-interpreter-in-py/chapter-11",title:"11",description:"Recap what we've learned so far:",source:"@site/docs/lisp-interpreter-in-py/chapter-11.md",sourceDirName:"lisp-interpreter-in-py",slug:"/lisp-interpreter-in-py/chapter-11",permalink:"/docs/lisp-interpreter-in-py/chapter-11",draft:!1,tags:[{label:"lisp",permalink:"/docs/tags/lisp"},{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",frontMatter:{title:"11",tags:["lisp","interpreter"]},sidebar:"tutorialSidebar",previous:{title:"10",permalink:"/docs/lisp-interpreter-in-py/chapter-10"},next:{title:"12",permalink:"/docs/lisp-interpreter-in-py/chapter-12"}},i={},p=[],f={toc:p};function m(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Recap what we've learned so far:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"How to break sentences into tokens. The process is called ",(0,r.kt)("em",{parentName:"p"},"lexical")," analysis and the part of the interpreter that does it is called a ",(0,r.kt)("em",{parentName:"p"},"lexical analyzer, lexer, scanner"),", or ",(0,r.kt)("em",{parentName:"p"},"tokenizer"),". We've learned how to write our own ",(0,r.kt)("em",{parentName:"p"},"lexer")," from the ground up without using regular expressions or any other tools like ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Lex_(software)"},"Lex"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"How to recognize a phrase in the stream of tokens. The process of recognizing a phrase in the stream of tokens or, to put it differently, the process of finding structure in the stream of tokens is called ",(0,r.kt)("em",{parentName:"p"},"parsing")," or ",(0,r.kt)("em",{parentName:"p"},"syntax analysis"),". The part of an interpreter or compiler that performs that job is called a ",(0,r.kt)("em",{parentName:"p"},"parser")," or ",(0,r.kt)("em",{parentName:"p"},"syntax")," analyzer.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"How to represent a programming language's syntax rules with ",(0,r.kt)("em",{parentName:"p"},"syntax diagrams"),", which are a graphical representation of a programming language's syntax rules. ",(0,r.kt)("em",{parentName:"p"},"Syntax diagrams")," visually show us which statements are allowed in our programming language and which are not.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"How to use another widely used notation for specifying the syntax of a programming language. It's called ",(0,r.kt)("em",{parentName:"p"},"context-free grammars")," (grammars, for short) or ",(0,r.kt)("em",{parentName:"p"},"BNF")," (Backus-Naur Form).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"How to map a ",(0,r.kt)("em",{parentName:"p"},"grammar")," to code and how to write a ",(0,r.kt)("em",{parentName:"p"},"recursive-descent parser"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"How to write a really basic ",(0,r.kt)("em",{parentName:"p"},"interpreter"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"How ",(0,r.kt)("em",{parentName:"p"},"associativity")," and ",(0,r.kt)("em",{parentName:"p"},"precedence")," of operators work and how to construct a grammar using a precedence table.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"How to build an ",(0,r.kt)("em",{parentName:"p"},"Abstract Syntax Tree")," (AST) of a parsed sentence and how to represent the whole source program in Pascal as one big ",(0,r.kt)("em",{parentName:"p"},"AST"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"How to walk an AST and how to implement our interpreter as an AST node visitor."))),(0,r.kt)("p",null,"With all that knowledge and experience under our belt, we've built an interpreter that can scan, parse, and build an AST and interpret, by walking the AST, our very first complete Pascal program."),(0,r.kt)("p",null,"With everything we've covered so far, we are almost ready to tackle topics like:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Nested procedures and functions"),(0,r.kt)("li",{parentName:"ul"},"Procedure and function calls"),(0,r.kt)("li",{parentName:"ul"},"Semantic analysis (type checking, making sure variables are declared before they are used, and basically checking if a program makes sense)"),(0,r.kt)("li",{parentName:"ul"},"Control flow elements (like IF statements)"),(0,r.kt)("li",{parentName:"ul"},"Aggregate data types (Records)"),(0,r.kt)("li",{parentName:"ul"},"More built-in types"),(0,r.kt)("li",{parentName:"ul"},"Source-level debugger"),(0,r.kt)("li",{parentName:"ul"},"Miscellanea (All the other goodness not mentioned above)")),(0,r.kt)("p",null,"But before we cover those topices, we need to dive deeper into the super important topic of symbols, symbol tables, and scopes. The topic itself will span several articles."),(0,r.kt)("p",null,"First, let's talk about symbols and why we need to track them. What is a ",(0,r.kt)("em",{parentName:"p"},"symbol")," ? In this case, we'll informally define ",(0,r.kt)("em",{parentName:"p"},"symbol")," as on identifier of some program entity like a variable, subroutine, or built-in type. For symbols to be useful they need to have at least the following information about the program entites they identify:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Name (x, y, number)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Category ( variable, subroutine, built-in type)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Type (INTEGER, REAL, STRING)"))),(0,r.kt)("p",null,"Today we'll tackle variable symbols and built-in type symbols because we've already used variables and types before. By the way, the \"built-in\" type just means a type that hasn't been defined by you and is available for you right out of the box, like INTEGER and REAL types."),(0,r.kt)("p",null,"Let's take a look at the following Pascal program, specifically at the variable declaration part. You can see in the picture below that there are four symbols in that section: two variable symbols (",(0,r.kt)("em",{parentName:"p"},"x")," and ",(0,r.kt)("em",{parentName:"p"},"y"),") and two built-in type symbols (",(0,r.kt)("em",{parentName:"p"},"INTEGER")," and ",(0,r.kt)("em",{parentName:"p"},"REAL"),")."),(0,r.kt)("img",{src:"./imgs/lsbasi_part11_prog_symbols.png",alt:""}),(0,r.kt)("p",null,"Let's create a base ",(0,r.kt)("em",{parentName:"p"},"Symbol")," class in Python:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Symbol(object):\n    def __init__(self, name, type=None):\n        self.name = name\n        self.type = type\n")),(0,r.kt)("p",null,"The class takes the ",(0,r.kt)("em",{parentName:"p"},"name")," and an optional ",(0,r.kt)("em",{parentName:"p"},"type")," parameters."),(0,r.kt)("p",null,"What about the category of a symbol? We'll encode the category of a symbol in the class name itself, which means we'll create separate classes to represent different symbol categories."),(0,r.kt)("p",null,"Start with the basic built-in types. We've seen two built-in types so far, when we declared variables: INTEGER and REAL. Here is one option for us to represent a built-in type symbol in code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class BuiltinTypeSymbol(Symbol):\n    def __init__(self,name):\n        # python 2.x\n        # super(BuiltinTypeSymbol, self).__init__(name)\n\n        super().__init__(name)\n\n    def __str__(self):\n        return self.name\n\n    __repr__ = __str__\n")),(0,r.kt)("p",null,"The class inherits from the ",(0,r.kt)("em",{parentName:"p"},"Symbol")," class and the constructor requires only a name of the type. The category is encoded in the class name, and the ",(0,r.kt)("em",{parentName:"p"},"type")," parameter from the base class for a built-in type symbol is ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),". The double underscore or ",(0,r.kt)("em",{parentName:"p"},"duder")," in methods ",(0,r.kt)("inlineCode",{parentName:"p"},"__str__")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"__repr__")," are special Python methods and we've defined them to have a nice formatted message when you print a symbol object."),(0,r.kt)("p",null,"We represent a variable symbol via a ",(0,r.kt)("em",{parentName:"p"},"VarSymbol")," class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class VarSymbol(Symbol):\n    def __init__(self, name, type):\n        super().__init__(name, type)\n\n    def __str__(self):\n        return '<{name}:{type}>'.format(name=self.name,type=self.type)\n\n    __repr__ = __str__\n")),(0,r.kt)("p",null,"In the class we made both the ",(0,r.kt)("em",{parentName:"p"},"name")," and the ",(0,r.kt)("em",{parentName:"p"},"type")," parameters required parameters and the class name VarSymbol clearly indicates that an instance of the class will identify a variable symbol (the category is ",(0,r.kt)("em",{parentName:"p"},"variable"),")."),(0,r.kt)("p",null,"Here is the hierarchy of symbols we've defined in visual form:"),(0,r.kt)("img",{src:"./imgs/lsbasi_part11_symbol_hierarchy.png",alt:""}),(0,r.kt)("p",null,"But why we even need to track those symbols in the first place?"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"To make sure that when we assign a value to a variable the types are correct (type checking)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"To make sure that a variable is declared before used"))),(0,r.kt)("p",null,"To be able to identify cases like that even before interpreting/evaluating the source code of the program at run-time, we need to track program symbols. And where do we store the symbols that we track? In the symbol table!"),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"symbol table")," is an abstract data type (ADT) for tracking various symbols in source code. We implement our symbol table as a separate class with some helper methods:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class SymbolTable(object):\n    def __init__(self):\n        self._symbols = OrderedDict()\n\n    def __str__(self):\n        return 'Symbol: {symbols} '.format(\n            symbols=[value for value in self._symbols.values()]\n        )\n\n    __repr__ = __str__\n\n    def define(self, symbol):\n        print('Define %s ' % symbol)\n        self._symbols[symbol.name] = symbol\n\n    def lookup(self,name):\n        print('Lookup: %s ' % name)\n        symbol = self._symbols.get(name)\n        # `symbol` is either an instance of the Symbol class or 'None'\n        return symbol\n")),(0,r.kt)("p",null,"There are two main operations that we will be performing with the symbol table: storing symbols and looking them up by name: ",(0,r.kt)("em",{parentName:"p"},"define")," and ",(0,r.kt)("em",{parentName:"p"},"lookup"),"."),(0,r.kt)("p",null,"The method ",(0,r.kt)("em",{parentName:"p"},"define")," takes a symbol as a parameter and stores it internally in its",(0,r.kt)("em",{parentName:"p"},"symbols ordered dictionary using the symbol's name as a key and the symbol instance as a value. The method ","_","lookup")," takes a symbol name as a parameter and returns a symbol if it finds it or 'None' if not."),(0,r.kt)("p",null,"An example for the contents of the ",(0,r.kt)("em",{parentName:"p"},"_","symbols")," dictionary it would look like this:"),(0,r.kt)("img",{src:"./imgs/lsbasi_part11_symtab.png",alt:""}),(0,r.kt)("p",null,"How to automate the process of building the symbol table?"),(0,r.kt)("p",null,"Write another node visitor that walks the AST built by the parser! (This is another example of how useful it is to have an intermediary form like AST. ) Instead of extending our parser to deal with symbol table, we separate concerns and write a new node visitor class."),(0,r.kt)("p",null,"We extend the ",(0,r.kt)("em",{parentName:"p"},"SymbolTable")," class to initialize the built-in types when the symbol table instance is created. Codes here:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class SymbolTable(object):\n    def __init__(self):\n        self._symbols = OrderedDict()\n        self._init_builtins()\n\n    def _init_builtins(self):\n        self.define(BuiltinTypeSymbol('INTEGER'))\n        self.define(BuiltinTypeSymbol('REAL'))\n\n    def __str__(self):\n        return 'Symbols: {symbols}'.format(\n            symbols=[value for value in self._symbols.values()]\n        )\n\n    __repr__ = __str__\n\n    def define(self, symbol):\n        print('Define: %s ' % symbol)\n        self._symbols[symbol.name] = symbol\n\n    def lookup(self,name):\n        print('Look up: %s ' % name)\n        symbol = self._symbols.get(name)\n        # `symbol` is either an instance of the Symbol class or 'None'\n        return symbol\n")),(0,r.kt)("p",null,"Now onto the ",(0,r.kt)("em",{parentName:"p"},"SymbolTableBuilder")," AST node visitor:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class SymbolTableBuilder(NodeVisitor):\n    def __init__(self):\n        self.symtab = SymbolTable()\n\n    def visit_Block(self,node):\n        for declaration in node.declarations:\n            self.visit(declaration)\n        self.visit(node.compound_statement)\n\n    def visit_Program(self, node):\n        self.visit(node.block)\n\n    def visit_BinOp(self, node):\n        self.visit(node.left)\n        self.visit(node.right)\n\n    def visit_Num(self, node):\n        pass\n\n    def visit_UnaryOp(self, node):\n        self.visit(node.expr)\n\n    def visit_Compound(self,node):\n        for child in node.children:\n            self.visit(child)\n\n    def visit_NoOp(self, node):\n        pass\n\n    def visit_VarDecl(self, node):\n        type_name = node.type_node.value\n        type_symbol = self.symtab.lookup(type_name)\n        var_name = node.var_node.value\n        var_symbol = VarSymbol(var_name, type_symbol)\n        self.symtab.define(var_symbol)\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"visit_VarDecl")," method deserves special attention. It's responsible for visiting (walking) a ",(0,r.kt)("em",{parentName:"p"},"VarDecl")," AST node and storing the corresponding symbol in the symbol table. First, the method looks up the built-in type symbol by name in the symbol table, then it creates an instance of the ",(0,r.kt)("em",{parentName:"p"},"VarSymbol")," class and stores (defines) it in the symbol table."),(0,r.kt)("p",null,"We can already put our symbol table and symbol table builder to good use: using them to verify that variables are declared before used in assignments and expressions. All we need to do is just extend the visitor with two more methods:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def visit_Assign(self,node):\n    var_name = node.left.value\n    var_symbol = self.symtab.lookup(var_name)\n    if var_symbol is None\n        raise NameError(repr(var_name))\n\n    self.visit(node.right)\n\ndef visit_Var(self, node):\n    var_name = node.value\n    var_symbol = self.symtab.lookup(var_name)\n\n    if var_symbol is None:\n        raise NameError(repr(var_name))\n")),(0,r.kt)("p",null,"These methods will raise a ",(0,r.kt)("em",{parentName:"p"},"NameError")," exception if they cannot find the symbol in the symbol table."),(0,r.kt)("p",null,"It should be emphasized that all those checks that our ",(0,r.kt)("em",{parentName:"p"},"SymbolTableBuilder")," AST visitor makes are made before the run-time, so before our interpreter actually evaluates the source program."),(0,r.kt)("p",null,"For example, if we were to interpret the following program:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-pascal"},"PROGRAM Part11;\nVAR\n    x : INTEGER;\nBEGIN\n    x := 2;\nEND.\n")),(0,r.kt)("p",null,"The contents of the symbol table and the run-time GLOBAL_MEMORY right before the program exited would look like this:"),(0,r.kt)("img",{src:"./imgs/lsbasi_part11_symtab_vs_globmem.png",alt:""}),(0,r.kt)("p",null,"The symbol table doesn't hold the value 2 for the variable \"x\". That's solely the interpreter's job now."),(0,r.kt)("p",null,"Again, the ",(0,r.kt)("em",{parentName:"p"},"Interpreter")," class has nothing to do with building the symbol table and it relies on the ",(0,r.kt)("em",{parentName:"p"},"SymbolTableBuilder")," to make sure variables in the source code are properly declared before they are used by the ",(0,r.kt)("em",{parentName:"p"},"Interpreter"),"."),(0,r.kt)("p",null,"Next, more about scopes."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Appendix")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"\"\"\" SPI - Simple Pascal Interpreter. Part 11.\"\"\"\n\nfrom collections import OrderedDict\n\n###############################################################################\n#                                                                             #\n#  LEXER                                                                      #\n#                                                                             #\n###############################################################################\n\n# Token types\n#\n# EOF (end-of-file) token is used to indicate that\n# there is no more input left for lexical analysis\nINTEGER = 'INTEGER'\nREAL = 'REAL'\nINTEGER_CONST = 'INTEGER_CONST'\nREAL_CONST = 'REAL_CONST'\nPLUS = 'PLUS'\nMINUS = 'MINUS'\nMUL = 'MUL'\nINTEGER_DIV = 'INTEGER_DIV'\nFLOAT_DIV = 'FLOAT_DIV'\nLPAREN = 'LPAREN'\nRPAREN = 'RPAREN'\nID = 'ID'\nASSIGN = 'ASSIGN'\nBEGIN = 'BEGIN'\nEND = 'END'\nSEMI = 'SEMI'\nDOT = 'DOT'\nPROGRAM = 'PROGRAM'\nVAR = 'VAR'\nCOLON = 'COLON'\nCOMMA = 'COMMA'\nEOF = 'EOF'\n\n\nclass Token(object):\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n\n    def __str__(self):\n        \"\"\"String representation of the class instance.\n\n        Examples:\n            Token(INTEGER, 3)\n            Token(PLUS, '+')\n            Token(MUL, '*')\n        \"\"\"\n        return 'Token({type}, {value})'.format(\n            type=self.type,\n            value=repr(self.value)\n        )\n\n    def __repr__(self):\n        return self.__str__()\n\n\nRESERVED_KEYWORDS = {\n    'PROGRAM': Token(PROGRAM, 'PROGRAM'),\n    'VAR': Token(VAR, 'VAR'),\n    'DIV': Token(INTEGER_DIV, 'DIV'),\n    'INTEGER': Token(INTEGER, 'INTEGER'),\n    'REAL': Token(REAL, 'REAL'),\n    'BEGIN': Token(BEGIN, 'BEGIN'),\n    'END': Token(END, 'END'),\n}\n\n\nclass Lexer(object):\n    def __init__(self, text):\n        # client string input, e.g. \"4 + 2 * 3 - 6 / 2\"\n        self.text = text\n        # self.pos is an index into self.text\n        self.pos = 0\n        self.current_char = self.text[self.pos]\n\n    def error(self):\n        raise Exception('Invalid character')\n\n    def advance(self):\n        \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\"\n        self.pos += 1\n        if self.pos > len(self.text) - 1:\n            self.current_char = None  # Indicates end of input\n        else:\n            self.current_char = self.text[self.pos]\n\n    def peek(self):\n        peek_pos = self.pos + 1\n        if peek_pos > len(self.text) - 1:\n            return None\n        else:\n            return self.text[peek_pos]\n\n    def skip_whitespace(self):\n        while self.current_char is not None and self.current_char.isspace():\n            self.advance()\n\n    def skip_comment(self):\n        while self.current_char != '}':\n            self.advance()\n        self.advance()  # the closing curly brace\n\n    def number(self):\n        \"\"\"Return a (multidigit) integer or float consumed from the input.\"\"\"\n        result = ''\n        while self.current_char is not None and self.current_char.isdigit():\n            result += self.current_char\n            self.advance()\n\n        if self.current_char == '.':\n            result += self.current_char\n            self.advance()\n\n            while (\n                self.current_char is not None and\n                self.current_char.isdigit()\n            ):\n                result += self.current_char\n                self.advance()\n\n            token = Token(REAL_CONST, float(result))\n        else:\n            token = Token(INTEGER_CONST, int(result))\n\n        return token\n\n    def _id(self):\n        \"\"\"Handle identifiers and reserved keywords\"\"\"\n        result = ''\n        while self.current_char is not None and self.current_char.isalnum():\n            result += self.current_char\n            self.advance()\n\n        token = RESERVED_KEYWORDS.get(result, Token(ID, result))\n        return token\n\n    def get_next_token(self):\n        \"\"\"Lexical analyzer (also known as scanner or tokenizer)\n\n        This method is responsible for breaking a sentence\n        apart into tokens. One token at a time.\n        \"\"\"\n        while self.current_char is not None:\n\n            if self.current_char.isspace():\n                self.skip_whitespace()\n                continue\n\n            if self.current_char == '{':\n                self.advance()\n                self.skip_comment()\n                continue\n\n            if self.current_char.isalpha():\n                return self._id()\n\n            if self.current_char.isdigit():\n                return self.number()\n\n            if self.current_char == ':' and self.peek() == '=':\n                self.advance()\n                self.advance()\n                return Token(ASSIGN, ':=')\n\n            if self.current_char == ';':\n                self.advance()\n                return Token(SEMI, ';')\n\n            if self.current_char == ':':\n                self.advance()\n                return Token(COLON, ':')\n\n            if self.current_char == ',':\n                self.advance()\n                return Token(COMMA, ',')\n\n            if self.current_char == '+':\n                self.advance()\n                return Token(PLUS, '+')\n\n            if self.current_char == '-':\n                self.advance()\n                return Token(MINUS, '-')\n\n            if self.current_char == '*':\n                self.advance()\n                return Token(MUL, '*')\n\n            if self.current_char == '/':\n                self.advance()\n                return Token(FLOAT_DIV, '/')\n\n            if self.current_char == '(':\n                self.advance()\n                return Token(LPAREN, '(')\n\n            if self.current_char == ')':\n                self.advance()\n                return Token(RPAREN, ')')\n\n            if self.current_char == '.':\n                self.advance()\n                return Token(DOT, '.')\n\n            self.error()\n\n        return Token(EOF, None)\n\n\n###############################################################################\n#                                                                             #\n#  PARSER                                                                     #\n#                                                                             #\n###############################################################################\nclass AST(object):\n    pass\n\n\nclass BinOp(AST):\n    def __init__(self, left, op, right):\n        self.left = left\n        self.token = self.op = op\n        self.right = right\n\n\nclass Num(AST):\n    def __init__(self, token):\n        self.token = token\n        self.value = token.value\n\n\nclass UnaryOp(AST):\n    def __init__(self, op, expr):\n        self.token = self.op = op\n        self.expr = expr\n\n\nclass Compound(AST):\n    \"\"\"Represents a 'BEGIN ... END' block\"\"\"\n\n    def __init__(self):\n        self.children = []\n\n\nclass Assign(AST):\n    def __init__(self, left, op, right):\n        self.left = left\n        self.token = self.op = op\n        self.right = right\n\n\nclass Var(AST):\n    \"\"\"The Var node is constructed out of ID token.\"\"\"\n\n    def __init__(self, token):\n        self.token = token\n        self.value = token.value\n\n\nclass NoOp(AST):\n    pass\n\n\nclass Program(AST):\n    def __init__(self, name, block):\n        self.name = name\n        self.block = block\n\n\nclass Block(AST):\n    def __init__(self, declarations, compound_statement):\n        self.declarations = declarations\n        self.compound_statement = compound_statement\n\n\nclass VarDecl(AST):\n    def __init__(self, var_node, type_node):\n        self.var_node = var_node\n        self.type_node = type_node\n\n\nclass Type(AST):\n    def __init__(self, token):\n        self.token = token\n        self.value = token.value\n\n\nclass Parser(object):\n    def __init__(self, lexer):\n        self.lexer = lexer\n        # set current token to the first token taken from the input\n        self.current_token = self.lexer.get_next_token()\n\n    def error(self):\n        raise Exception('Invalid syntax')\n\n    def eat(self, token_type):\n        # compare the current token type with the passed token\n        # type and if they match then \"eat\" the current token\n        # and assign the next token to the self.current_token,\n        # otherwise raise an exception.\n        if self.current_token.type == token_type:\n            self.current_token = self.lexer.get_next_token()\n        else:\n            self.error()\n\n    def program(self):\n        \"\"\"program : PROGRAM variable SEMI block DOT\"\"\"\n        self.eat(PROGRAM)\n        var_node = self.variable()\n        prog_name = var_node.value\n        self.eat(SEMI)\n        block_node = self.block()\n        program_node = Program(prog_name, block_node)\n        self.eat(DOT)\n        return program_node\n\n    def block(self):\n        \"\"\"block : declarations compound_statement\"\"\"\n        declaration_nodes = self.declarations()\n        compound_statement_node = self.compound_statement()\n        node = Block(declaration_nodes, compound_statement_node)\n        return node\n\n    def declarations(self):\n        \"\"\"declarations : VAR (variable_declaration SEMI)+\n                        | empty\n        \"\"\"\n        declarations = []\n        if self.current_token.type == VAR:\n            self.eat(VAR)\n            while self.current_token.type == ID:\n                var_decl = self.variable_declaration()\n                declarations.extend(var_decl)\n                self.eat(SEMI)\n\n        return declarations\n\n    def variable_declaration(self):\n        \"\"\"variable_declaration : ID (COMMA ID)* COLON type_spec\"\"\"\n        var_nodes = [Var(self.current_token)]  # first ID\n        self.eat(ID)\n\n        while self.current_token.type == COMMA:\n            self.eat(COMMA)\n            var_nodes.append(Var(self.current_token))\n            self.eat(ID)\n\n        self.eat(COLON)\n\n        type_node = self.type_spec()\n        var_declarations = [\n            VarDecl(var_node, type_node) for var_node in var_nodes\n        ]\n        return var_declarations\n\n    def type_spec(self):\n        \"\"\"type_spec : INTEGER\n                     | REAL\n        \"\"\"\n        token = self.current_token\n        if self.current_token.type == INTEGER:\n            self.eat(INTEGER)\n        else:\n            self.eat(REAL)\n        node = Type(token)\n        return node\n\n    def compound_statement(self):\n        \"\"\"\n        compound_statement: BEGIN statement_list END\n        \"\"\"\n        self.eat(BEGIN)\n        nodes = self.statement_list()\n        self.eat(END)\n\n        root = Compound()\n        for node in nodes:\n            root.children.append(node)\n\n        return root\n\n    def statement_list(self):\n        \"\"\"\n        statement_list : statement\n                       | statement SEMI statement_list\n        \"\"\"\n        node = self.statement()\n\n        results = [node]\n\n        while self.current_token.type == SEMI:\n            self.eat(SEMI)\n            results.append(self.statement())\n\n        return results\n\n    def statement(self):\n        \"\"\"\n        statement : compound_statement\n            | assignment_statement\n            | empty\n        \"\"\"\n        if self.current_token.type == BEGIN:\n            node = self.compound_statement()\n        elif self.current_token.type == ID:\n            node = self.assignment_statement()\n        else:\n            node = self.empty()\n        return node\n\n    def assignment_statement(self):\n        \"\"\"\n        assignment_statement : variable ASSIGN expr\n        \"\"\"\n        left = self.variable()\n        token = self.current_token\n        self.eat(ASSIGN)\n        right = self.expr()\n        node = Assign(left, token, right)\n        return node\n\n    def variable(self):\n        \"\"\"\n        variable : ID\n        \"\"\"\n        node = Var(self.current_token)\n        self.eat(ID)\n        return node\n\n    def empty(self):\n        \"\"\"An empty production\"\"\"\n        return NoOp()\n\n    def expr(self):\n        \"\"\"\n        expr : term ((PLUS | MINUS) term)*\n        \"\"\"\n        node = self.term()\n\n        while self.current_token.type in (PLUS, MINUS):\n            token = self.current_token\n            if token.type == PLUS:\n                self.eat(PLUS)\n            elif token.type == MINUS:\n                self.eat(MINUS)\n\n            node = BinOp(left=node, op=token, right=self.term())\n\n        return node\n\n    def term(self):\n        \"\"\"term : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*\"\"\"\n        node = self.factor()\n\n        while self.current_token.type in (MUL, INTEGER_DIV, FLOAT_DIV):\n            token = self.current_token\n            if token.type == MUL:\n                self.eat(MUL)\n            elif token.type == INTEGER_DIV:\n                self.eat(INTEGER_DIV)\n            elif token.type == FLOAT_DIV:\n                self.eat(FLOAT_DIV)\n\n            node = BinOp(left=node, op=token, right=self.factor())\n\n        return node\n\n    def factor(self):\n        \"\"\"factor : PLUS factor\n                  | MINUS factor\n                  | INTEGER_CONST\n                  | REAL_CONST\n                  | LPAREN expr RPAREN\n                  | variable\n        \"\"\"\n        token = self.current_token\n        if token.type == PLUS:\n            self.eat(PLUS)\n            node = UnaryOp(token, self.factor())\n            return node\n        elif token.type == MINUS:\n            self.eat(MINUS)\n            node = UnaryOp(token, self.factor())\n            return node\n        elif token.type == INTEGER_CONST:\n            self.eat(INTEGER_CONST)\n            return Num(token)\n        elif token.type == REAL_CONST:\n            self.eat(REAL_CONST)\n            return Num(token)\n        elif token.type == LPAREN:\n            self.eat(LPAREN)\n            node = self.expr()\n            self.eat(RPAREN)\n            return node\n        else:\n            node = self.variable()\n            return node\n\n    def parse(self):\n        \"\"\"\n        program : PROGRAM variable SEMI block DOT\n\n        block : declarations compound_statement\n\n        declarations : VAR (variable_declaration SEMI)+\n                     | empty\n\n        variable_declaration : ID (COMMA ID)* COLON type_spec\n\n        type_spec : INTEGER\n\n        compound_statement : BEGIN statement_list END\n\n        statement_list : statement\n                       | statement SEMI statement_list\n\n        statement : compound_statement\n                  | assignment_statement\n                  | empty\n\n        assignment_statement : variable ASSIGN expr\n\n        empty :\n\n        expr : term ((PLUS | MINUS) term)*\n\n        term : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*\n\n        factor : PLUS factor\n               | MINUS factor\n               | INTEGER_CONST\n               | REAL_CONST\n               | LPAREN expr RPAREN\n               | variable\n\n        variable: ID\n        \"\"\"\n        node = self.program()\n        if self.current_token.type != EOF:\n            self.error()\n\n        return node\n\n\n###############################################################################\n#                                                                             #\n#  AST visitors (walkers)                                                     #\n#                                                                             #\n###############################################################################\n\nclass NodeVisitor(object):\n    def visit(self, node):\n        method_name = 'visit_' + type(node).__name__\n        visitor = getattr(self, method_name, self.generic_visit)\n        return visitor(node)\n\n    def generic_visit(self, node):\n        raise Exception('No visit_{} method'.format(type(node).__name__))\n\n\n###############################################################################\n#                                                                             #\n#  SYMBOLS and SYMBOL TABLE                                                   #\n#                                                                             #\n###############################################################################\n\nclass Symbol(object):\n    def __init__(self, name, type=None):\n        self.name = name\n        self.type = type\n\n\nclass VarSymbol(Symbol):\n    def __init__(self, name, type):\n        super().__init__(name, type)\n\n    def __str__(self):\n        return '<{name}:{type}>'.format(name=self.name, type=self.type)\n\n    __repr__ = __str__\n\n\nclass BuiltinTypeSymbol(Symbol):\n    def __init__(self, name):\n        super().__init__(name)\n\n    def __str__(self):\n        return self.name\n\n    __repr__ = __str__\n\n\nclass SymbolTable(object):\n    def __init__(self):\n        self._symbols = OrderedDict()\n        self._init_builtins()\n\n    def _init_builtins(self):\n        self.define(BuiltinTypeSymbol('INTEGER'))\n        self.define(BuiltinTypeSymbol('REAL'))\n\n    def __str__(self):\n        return 'Symbols: {symbols}'.format(\n            symbols=[value for value in self._symbols.values()]\n        )\n\n    __repr__ = __str__\n\n    def define(self, symbol):\n        print('Define: %s' % symbol)\n        self._symbols[symbol.name] = symbol\n\n    def lookup(self, name):\n        print('Lookup: %s' % name)\n        symbol = self._symbols.get(name)\n        # 'symbol' is either an instance of the Symbol class or 'None'\n        return symbol\n\n\nclass SymbolTableBuilder(NodeVisitor):\n    def __init__(self):\n        self.symtab = SymbolTable()\n\n    def visit_Block(self, node):\n        for declaration in node.declarations:\n            self.visit(declaration)\n        self.visit(node.compound_statement)\n\n    def visit_Program(self, node):\n        self.visit(node.block)\n\n    def visit_BinOp(self, node):\n        self.visit(node.left)\n        self.visit(node.right)\n\n    def visit_Num(self, node):\n        pass\n\n    def visit_UnaryOp(self, node):\n        self.visit(node.expr)\n\n    def visit_Compound(self, node):\n        for child in node.children:\n            self.visit(child)\n\n    def visit_NoOp(self, node):\n        pass\n\n    def visit_VarDecl(self, node):\n        type_name = node.type_node.value\n        type_symbol = self.symtab.lookup(type_name)\n        var_name = node.var_node.value\n        var_symbol = VarSymbol(var_name, type_symbol)\n        self.symtab.define(var_symbol)\n\n    def visit_Assign(self, node):\n        var_name = node.left.value\n        var_symbol = self.symtab.lookup(var_name)\n        if var_symbol is None:\n            raise NameError(repr(var_name))\n\n        self.visit(node.right)\n\n    def visit_Var(self, node):\n        var_name = node.value\n        var_symbol = self.symtab.lookup(var_name)\n\n        if var_symbol is None:\n            raise NameError(repr(var_name))\n\n\n###############################################################################\n#                                                                             #\n#  INTERPRETER                                                                #\n#                                                                             #\n###############################################################################\n\nclass Interpreter(NodeVisitor):\n    def __init__(self, tree):\n        self.tree = tree\n        self.GLOBAL_MEMORY = OrderedDict()\n\n    def visit_Program(self, node):\n        self.visit(node.block)\n\n    def visit_Block(self, node):\n        for declaration in node.declarations:\n            self.visit(declaration)\n        self.visit(node.compound_statement)\n\n    def visit_VarDecl(self, node):\n        pass\n\n    def visit_Type(self, node):\n        pass\n\n    def visit_BinOp(self, node):\n        if node.op.type == PLUS:\n            return self.visit(node.left) + self.visit(node.right)\n        elif node.op.type == MINUS:\n            return self.visit(node.left) - self.visit(node.right)\n        elif node.op.type == MUL:\n            return self.visit(node.left) * self.visit(node.right)\n        elif node.op.type == INTEGER_DIV:\n            return self.visit(node.left) // self.visit(node.right)\n        elif node.op.type == FLOAT_DIV:\n            return float(self.visit(node.left)) / float(self.visit(node.right))\n\n    def visit_Num(self, node):\n        return node.value\n\n    def visit_UnaryOp(self, node):\n        op = node.op.type\n        if op == PLUS:\n            return +self.visit(node.expr)\n        elif op == MINUS:\n            return -self.visit(node.expr)\n\n    def visit_Compound(self, node):\n        for child in node.children:\n            self.visit(child)\n\n    def visit_Assign(self, node):\n        var_name = node.left.value\n        var_value = self.visit(node.right)\n        self.GLOBAL_MEMORY[var_name] = var_value\n\n    def visit_Var(self, node):\n        var_name = node.value\n        var_value = self.GLOBAL_MEMORY.get(var_name)\n        return var_value\n\n    def visit_NoOp(self, node):\n        pass\n\n    def interpret(self):\n        tree = self.tree\n        if tree is None:\n            return ''\n        return self.visit(tree)\n\n\ndef main():\n    import sys\n    text = open(sys.argv[1], 'r').read()\n\n    lexer = Lexer(text)\n    parser = Parser(lexer)\n    tree = parser.parse()\n    symtab_builder = SymbolTableBuilder()\n    symtab_builder.visit(tree)\n    print('-----')\n    print('Symbol Table Contents:')\n    print(symtab_builder.symtab)\n\n    interpreter = Interpreter(tree)\n    result = interpreter.interpret()\n    print('-----')\n    print('Run-time GLOBAL_MEMORY contents:')\n    for k, v in sorted(interpreter.GLOBAL_MEMORY.items()):\n        print('%s = %s' % (k, v))\n\n\nif __name__ == '__main__':\n    main()\n")))}m.isMDXComponent=!0}}]);