"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[841],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>h});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var o=r.createContext({}),p=function(e){var n=r.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=p(e.components);return r.createElement(o.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(t),m=a,h=u["".concat(o,".").concat(m)]||u[m]||d[m]||i;return t?r.createElement(h,l(l({ref:n},c),{},{components:t})):r.createElement(h,l({ref:n},c))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,l=new Array(i);l[0]=m;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s[u]="string"==typeof e?e:a,l[1]=s;for(var p=2;p<i;p++)l[p]=t[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},75364:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var r=t(87462),a=(t(67294),t(3905));const i={title:"12 Strings",tags:["lisp","interpreter"]},l=void 0,s={unversionedId:"lisp-interpreter-in-c/strings",id:"lisp-interpreter-in-c/strings",title:"12 Strings",description:"document",source:"@site/docs/lisp-interpreter-in-c/12-strings.md",sourceDirName:"lisp-interpreter-in-c",slug:"/lisp-interpreter-in-c/strings",permalink:"/docs/lisp-interpreter-in-c/strings",draft:!1,tags:[{label:"lisp",permalink:"/docs/tags/lisp"},{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",sidebarPosition:12,frontMatter:{title:"12 Strings",tags:["lisp","interpreter"]},sidebar:"tutorialSidebar",previous:{title:"11 Conditionals",permalink:"/docs/lisp-interpreter-in-c/conditionals"},next:{title:"13 Standard Library",permalink:"/docs/lisp-interpreter-in-c/standard-library"}},o={},p=[{value:"Libraries",id:"libraries",level:2},{value:"String Type",id:"string-type",level:2},{value:"Reading Strings",id:"reading-strings",level:2},{value:"Comments",id:"comments",level:2},{value:"Load Function",id:"load-function",level:2},{value:"Command Line Arguments",id:"command-line-arguments",level:2},{value:"Print Function",id:"print-function",level:2},{value:"Error Function",id:"error-function",level:2},{value:"Wrapping Up",id:"wrapping-up",level:2}],c={toc:p};function u(e){let{components:n,...i}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"http://www.buildyourownlisp.com/chapter14_strings"},"document")),(0,a.kt)("p",null,"codes:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{target:"_blank",href:t(6658).Z},"strings.c"))),(0,a.kt)("h2",{id:"libraries"},"Libraries"),(0,a.kt)("p",null,"Now the Lisp is fully functional in the terminal. In this chapter, we'll add the functionality to load code from a file and run it. This will allow us to start building up a standard library up. Along the way we'll also add support for code comments, strings, and printing."),(0,a.kt)("h2",{id:"string-type"},"String Type"),(0,a.kt)("p",null,"For the user to load a file we'll have to let them supply a string consisting of the file name, which can include spaces and other characters. We nee to add this possible ",(0,a.kt)("inlineCode",{parentName:"p"},"lval")," type to specify the file names we need."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"enmu { LVAL_ERR, LVAL_NUM, LVAL_SYM, LVAL_STR, LVAL_FUN, LVAL_SEXPR, LVAL_QEXPR };\n\nstruct lval {\n    //...\n    long num;\n    char* err;\n    char* sym;\n    char* str;\n    //...\n};\n\nlval* lval_str(char* s) {\n    lval* v = malloc(sizeof(lval));\n    v->type = LVAL_STR;\n    v->str = malloc(strlen(s) + 1);\n    strcpy(v->str, s);\n    return v;\n}\n")),(0,a.kt)("p",null,"We also need to add relevant entries into the functions that deal with ",(0,a.kt)("inlineCode",{parentName:"p"},"lval"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'// for deletion\ncase LVAL_STR: free(v->str); break;\n\n// for copying\ncase LVAL_STR: x->str = malloc(strlen(v->str) + 1);\n            strcpy(x->str, v->str); break;\n\n// for equality\ncase LVAL_STR: return ( strcmp(x->str, y->str) == 0);\n\n// for type name\ncase LVAL_STR: return "string";\n\n// for print\ncase LVAL_STR: lval_print_str(v); break;\n')),(0,a.kt)("p",null,"For Printing, we need to do a little more. The string we store internally is different to the string we want to print. We want to print a string as a user might input it, using escape characters such as ",(0,a.kt)("inlineCode",{parentName:"p"},"\\n")," to represent a new line."),(0,a.kt)("p",null,"We therefore need to escape it before we print it. Luckily we can make use of a ",(0,a.kt)("inlineCode",{parentName:"p"},"mpc")," function that will do this for us."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'void lval_print_str(lval* v) {\n    char* escaped = malloc(strlen(v->str)+1);\n    strcpy(escaped, v->str);\n\n    escaped = mpcf_escape(escaped);\n\n    printf("\\"%s\\"", escaped);\n\n    free(escaped);\n}\n')),(0,a.kt)("h2",{id:"reading-strings"},"Reading Strings"),(0,a.kt)("p",null,"Now we need to add support for parsing strings. As usual this requires first adding a new grammar rule called ",(0,a.kt)("inlineCode",{parentName:"p"},"string")," and adding it to the parser."),(0,a.kt)("p",null,"The rule we are going to use that represents a string is going to be the same as for C style strings. This means a string is essentially series of escaped characters, or normal characters, between twe quotation marks ",(0,a.kt)("inlineCode",{parentName:"p"},'""'),". We can specify this as a regular expression inside the grammar string as follows."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'string: /\\"(\\\\\\\\.|[^\\"])*\\"/;  //???\n')),(0,a.kt)("p",null,"This looks complicated but makes a lot more sense when explained in parts. A string is a ",(0,a.kt)("inlineCode",{parentName:"p"},'"')," character, followed by zero or more of either a backslash ",(0,a.kt)("inlineCode",{parentName:"p"},"\\\\")," followed by any other character ",(0,a.kt)("inlineCode",{parentName:"p"},"."),", or anything this isn't a ",(0,a.kt)("inlineCode",{parentName:"p"},'"'),", character ",(0,a.kt)("inlineCode",{parentName:"p"},'[^\\"]'),". Finally, it ends with another ",(0,a.kt)("inlineCode",{parentName:"p"},'"')," character."),(0,a.kt)("p",null,"We also need to add a case to deal with this in the ",(0,a.kt)("inlineCode",{parentName:"p"},"lval_read")," function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'if (strstr(t->tag, "string")) { return lval_read_str(t); }\n')),(0,a.kt)("p",null,"Because the input string is input in an escaped from we need to create a function ",(0,a.kt)("inlineCode",{parentName:"p"},"lval_read_str")," which deals with this. This function is a little tricky because it has to do a few tasks. First it must strip the input string of the ",(0,a.kt)("inlineCode",{parentName:"p"},'"')," characters on either side. Then it must unescape the string, converting series of characters such as ",(0,a.kt)("inlineCode",{parentName:"p"},"\\n")," to their actual encoded characters. Finally, it has to create a new ",(0,a.kt)("inlineCode",{parentName:"p"},"lval")," and clean up anything that has happened in-between."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"lval* lval_read_str(mcp_ast_t* t) {\n    /* Cut off the final quote character */\n    t->contents[strlen(strlen(t->contents) -1] = '\\0';\n    /* Copy the string missing out the first quote character */\n    char* unescaped = malloc(strlen(t->contents+1) + 1); // ??\n    strcpy(unescaped, t->contents+1);\n    unescaped = mpcf_unescape(unescaped);\n    lval* str = lval_str(unescaped);\n    free(unescaped);\n    return str;\n}\n")),(0,a.kt)("h2",{id:"comments"},"Comments"),(0,a.kt)("p",null,"While we're building in new syntax to the language we may as well look at comments."),(0,a.kt)("p",null,"Just like in C, we can use comments in inform other people (or ourselves) about what the code is meant to do or why it has been written. In C comments go between ",(0,a.kt)("inlineCode",{parentName:"p"},"/*")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"*/"),". Lisp comments, on the other hand, start with ",(0,a.kt)("inlineCode",{parentName:"p"},";")," and run to the end of the line."),(0,a.kt)("p",null,"I attempted to research why Lisps use ",(0,a.kt)("inlineCode",{parentName:"p"},";")," for comments, but it appears that the origins of this have been lost in the mists of time. I imagine it as a small rebellion against the imperative languages such as C and Java which use semicolons so shamelessly and frequently to separate/terminate statements. Compared to Lisp all these languages are just comments."),(0,a.kt)("p",null,"So in LISP, a comment is defined by a semicolon ",(0,a.kt)("inlineCode",{parentName:"p"},";")," followed by any number of characters that are not newline characters represented by either ",(0,a.kt)("inlineCode",{parentName:"p"},"\\r")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"\\n"),". We can use another regex to define it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"comment : /;[^\\\\r^\\\\n]*/;\n")),(0,a.kt)("p",null,"As with strings we need to create a new parser and use this to update the language in ",(0,a.kt)("inlineCode",{parentName:"p"},"mpca_lang"),". We also need to remember to add the parser to ",(0,a.kt)("inlineCode",{parentName:"p"},"mpc_cleanup"),", and update the first integer argument to reflect the new number of parsers passed in."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"mpca_lang( MPCA_LANG_DEFAULT,\n    \"\n        number: /-?[0-9]+/; \\\n        symbol: /[a-zA-Z0-9_+\\\\-*\\\\/\\\\\\\\=<>!&]+/; \\\n        string: /\\\"(\\\\\\\\.|[^\\\"])*\\\"/; \\\n        comment: /;[^\\\\r\\\\n]*/; \\\n        sexpr: '(' <expr>* ')'; \\\n        qexpr: '{' <expr>* '}'; \\\n        expr: <number> | <symbol> | <string> | <comment> | <sexpr> | <qexpr> ; \\\n        lispy: /^/ <expr> * /$/; \\\n    \",\n    Number, Symbol, String, Comment, Sexpr, Qexpr, Expr, Lispy);\n\nmpc_cleanup(8, Number, Symbol, String, Comment, Sexpr, Qexpr, Expr, Lispy);\n")),(0,a.kt)("p",null,"Because comments are only for programmers reading the code, our internal function for reading them in just consists of ignoring them. We can add a clause to deal with them in a similar way to brackets and parenthesis in ",(0,a.kt)("inlineCode",{parentName:"p"},"lval_read"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'if (strstr(t->children[i]->tag, "comment")) { continue; }\n')),(0,a.kt)("h2",{id:"load-function"},"Load Function"),(0,a.kt)("p",null,"We want to build a function that can load and evaluate a file when passed a string of its name. To implement this function we'll need to make use of the grammar as we'll need ti to read in the file contents, parse, and evaluate them. The load function is going to rely on the ",(0,a.kt)("inlineCode",{parentName:"p"},"mpc_parser*")," called ",(0,a.kt)("inlineCode",{parentName:"p"},"Lispy"),"."),(0,a.kt)("p",null,"Therefore, just like with functions, we need to forward declare the parser pointers, and place them at the top of the file."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"mpc_parser_t* Number;\nmpc_parser_t* Symbol;\nmpc_parser_t* String;\nmpc_parser_t* Comment;\nmpc_parser_t* Sexpr;\nmpc_parser_t* Qexpr;\nmpc_parser_t* Expr;\nmpc_parser_t* Lispy;\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"load")," function will just like any other builtin. We need to start by checking that the input argument is a single string. Then we can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"mpc_parse_contents")," function to read in the contents of a file using a grammar. Just like ",(0,a.kt)("inlineCode",{parentName:"p"},"mpc_parse")," this parses the contents of a file into some ",(0,a.kt)("inlineCode",{parentName:"p"},"mpc_result")," object, which in our case is an ",(0,a.kt)("strong",{parentName:"p"},"abstract syntax tree")," again or an ",(0,a.kt)("strong",{parentName:"p"},"error"),"."),(0,a.kt)("p",null,"Slightly differently to the command prompt, on successfully parsing a file we shouldn't treat it like on expression. When typing into a file we let users list multiple expressions and evaluate all of them individually. To achieve this behaviour we need to loop over each expression in the contents of the file and evaluate it one by one. If there are any errors we should print them and continue."),(0,a.kt)("p",null,"If there is a parse error we're going to extract the message and put it into an error ",(0,a.kt)("inlineCode",{parentName:"p"},"lval")," which we return. If there are no errors the return value for this builtin can just be the empty expression. The full code for this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'lval* builtin_load(lenv* e, lval* a) {\n    LASSERT_NUM("load", a, 1);\n    LASSERT_TYPE("load", a, 0, LVAL_STR);\n\n    /* Parse File given by string name*/\n    mpc_result_t r;\n    if (mpc_parse_contents(a->cell[0]->str, Lispy, &r)) {\n        lval* expr = lval_read(r.output);\n        mpc_ast_delete(r.output);\n        while (expr->count) {\n            lval* x = lval_eval(e, lval_pop(expr, 0));\n            if (x->type == LVAL_ERR) { lval_println(x); }\n            lval_del(x);\n        }\n        lval_del(expr);\n        lval_del(a);\n        return lval_sexpr();\n    } else {\n        char* err_msg = mpc_err_string(r.error);\n        mpc_err_delete(r.error);\n\n        lval* err = lval_err("could not load library %s", err_msg);\n        free(err_msg);\n        lval_del(a);\n\n        return err;\n    }\n}\n')),(0,a.kt)("h2",{id:"command-line-arguments"},"Command Line Arguments"),(0,a.kt)("p",null,"With the ability to load files, we can take the chance to add in some functionality typical of other programming languages. When file names are given as arguments to the command line we can try to run these files. For example to run a python file one might write ",(0,a.kt)("inlineCode",{parentName:"p"},"python filename.py"),"."),(0,a.kt)("p",null,"These command line arguments are accessible using the ",(0,a.kt)("inlineCode",{parentName:"p"},"argc")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"argv")," variables that are given to ",(0,a.kt)("inlineCode",{parentName:"p"},"main"),". The ",(0,a.kt)("inlineCode",{parentName:"p"},"argc")," variable gives the number of arguments, and ",(0,a.kt)("inlineCode",{parentName:"p"},"argv")," specifies each string. The ",(0,a.kt)("inlineCode",{parentName:"p"},"argc")," is always set to at least one, where the first argument is always the complete command invoked."),(0,a.kt)("p",null,"That means if ",(0,a.kt)("inlineCode",{parentName:"p"},"argc")," is set to ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," we can invoke the interpreter, otherwise we can run each of the arguments through the ",(0,a.kt)("inlineCode",{parentName:"p"},"builtin_load")," function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"if (argc >= 2) {\n    for (int i = 1; i < argc; i++) {\n        lval* args = lval_add(lval_sexpr(), lval_str(argv[i]));\n        lval* x = builtin_load(e, args);\n\n        if (x->type == LVAL_ERR) { lval_println(x); }\n        lval_del(x);\n    }\n}\n")),(0,a.kt)("h2",{id:"print-function"},"Print Function"),(0,a.kt)("p",null,"If we are running programs form the command line we might want them to output some data, rather than just define functions and other values. We can add a ",(0,a.kt)("inlineCode",{parentName:"p"},"print")," function to the Lisp which makes use of the existing ",(0,a.kt)("inlineCode",{parentName:"p"},"lval_print")," function."),(0,a.kt)("p",null,"This function prints each argument separated by a space and then prints a newline character to finish. It returns the empty expression."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"lval* builin_print(lenv* e, lval* a) {\n    for (int i = 0; i < a->count; i++) {\n        lval_print(a->cell[i]); putchar(' ');\n    }\n\n    putchar('\\n');\n    lval_del(a);\n\n    return lval_sexpr();\n}\n")),(0,a.kt)("h2",{id:"error-function"},"Error Function"),(0,a.kt)("p",null,"We can also make use of strings to add in an error reporting functions. This can take as input a user supplied string and provide it as an error message ",(0,a.kt)("inlineCode",{parentName:"p"},"lval_err"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'lval* builtin_error(lenv* e, lval* a) {\n    LASSERT_NUM("error", a, 1);\n    LASSERT_TYPE("error", a, 0, LVAL_STR);\n\n    lval* err = lval_err(a->cell[0]->str);\n\n    lval_del(a);\n    return err;\n}\n')),(0,a.kt)("p",null,"Also, remember to register these as builtins."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'lenv_add_builtin(e, "load", builtin_load);\nlenv_add_builtin(e, "error", builtin_error);\nlenv_add_builtin(e, "print", builtin_print);\n')),(0,a.kt)("h2",{id:"wrapping-up"},"Wrapping Up"),(0,a.kt)("p",null,"This is the last chapter in which we are going to explicitly work on our C implementation of Lisp. The result of this chapter will be the final state of your language implementation."),(0,a.kt)("p",null,"The final line count should clock in somewhere close to 1000 lines of code. Writing this amount of code is not trivial. If you've made it this far you've written a real program and started on a proper project. The skills you've learnt here should be transferable, and give you the confidence to seek out your own goals and targets. You now have a complex and beautiful program which you can interact and play with. This is something you should be proud of. Go show it off to your friends and family!"))}u.isMDXComponent=!0},6658:(e,n,t)=>{t.d(n,{Z:()=>r});const r=t.p+"assets/files/strings-56f6e674dd57aaebf4c884b050d076ac.c"}}]);