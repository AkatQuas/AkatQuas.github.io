"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9750],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>d});var n=a(67294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},m=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=c(a),h=o,d=u["".concat(l,".").concat(h)]||u[h]||p[h]||i;return a?n.createElement(d,r(r({ref:t},m),{},{components:a})):n.createElement(d,r({ref:t},m))}));function d(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=a.length,r=new Array(i);r[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=a[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},84563:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=a(87462),o=(a(67294),a(3905));const i={title:"Modularity, Objects, and State",tags:["sicp"]},r=void 0,s={unversionedId:"sicp/modularity-objects-state",id:"sicp/modularity-objects-state",title:"Modularity, Objects, and State",description:"Effective program synthesis also requires organizational principles that can guide us in formulating the overall design of a program.",source:"@site/docs/sicp/03-modularity-objects-state.md",sourceDirName:"sicp",slug:"/sicp/modularity-objects-state",permalink:"/docs/sicp/modularity-objects-state",draft:!1,tags:[{label:"sicp",permalink:"/docs/tags/sicp"}],version:"current",sidebarPosition:3,frontMatter:{title:"Modularity, Objects, and State",tags:["sicp"]},sidebar:"tutorialSidebar",previous:{title:"Building Abstractions with Data",permalink:"/docs/sicp/building-abstractions-with-data"},next:{title:"Metalinguistic Abstraction",permalink:"/docs/sicp/metalinguistic-abstraction"}},l={},c=[{value:"Assignment and Local State",id:"assignment-and-local-state",level:2},{value:"Local State Variables",id:"local-state-variables",level:3},{value:"The Benefits of Introducing Assignment",id:"the-benefits-of-introducing-assignment",level:3},{value:"The Costs of Introducing Assignment",id:"the-costs-of-introducing-assignment",level:3},{value:"Sameness and change",id:"sameness-and-change",level:4},{value:"Pitfalls of imperative programming",id:"pitfalls-of-imperative-programming",level:4},{value:"The Environment Model of Evaluation",id:"the-environment-model-of-evaluation",level:2},{value:"The Rules for Evaluation",id:"the-rules-for-evaluation",level:3},{value:"Internal Definitions",id:"internal-definitions",level:3},{value:"Modeling with Mutable Data",id:"modeling-with-mutable-data",level:2},{value:"Sharing and identity",id:"sharing-and-identity",level:3},{value:"Mutation is just assignment",id:"mutation-is-just-assignment",level:3},{value:"Representing Queues",id:"representing-queues",level:3},{value:"Propagation of Constraints",id:"propagation-of-constraints",level:3},{value:"Implementing the constraint system",id:"implementing-the-constraint-system",level:3},{value:"Representing connectors",id:"representing-connectors",level:3},{value:"Concurrency: Time Is of the Essence",id:"concurrency-time-is-of-the-essence",level:2},{value:"The Nature of Time in Concurrent Systems",id:"the-nature-of-time-in-concurrent-systems",level:3},{value:"Correct behavior of concurrent programs",id:"correct-behavior-of-concurrent-programs",level:4},{value:"Mechanisms for Controlling Concurrency",id:"mechanisms-for-controlling-concurrency",level:3},{value:"Serializing access to shared state",id:"serializing-access-to-shared-state",level:4},{value:"Complexity of using multiple shared resources",id:"complexity-of-using-multiple-shared-resources",level:4},{value:"Implementing serializers",id:"implementing-serializers",level:4},{value:"Streams",id:"streams",level:2},{value:"Streams Are Delayed Lists",id:"streams-are-delayed-lists",level:3},{value:"Infinite Streams",id:"infinite-streams",level:3},{value:"Defining streams implicitly",id:"defining-streams-implicitly",level:4},{value:"Exploiting the Stream Paradigm",id:"exploiting-the-stream-paradigm",level:3},{value:"Streams and Delayed Evaluation",id:"streams-and-delayed-evaluation",level:3},{value:"Modularity of Functional Programs and Modularity of Objects",id:"modularity-of-functional-programs-and-modularity-of-objects",level:3},{value:"A functional-programming view of time",id:"a-functional-programming-view-of-time",level:4}],m={toc:c};function u(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Effective program synthesis also requires organizational principles that can guide us in formulating the overall design of a program."),(0,o.kt)("p",null,"In particular, we need strategies to help us structure large systems so that they will be ",(0,o.kt)("em",{parentName:"p"},"modular"),", that is, so that they can be divided ",(0,o.kt)("em",{parentName:"p"},"naturally")," into coherent parts that can be separately developed and maintained."),(0,o.kt)("p",null,"There are two prominent organizational strategies arising from two rather different ",(0,o.kt)("em",{parentName:"p"},"world views")," of the structure of systems:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"object-based: viewing a large system as a collection of distinct objects whose behaviors may change over time.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"stream-processing: concentrating on the streams of information that flow in the system."))),(0,o.kt)("h2",{id:"assignment-and-local-state"},"Assignment and Local State"),(0,o.kt)("p",null,"An object is said to ",(0,o.kt)("em",{parentName:"p"},"have state")," if its behavior is influenced by its history."),(0,o.kt)("p",null,"We can characterize an object's state by one or more ",(0,o.kt)("em",{parentName:"p"},"state variables"),", which among them maintain enough information about history to determine the object's current behavior."),(0,o.kt)("p",null,"In a system composed of many objects, the objects are rarely completely independent. Each may influence the states of others through interactions, which serve to couple the state variables of one object to those of other objects."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Indeed, the view that a system is composed of separate objects is most useful when the state variables of the system can be grouped into ",(0,o.kt)("em",{parentName:"p"},"closely coupled")," subsystems that are only ",(0,o.kt)("em",{parentName:"p"},"loosely coupled")," to other subsystems.")),(0,o.kt)("p",null,"For such a model to be modular, it should be decomposed into computational objects that model the actual objects in the system. Each computational object must have its own ",(0,o.kt)("em",{parentName:"p"},"local state variables")," describing the actual object\u2019s state. Since the states of objects in the system being modeled change over time, the state variables of the corresponding computational objects must also change. In particular, if we wish to model state variables by ordinary symbolic names in the programming language, then the language must provide an ",(0,o.kt)("em",{parentName:"p"},"assignment operator")," to enable us to change the value associated with a name."),(0,o.kt)("h3",{id:"local-state-variables"},"Local State Variables"),(0,o.kt)("p",null,"This uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"set!")," special form, whose syntax is"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"(set! <name> <new-value>)\n")),(0,o.kt)("p",null,"Here ",(0,o.kt)("inlineCode",{parentName:"p"},"<name>")," is a symbol and ",(0,o.kt)("inlineCode",{parentName:"p"},"<new-value>")," is any expression. ",(0,o.kt)("inlineCode",{parentName:"p"},"set!")," changes ",(0,o.kt)("inlineCode",{parentName:"p"},"<name>")," so that its value is the result obtained by evaluating ",(0,o.kt)("inlineCode",{parentName:"p"},"<new-value>"),"."),(0,o.kt)("p",null,"In general, evaluating the expression:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"(begin <exp1> <exp2> ... <expk>)\n")),(0,o.kt)("p",null,"causes the expressions ",(0,o.kt)("inlineCode",{parentName:"p"},"\u27e8exp1\u27e9")," through ",(0,o.kt)("inlineCode",{parentName:"p"},"\u27e8expk\u27e9")," to be evaluated in sequence and the value of the final expression ",(0,o.kt)("inlineCode",{parentName:"p"},"\u27e8expk\u27e9")," to be returned as the value ofe the entire ",(0,o.kt)("inlineCode",{parentName:"p"},"begin")," form."),(0,o.kt)("p",null,"Combining ",(0,o.kt)("inlineCode",{parentName:"p"},"set!")," with local variable is the general programming technique for constructing computational objects with local state. (It's a closure.)"),(0,o.kt)("h3",{id:"the-benefits-of-introducing-assignment"},"The Benefits of Introducing Assignment"),(0,o.kt)("p",null,"Viewing systems as collections of objects with ",(0,o.kt)("em",{parentName:"p"},"local state")," is a powerful technique for maintaining a ",(0,o.kt)("em",{parentName:"p"},"modular design"),"."),(0,o.kt)("p",null,"From the point of view of one part of a complex process, the other parts appear to change with time. They have hidden time-varying local state. If we wish to write computer programs whose structure reflects this decomposition, we make computational objects whose behavior changes with time. We model state with local state variables, and we model the changes of state with assignments to those variables."),(0,o.kt)("p",null,"By introducing assignment and the technique of hiding state in local variables, we are able to structure systems in a more modular fashion than if all state had to be manipulated explicitly, by passing additional parameters."),(0,o.kt)("h3",{id:"the-costs-of-introducing-assignment"},"The Costs of Introducing Assignment"),(0,o.kt)("p",null,"The advantage of local state assignment when modeling objects comes with a price: the program can no longer be interpreted in terms of the substitution model of procedure application. Moreover, no simple model with ",(0,o.kt)("em",{parentName:"p"},"nice")," mathematical properties can be an adequate framework for dealing with objects and assignment in programming languages."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Programming without any use of assignments, as we did throughout the first two chapters of this book, is accordingly known as ",(0,o.kt)("em",{parentName:"p"},"functional programming"),". (No more assignment after first assignment?)")),(0,o.kt)("p",null,"Without assignment, that symbols in the language could be viewed as essentially names for values."),(0,o.kt)("p",null,"But, if the value of a variable can change, a variable can no longer be simply a symbol. Now a variable somehow refers to a place where a value can be stored, and the value stored at this place can change."),(0,o.kt)("h4",{id:"sameness-and-change"},"Sameness and change"),(0,o.kt)("p",null,"In general, we can determine that two apparently identical objects are indeed ",(0,o.kt)("em",{parentName:"p"},"the same one")," only by modifying one object and then observing whether the other object has changed in the same way."),(0,o.kt)("p",null,"In general, so long as we never modify data objects, we can regard a compound data object to be precisely the totality of its pieces. But, this view is no longer valid in the presence of change, where a compound data object has an ",(0,o.kt)("em",{parentName:"p"},"identity")," that is something different from the pieces of which it is composed. An object is still ",(0,o.kt)("em",{parentName:"p"},"the same")," object even if some of its pieces change; conversely, two different objects can both exist with the same state information."),(0,o.kt)("h4",{id:"pitfalls-of-imperative-programming"},"Pitfalls of imperative programming"),(0,o.kt)("p",null,"In contrast to ",(0,o.kt)("em",{parentName:"p"},"functional programming"),", programming that makes extensive use of assignment is known as ",(0,o.kt)("em",{parentName:"p"},"imperative programming"),"."),(0,o.kt)("p",null,"In general, programming with assignment forces us to carefully consider the relative orders of the assignments to make sure that each statement is using the correct version of the variables that have been changed."),(0,o.kt)("h2",{id:"the-environment-model-of-evaluation"},"The Environment Model of Evaluation"),(0,o.kt)("p",null,"In our new model of evaluation, these places in which values can be stored will be maintained in structures called ",(0,o.kt)("em",{parentName:"p"},"environments"),"."),(0,o.kt)("p",null,"An environment is a sequence of ",(0,o.kt)("em",{parentName:"p"},"frames"),". Each frame is a table (possibly empty) of bindings, which associate ",(0,o.kt)("em",{parentName:"p"},"variable names")," with their corresponding ",(0,o.kt)("em",{parentName:"p"},"values"),". (A single frame may contain at most one binding for any variable, no more than two variables use same name). Each frame also has a pointer to its enclosing environment, unless the frame is considered to be ",(0,o.kt)("em",{parentName:"p"},"global"),". The ",(0,o.kt)("em",{parentName:"p"},"value of a variable")," with respect to an environment is the value given by the binding of the variable in the first frame in the environment that contains a binding for that variable. If no frame in the sequence specifies a binding for the variable, then the variable is said to be ",(0,o.kt)("em",{parentName:"p"},"unbound")," in the environment."),(0,o.kt)("p",null,"The environment is crucial to the evaluation process, because it determines the ",(0,o.kt)("em",{parentName:"p"},"context")," in which an expression should be evaluated."),(0,o.kt)("p",null,"Rather, an expression acquires a meaning only with respect to some environment in which it is evaluated. Thus, in our model of evaluation we will always speak of evaluating an expression with respect to some environment."),(0,o.kt)("h3",{id:"the-rules-for-evaluation"},"The Rules for Evaluation"),(0,o.kt)("p",null,"In the environment model of evaluation, a procedure is always a pair consisting of some code and a pointer to an environment."),(0,o.kt)("p",null,"Procedures are created in one way only: by evaluating a \u03bb-expression. This produces a procedure whose code is obtained from the text of the \u03bb-expression and whose environment is the environment in which the \u03bb-expression was evaluated to produce the procedure."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"(define (square x)\n  (* x x))\n\n// syntax sugar, equivalent \u03bb-expression\n(define square\n  (lambda (x) (* x x)))\n")),(0,o.kt)("p",null,"The environment model of procedure application can be summarized by two rules:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"A procedure object is applied to a set of arguments by constructing a frame, binding the formal parameters of the procedure to the arguments of the call, and then evaluating the body of the procedure in the context of the new environment constructed. The new frame has as its enclosing environment the environment part of the procedure object being applied.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"A procedure is created by evaluating a \u03bb-expression relative to a given environment. The resulting procedure object is a pair consisting of the text of the \u03bb-expression and a pointer to the environment in which the procedure was created."))),(0,o.kt)("h3",{id:"internal-definitions"},"Internal Definitions"),(0,o.kt)("p",null,"Environment model helps us to understanding internal definitions inside procedures."),(0,o.kt)("p",null,"The environment model thus explains the two key properties that make local procedure definitions a useful technique for modularizing programs:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"The names of the local procedures do not interfere with names external to the enclosing procedure, because the local procedure names will be bound in the frame that the procedure creates when it is run, rather than being bound in the global environment.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"The local procedures can access the arguments of the enclosing procedure, simply by using parameter names as free variables. This is because the body of the local procedure is evaluated in an environment that is subordinate to the evaluation environment for the enclosing procedure."))),(0,o.kt)("h2",{id:"modeling-with-mutable-data"},"Modeling with Mutable Data"),(0,o.kt)("p",null,"In order to model compound objects with changing state, we will design data abstractions to include, in addition to selectors and constructors, operations called ",(0,o.kt)("em",{parentName:"p"},"mutators"),", which modify data objects."),(0,o.kt)("p",null,"Data objects for which mutators are defined are known as ",(0,o.kt)("em",{parentName:"p"},"mutable data"),"."),(0,o.kt)("h3",{id:"sharing-and-identity"},"Sharing and identity"),(0,o.kt)("p",null,"One object might be ",(0,o.kt)("em",{parentName:"p"},"shared")," among different data objects."),(0,o.kt)("p",null,"Sharing can be dangerous since modifications made to structures will also affect other structures that happen to share the modified parts."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Data consistency, Mutation Exclusive,")),(0,o.kt)("h3",{id:"mutation-is-just-assignment"},"Mutation is just assignment"),(0,o.kt)("p",null,"We can implement mutable data objects as procedures using assignment and local state."),(0,o.kt)("h3",{id:"representing-queues"},"Representing Queues"),(0,o.kt)("p",null,"A ",(0,o.kt)("em",{parentName:"p"},"queue")," is a sequence in which items are inserted at one end (called the ",(0,o.kt)("em",{parentName:"p"},"rear")," of the queue) and deleted from the other end (the ",(0,o.kt)("em",{parentName:"p"},"front"),")."),(0,o.kt)("p",null,"Because items are always removed in the order in which they are inserted, a queue is sometimes called a ",(0,o.kt)("em",{parentName:"p"},"FIFO (first in, first out)")," buffer."),(0,o.kt)("p",null,"In terms of data abstraction, we can regard a queue as defined by the following set of operations:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"a constructor: (make-queue) returns an empty queue (a queue containing no items).")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"two selectors:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"(empty-queue? \u27e8queue\u27e9)")," tests if the queue is empty."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"(front-queue \u27e8queue\u27e9)")," returns the object at the front of the queue, signaling an error if the queue is empty; it does not modify the queue."))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"two mutators:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"(insert-queue! \u27e8queue\u27e9 \u27e8item\u27e9)")," inserts the item at the rear of the queue and returns the modified queue as its value.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"(delete-queue! \u27e8queue\u27e9)")," removes the item at the front of the queue and returns the modified queue as its value, signaling an error if the queue is empty before the deletion."))))),(0,o.kt)("h3",{id:"propagation-of-constraints"},"Propagation of Constraints"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"It's a big issue in computer science.")),(0,o.kt)("p",null,"Computer programs are traditionally organized as one-directional computations, which perform operations on prespecified arguments to produce desired outputs."),(0,o.kt)("p",null,"On the other hand, we often model systems in terms of relations among quantities."),(0,o.kt)("p",null,"We sketch the design of a language that enables us to work in terms of relations themselves. The primitive elements of the language are ",(0,o.kt)("em",{parentName:"p"},"primitive constraints"),", which state that certain relations hold between quantities."),(0,o.kt)("p",null,"The language provides a means of combining primitive constraints in order to express more complex relations. We combine constraints by constructing ",(0,o.kt)("em",{parentName:"p"},"constraint networks"),", in which constraints are joined by ",(0,o.kt)("em",{parentName:"p"},"connectors"),". A connector is an object that ",(0,o.kt)("em",{parentName:"p"},"holds")," a value that may participate in one or more constraints."),(0,o.kt)("p",null,"Computation by such a network proceeds as follows: When a connector is given a value (by the user or by a constraint box to which it is linked), it awakens all of its associated constraints (except for the constraint that just awakened it) to inform them that it has a value. Each awakened constraint box then polls its connectors to see if there is enough information to determine a value for a connector. If so, the box sets that connector, which then awakens all of its associated constraints, and so on."),(0,o.kt)("h3",{id:"implementing-the-constraint-system"},"Implementing the constraint system"),(0,o.kt)("p",null,"The constraint system is implemented via procedural objects with local state. Although the primitive objects of the constraint system are somewhat more complex, the overall system is simpler, since there is no concern about agendas and logic delays."),(0,o.kt)("p",null,"The basic operations on connectors are the following:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"(has-value? \u27e8connector\u27e9)")," tells whether the connector has a value.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"(get-value \u27e8connector\u27e9)")," returns the connector\u2019s current value.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"(set-value! \u27e8connector\u27e9 \u27e8new-value\u27e9 \u27e8informant\u27e9)")," indicates that the informant is requesting the connector to set its value to the new value.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"(forget-value! \u27e8connector\u27e9 \u27e8retractor\u27e9)")," tells the connector that the retractor is requesting it to forget its value.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"(connect \u27e8connector\u27e9 \u27e8new-constraint\u27e9)")," tells the connector to participate in the new constraint."))),(0,o.kt)("p",null,"The connectors communicate with the constraints by means of the procedures ",(0,o.kt)("inlineCode",{parentName:"p"},"inform-about-value"),", which tells the given constraint that the connector has a value, and ",(0,o.kt)("inlineCode",{parentName:"p"},"inform-about-no-value"),", which tells the constraint that the connector has lost its value."),(0,o.kt)("h3",{id:"representing-connectors"},"Representing connectors"),(0,o.kt)("p",null,"A connector is represented as a procedural object with local state variables ",(0,o.kt)("em",{parentName:"p"},"value"),", the current value of the connector; ",(0,o.kt)("em",{parentName:"p"},"informant"),", the object that set the connector\u2019s value; and ",(0,o.kt)("em",{parentName:"p"},"constraints"),", a list of the constraints in which the connector participates."),(0,o.kt)("h2",{id:"concurrency-time-is-of-the-essence"},"Concurrency: Time Is of the Essence"),(0,o.kt)("p",null,"The central issue lurking beneath the complexity of state, sameness, and change is that by introducing assignment we are forced to admit ",(0,o.kt)("em",{parentName:"p"},"time")," into our computational models. The result of evaluating an expression depends not only on the expression itself, but also on whether the evaluation occurs before or after these assignment moments. Building models in terms of computational objects with local state forces us to confront time as an essential concept in programming."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Before we introduced assignment, all our programs were time-agnostic, in the sense that any expression that has a value always has the same value.")),(0,o.kt)("p",null,"In real world, objects do not change one at a time in sequence. Rather, we perceive them as acting ",(0,o.kt)("em",{parentName:"p"},"concurrently")," -- all at once."),(0,o.kt)("p",null,"So it is often natural to model systems as collections of computational processes that execute concurrently."),(0,o.kt)("p",null,"Even if the programs are to be executed on a sequential computer, the practice of writing programs as if they were to be executed concurrently forces the programmer to avoid inessential timing constraints and thus makes programs more modular."),(0,o.kt)("p",null,"In addition to making programs more modular, concurrent computation can provide a speed advantage over sequential computation."),(0,o.kt)("h3",{id:"the-nature-of-time-in-concurrent-systems"},"The Nature of Time in Concurrent Systems"),(0,o.kt)("p",null,"Several processes may share a common state variable. It's more complicated when more than one process may be trying to manipulate the shared state at the same time."),(0,o.kt)("h4",{id:"correct-behavior-of-concurrent-programs"},"Correct behavior of concurrent programs"),(0,o.kt)("p",null,"With concurrent processes we must be especially careful about assignments, because we may not be able to control the order of the assignments made by the different processes. To make concurrent programs behave correctly, we may have to place some restrictions on concurrent execution."),(0,o.kt)("p",null,"One possible restriction on concurrency would stipulate that no two operations that change any shared state variables can occur at the same time."),(0,o.kt)("p",null,"A less stringent restriction on concurrency would ensure that a concurrent system produces the same result as if the processes had run sequentially in some order. There are two important aspects to this requirement. First, it does not require the processes to actually run sequentially, but only to produce results that are the same as if they had run sequentially. Second, there may be more than one possible ",(0,o.kt)("em",{parentName:"p"},"correct")," result produced by a concurrent program, because we require only that the result be the same as for ",(0,o.kt)("em",{parentName:"p"},"some")," sequential order."),(0,o.kt)("h3",{id:"mechanisms-for-controlling-concurrency"},"Mechanisms for Controlling Concurrency"),(0,o.kt)("p",null,"A more practical approach to the design of concurrent systems is to devise general mechanisms that allow us to constrain the interleaving of concurrent processes so that we can be sure that the program behavior is correct."),(0,o.kt)("h4",{id:"serializing-access-to-shared-state"},"Serializing access to shared state"),(0,o.kt)("p",null,"Serialization implements the following idea: Processes will execute concurrently, but there will be certain collections of procedures that cannot be executed concurrently. More precisely, serialization creates distinguished sets of procedures such that only one execution of a procedure in each serialized set is permitted to happen at a time. If some procedure in the set is being executed, then a process that attempts to execute any procedure in the set will be forced to wait until the first execution has finished."),(0,o.kt)("h4",{id:"complexity-of-using-multiple-shared-resources"},"Complexity of using multiple shared resources"),(0,o.kt)("p",null,"Serializers provide a powerful abstraction that helps isolate the complexities of concurrent programs so that they can be dealt with carefully and (hopefully) correctly. However, while using serializers is relatively straightforward when there is only a single shared resource, concurrent programming can be treacherously difficult when there are multiple shared resources."),(0,o.kt)("h4",{id:"implementing-serializers"},"Implementing serializers"),(0,o.kt)("p",null,"We implement serializers in terms of a more primitive synchronization mechanism called a ",(0,o.kt)("em",{parentName:"p"},"mutex"),"."),(0,o.kt)("p",null,"A mutex is an object that supports two operations: the mutex can be ",(0,o.kt)("em",{parentName:"p"},"acquired"),", and the mutex can be ",(0,o.kt)("em",{parentName:"p"},"released"),"."),(0,o.kt)("p",null,"Once a mutex has been acquired, no other acquire operations on that mutex may proceed until the mutex is released."),(0,o.kt)("p",null,"The mutex is a mutable object that can hold teh value true or false. When the value is false, the mutex is available to be acquired. When the value is true, the mutex is unavailable, and any process that attempts to acquire the mutex must wait."),(0,o.kt)("h2",{id:"streams"},"Streams"),(0,o.kt)("p",null,"From an abstract point of view, a ",(0,o.kt)("em",{parentName:"p"},"stream")," is simply a sequence of data objects."),(0,o.kt)("p",null,"Stream processing lets us model systems that have state without ever using assignment or mutable data."),(0,o.kt)("h3",{id:"streams-are-delayed-lists"},"Streams Are Delayed Lists"),(0,o.kt)("p",null,"Streams are a clever idea that allows one to use sequence manipulations without incurring the costs of manipulating sequences as lists. With streams we can achieve the best of both worlds: We can formulate programs elegantly as sequence manipulations, while attaining the efficiency of incremental computation."),(0,o.kt)("p",null,"The basic idea is to arrange to construct a stream only partially, and to pass the partial construction to the program that consumes the stream. If the consumer attempts to access a part of the stream that has not yet been constructed, the stream will automatically construct just enough more of itself to produce the required part, thus preserving the illusion that the entire stream exists."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Generator is one implementation of streams.")),(0,o.kt)("p",null,"The implementation of streams will be based on a special form called ",(0,o.kt)("em",{parentName:"p"},"delay"),". Evaluating ",(0,o.kt)("inlineCode",{parentName:"p"},"(delay \u27e8exp\u27e9)")," does not evaluate the expression ",(0,o.kt)("inlineCode",{parentName:"p"},"\u27e8exp\u27e9"),", but rather returns a so-called ",(0,o.kt)("em",{parentName:"p"},"delayed object"),", which we can think of as a ",(0,o.kt)("em",{parentName:"p"},"promise")," to evaluate ",(0,o.kt)("inlineCode",{parentName:"p"},"\u27e8exp\u27e9")," at some future time. As a companion to delay, there is a procedure called ",(0,o.kt)("em",{parentName:"p"},"force")," that takes a delayed object as argument and performs the evaluation\u2014in effect, forcing the ",(0,o.kt)("em",{parentName:"p"},"delay")," to fulfill its promise."),(0,o.kt)("p",null,"In general, we can think of delayed evaluation as ",(0,o.kt)("em",{parentName:"p"},"demand-driven")," programming, whereby each stage in the stream process is activated only enough to satisfy the next stage. What we have done is to decouple the actual order of events in the computation from the apparent structure of our procedures. We write procedures as if the streams existed ",(0,o.kt)("em",{parentName:"p"},"all at once")," when, in reality, the computation is performed incrementally, as in traditional programming styles."),(0,o.kt)("h3",{id:"infinite-streams"},"Infinite Streams"),(0,o.kt)("p",null,"We can user streams to represent sequences that are infinitely long. But, in any given time we can examine only a finite portion of it."),(0,o.kt)("h4",{id:"defining-streams-implicitly"},"Defining streams implicitly"),(0,o.kt)("p",null,"An alternative way to specify streams is to take advantage of delayed evaluation to define streams implicitly."),(0,o.kt)("h3",{id:"exploiting-the-stream-paradigm"},"Exploiting the Stream Paradigm"),(0,o.kt)("p",null,"The stream approach can be illuminating because it allows us to build systems with different module boundaries than systems organized around assignment to state variables. This makes it convenient to combine and compare components of state from different moments."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"For example, we can think of an entire time series/signal as a focus of interest, rather than the values of the state variables at individual moments.")),(0,o.kt)("p",null,"To handle infinite streams, we need to devise an order of combination that ensures that every element will eventually be reached if we let the program run long enough."),(0,o.kt)("h3",{id:"streams-and-delayed-evaluation"},"Streams and Delayed Evaluation"),(0,o.kt)("p",null,"In general, ",(0,o.kt)("em",{parentName:"p"},"delay")," is crucial for using streams to model signal-processing systems that contain loops. Without ",(0,o.kt)("em",{parentName:"p"},"delay"),", our models would have to be formulated so that the inputs to any signal-processing component would be fully evaluated before the output could be produced. This would outlaw loops."),(0,o.kt)("h3",{id:"modularity-of-functional-programs-and-modularity-of-objects"},"Modularity of Functional Programs and Modularity of Objects"),(0,o.kt)("p",null,"One of the major benefits of introducing assignment is that we can increase the modularity of the systems by encapsulating, or ",(0,o.kt)("em",{parentName:"p"},"hiding"),", parts of the state of a large system within local variables. Stream models can provide an equivalent modularity without the use of assignment."),(0,o.kt)("h4",{id:"a-functional-programming-view-of-time"},"A functional-programming view of time"),(0,o.kt)("p",null,"We introduced assignment and mutable objects to provide a mechanism for modular construction of programs that model systems with state. We constructed computational objects with local state variables and used assignment to modify these variables. We modeled the temporal behavior of the objects in the world by the temporal behavior of the corresponding computational objects."),(0,o.kt)("p",null,"Now we have seen that streams provide an alternative way to model objects with local state. We can model a changing quantity, such as the local state of some object, using a stream that represents the time history of successive states. In essence, we represent time explicitly, using streams, so that we decouple time in our simulated world from the sequence of events that take place during evaluation. Indeed, because of the presence of delay there may be little relation between simulated time in the model, and the order of events during the evaluation."),(0,o.kt)("p",null,"From the point of view of one part of a complex process, the other parts appear to change with time. They have hidden time-varying local state. If we wish to write programs that model this kind of natural decomposition in our world (as we see it from our viewpoint as a part of that world) with structures in our computer, we make computational objects that are not functional\u2014they must change with time. We model state with local state variables, and we model the changes of state with assignments to those variables. By doing this we make the time of execution of a computation model time in the world we are part of, and thus we get \u201cobjects\u201d in our computer."),(0,o.kt)("p",null,"Modeling with mutable objects raise thorny problems of constraining the order of events and of synchronizing multiple processes. The possibility of avoiding these problems has stimulated the development of ",(0,o.kt)("em",{parentName:"p"},"functional programming")," languages, which do not include any provision for assignment or mutable data."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The functional approach is extremely attractive for dealing with concurrent systems.")),(0,o.kt)("p",null,"There are some time-related problems creeping into functional models as well. One particularly troublesome area arises when we wish to design interactive systems, especially ones that model interactions between independent entities. The trouble comes with the notion of ",(0,o.kt)("em",{parentName:"p"},"merge"),". Such a merge is implemented to interleave these inputs in some way that is constrained by ",(0,o.kt)("em",{parentName:"p"},"real time")," as perceived by mutations. Technically, ",(0,o.kt)("em",{parentName:"p"},"merge")," is a relation rather than a function."),(0,o.kt)("p",null,"The need to introduce explicit synchronization to ensure a ",(0,o.kt)("em",{parentName:"p"},"correct")," order of events in concurrent processing of objects with state. Thus, in an attempt to support the functional style, the need to merge inputs from different agents reintroduces the same problems that functional style was meant to eliminate."))}u.isMDXComponent=!0}}]);