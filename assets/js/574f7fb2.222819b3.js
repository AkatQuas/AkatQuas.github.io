"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5015],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var i=r.createContext({}),f=function(e){var n=r.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=f(e.components);return r.createElement(i.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},_=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,i=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=f(t),_=a,m=c["".concat(i,".").concat(_)]||c[_]||d[_]||s;return t?r.createElement(m,l(l({ref:n},p),{},{components:t})):r.createElement(m,l({ref:n},p))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,l=new Array(s);l[0]=_;var o={};for(var i in n)hasOwnProperty.call(n,i)&&(o[i]=n[i]);o.originalType=e,o[c]="string"==typeof e?e:a,l[1]=o;for(var f=2;f<s;f++)l[f]=t[f];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}_.displayName="MDXCreateElement"},35733:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>f});var r=t(87462),a=(t(67294),t(3905));const s={title:"12",tags:["lisp","interpreter"]},l=void 0,o={unversionedId:"lisp-interpreter-in-py/chapter-12",id:"lisp-interpreter-in-py/chapter-12",title:"12",description:"In this article we are going to take a few more baby steps and learn how to parse Pascal procedure declarations.",source:"@site/docs/lisp-interpreter-in-py/chapter-12.md",sourceDirName:"lisp-interpreter-in-py",slug:"/lisp-interpreter-in-py/chapter-12",permalink:"/docs/lisp-interpreter-in-py/chapter-12",draft:!1,tags:[{label:"lisp",permalink:"/docs/tags/lisp"},{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",frontMatter:{title:"12",tags:["lisp","interpreter"]},sidebar:"tutorialSidebar",previous:{title:"11",permalink:"/docs/lisp-interpreter-in-py/chapter-11"},next:{title:"13 Introduction to semantic analysis",permalink:"/docs/lisp-interpreter-in-py/chapter-13"}},i={},f=[],p={toc:f};function c(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"In this article we are going to take a few more baby steps and learn how to parse Pascal procedure declarations."),(0,a.kt)("p",null,"A ",(0,a.kt)("em",{parentName:"p"},"procedure declaration")," is a language construct that defines an identifier (a procedure name) and associates it with a block of Pascal code."),(0,a.kt)("p",null,"Before we dive in, a few words about Pascal procedures and their declarations:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Pascal procedures don't have return statements. They exit when they reach the end of their corresponding block.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Pascal procedures can be nested within each other.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"For simplicity reasons, procedure declarations in this article won't have any formal parameters."))),(0,a.kt)("p",null,"This is our test program for today:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"PROGRAM Part12;\nVAR\n    a : INTEGER;\n\nPROCEDURE P1;\nVAR\n    a : REAL;\n    k : INTEGER;\n\n    PROCEDURE P2;\n    VAR\n        a,z : INTEGER;\n\n    BEGIN {P2}\n        z := 777;\n    END; {P2}\n\nBEGIN {P1}\n\nEND; {P1}\n\nBEGIN {Part12}\n    a := 10;\nEND. {Part12}\n")),(0,a.kt)("p",null,"As can be seen above, we have defined two procedures (",(0,a.kt)("em",{parentName:"p"},"P1")," and ",(0,a.kt)("em",{parentName:"p"},"P2"),") and ",(0,a.kt)("em",{parentName:"p"},"P2")," is nested within ",(0,a.kt)("em",{parentName:"p"},"P1"),". In the code above, I used comments with a procedure's name to clearly indicate where the body of every procedure begins and where it ends."),(0,a.kt)("p",null,"Our objective for today is pretty clear: learn how to parse a code like that."),(0,a.kt)("p",null,"First, we need to make some changes to our grammar to add procedure declarations."),(0,a.kt)("img",{src:"./imgs/lsbasi_part12_grammar.png",alt:""}),(0,a.kt)("p",null,"The procedure declaration sub-rule consists fo the reserved keyword PROCEDURE followed by an identifier (a procedure name), followed by a semicolon, which in turn followed by a ",(0,a.kt)("em",{parentName:"p"},"block")," rule, which is terminated by a semicolon."),(0,a.kt)("p",null,"Here is the updated syntax diagram for the ",(0,a.kt)("em",{parentName:"p"},"declarations")," rule:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part12_syntaxdiagram.png",alt:""}),(0,a.kt)("p",null,"From the grammar and the diagram above you can see that you can have as many procedure declarations on the same level as you want. For example, in the code snippet below we define two procedure declarations, ",(0,a.kt)("em",{parentName:"p"},"P1")," and ",(0,a.kt)("em",{parentName:"p"},"P1A"),", on the same level:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"PROGRAM Test;\nVAR\n   a : INTEGER;\n\nPROCEDURE P1;\nBEGIN {P1}\n\nEND;  {P1}\n\nPROCEDURE P1A;\nBEGIN {P1A}\n\nEND;  {P1A}\n\nBEGIN {Test}\n   a := 10;\nEND.  {Test}\n")),(0,a.kt)("p",null,"The diagram and the grammar rule above also indicate that procedure declarations can be nested because the ",(0,a.kt)("em",{parentName:"p"},"procedure declaration")," sub-rule references the ",(0,a.kt)("em",{parentName:"p"},"block")," rule which contains the ",(0,a.kt)("em",{parentName:"p"},"declarations")," rule, which in turn contains the ",(0,a.kt)("em",{parentName:"p"},"procedure declaration")," sub-rule."),(0,a.kt)("p",null,"Now let's focus on the interpreter components that need to be updated to support procedure declarations."),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Updating the Lexer")),(0,a.kt)("p",null,"Add a new token named PROCEDURE:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"PROCEDURE = 'PROCEDURE'\n")),(0,a.kt)("p",null,"Add 'PROCEDURE' to the reserved keywords."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"RESERVED_KEYWORDS = {\n    'PROGRAM': Token('PROGRAM', 'PROGRAM'),\n    'VAR': Token('VAR', 'VAR'),\n    'DIV': Token('INTEGER_DIV', 'DIV'),\n    'INTEGER': Token('INTEGER', 'INTEGER'),\n    'REAL': Token('REAL', 'REAL'),\n    'BEGIN': Token('BEGIN', 'BEGIN'),\n    'END': Token('END', 'END'),\n    'PROCEDURE': Token('PROCEDURE', 'PROCEDURE'),\n}\n")),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Updating the Parser")),(0,a.kt)("p",null,"Here is a summary of the parser changes:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"New ",(0,a.kt)("em",{parentName:"p"},"ProcedureDecl")," AST node"),(0,a.kt)("p",{parentName:"li"},"The ",(0,a.kt)("em",{parentName:"p"},"ProcedureDecl")," AST node represents a ",(0,a.kt)("em",{parentName:"p"},"procedure declaration"),". The class constructor takes as parameters the name of the procedure and the AST node of the block of code that the procedure's name refers to."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-python"},"class ProcedureDecl(AST):\n    def __init__(self, proc_name, block_node):\n        self.proc_name = proc_name\n        self.block_node = block_node\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Update to the parser's ",(0,a.kt)("em",{parentName:"p"},"declarations")," method to support procedure declarations"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-python"},'def declarations(self):\n    """declarations : VAR (variable_declaration SEMI)+\n                    | (PROCEDURE ID SEMI block SEMI)*\n                    | empty\n    """\n    declarations = []\n\n    if self.current_token.type == VAR:\n        self.eat(VAR)\n        while self.current_token.type == ID:\n            var_decl = self.variable_declaration()\n            declarations.extend(var_decl)\n            self.eat(SEMI)\n\n    while self.current_token.type == PROCEDURE:\n        self.eat(PROCEDURE)\n        proc_name = self.current_token.value\n        self.eat(ID)\n        self.eat(SEMI)\n        block_node = self.block()\n        proc_decl = ProcedureDecl(proc_name, block_name)\n        declarations.append(proc_decl)\n        self.eat(SEMI)\n\n    return declarations\n')))),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Updating the SymbolTable builder")),(0,a.kt)("p",null,"Before we're ready to handle nested procedure scopes, we'll simply add an empty ",(0,a.kt)("em",{parentName:"p"},"visit_ProcedureDecl")," method to the ",(0,a.kt)("em",{parentName:"p"},"SymbolTreeBuilder")," AST visitor class."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def visit_ProcedureDecl(self, node):\n    pass\n")),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Updating the Interpreter")),(0,a.kt)("p",null,"We also need to add an empty ",(0,a.kt)("em",{parentName:"p"},"visit_ProcedureDecl")," method to the ",(0,a.kt)("em",{parentName:"p"},"Interpreter")," class, which will cause our interpreter to silently ignore all procedure declarations."),(0,a.kt)("p",null,"Next, dive deep into scopes."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Appendix")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"\"\"\" SPI - Simple Pascal Interpreter. Part 12.\"\"\"\n\nfrom collections import OrderedDict\n\n###############################################################################\n#                                                                             #\n#  LEXER                                                                      #\n#                                                                             #\n###############################################################################\n\n# Token types\n#\n# EOF (end-of-file) token is used to indicate that\n# there is no more input left for lexical analysis\nINTEGER = 'INTEGER'\nREAL = 'REAL'\nINTEGER_CONST = 'INTEGER_CONST'\nREAL_CONST = 'REAL_CONST'\nPLUS = 'PLUS'\nMINUS = 'MINUS'\nMUL = 'MUL'\nINTEGER_DIV = 'INTEGER_DIV'\nFLOAT_DIV = 'FLOAT_DIV'\nLPAREN = 'LPAREN'\nRPAREN = 'RPAREN'\nID = 'ID'\nASSIGN = 'ASSIGN'\nBEGIN = 'BEGIN'\nEND = 'END'\nSEMI = 'SEMI'\nDOT = 'DOT'\nPROGRAM = 'PROGRAM'\nVAR = 'VAR'\nCOLON = 'COLON'\nCOMMA = 'COMMA'\nPROCEDURE = 'PROCEDURE'\nEOF = 'EOF'\n\n\nclass Token(object):\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n\n    def __str__(self):\n        \"\"\"String representation of the class instance.\n\n        Examples:\n            Token(INTEGER, 3)\n            Token(PLUS, '+')\n            Token(MUL, '*')\n        \"\"\"\n        return 'Token({type}, {value})'.format(\n            type=self.type,\n            value=repr(self.value)\n        )\n\n    def __repr__(self):\n        return self.__str__()\n\n\nRESERVED_KEYWORDS = {\n    'PROGRAM': Token(PROGRAM, 'PROGRAM'),\n    'PROCEDURE': Token(PROCEDURE, 'PROCEDURE'),\n    'VAR': Token(VAR, 'VAR'),\n    'DIV': Token(INTEGER_DIV, 'DIV'),\n    'INTEGER': Token(INTEGER, 'INTEGER'),\n    'REAL': Token(REAL, 'REAL'),\n    'BEGIN': Token(BEGIN, 'BEGIN'),\n    'END': Token(END, 'END'),\n}\n\n\nclass Lexer(object):\n    def __init__(self, text):\n        # client string input, e.g. \"4 + 2 * 3 - 6 / 2\"\n        self.text = text\n        # self.pos is an index into self.text\n        self.pos = 0\n        self.current_char = self.text[self.pos]\n\n    def error(self):\n        raise Exception('Invalid character')\n\n    def advance(self):\n        \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\"\n        self.pos += 1\n        if self.pos > len(self.text) - 1:\n            self.current_char = None  # Indicates end of input\n        else:\n            self.current_char = self.text[self.pos]\n\n    def peek(self):\n        peek_pos = self.pos + 1\n        if peek_pos > len(self.text) - 1:\n            return None\n        else:\n            return self.text[peek_pos]\n\n    def skip_whitespace(self):\n        while self.current_char is not None and self.current_char.isspace():\n            self.advance()\n\n    def skip_comment(self):\n        while self.current_char != '}':\n            self.advance()\n        self.advance()  # the closing curly brace\n\n    def number(self):\n        \"\"\"Return a (multidigit) integer or float consumed from the input.\"\"\"\n        result = ''\n        while self.current_char is not None and self.current_char.isdigit():\n            result += self.current_char\n            self.advance()\n\n        if self.current_char == '.':\n            result += self.current_char\n            self.advance()\n\n            while (\n                self.current_char is not None and\n                self.current_char.isdigit()\n            ):\n                result += self.current_char\n                self.advance()\n\n            token = Token(REAL_CONST, float(result))\n        else:\n            token = Token(INTEGER_CONST, int(result))\n\n        return token\n\n    def _id(self):\n        \"\"\"Handle identifiers and reserved keywords\"\"\"\n        result = ''\n        while self.current_char is not None and self.current_char.isalnum():\n            result += self.current_char\n            self.advance()\n\n        token = RESERVED_KEYWORDS.get(result, Token(ID, result))\n        return token\n\n    def get_next_token(self):\n        \"\"\"Lexical analyzer (also known as scanner or tokenizer)\n\n        This method is responsible for breaking a sentence\n        apart into tokens. One token at a time.\n        \"\"\"\n        while self.current_char is not None:\n\n            if self.current_char.isspace():\n                self.skip_whitespace()\n                continue\n\n            if self.current_char == '{':\n                self.advance()\n                self.skip_comment()\n                continue\n\n            if self.current_char.isalpha():\n                return self._id()\n\n            if self.current_char.isdigit():\n                return self.number()\n\n            if self.current_char == ':' and self.peek() == '=':\n                self.advance()\n                self.advance()\n                return Token(ASSIGN, ':=')\n\n            if self.current_char == ';':\n                self.advance()\n                return Token(SEMI, ';')\n\n            if self.current_char == ':':\n                self.advance()\n                return Token(COLON, ':')\n\n            if self.current_char == ',':\n                self.advance()\n                return Token(COMMA, ',')\n\n            if self.current_char == '+':\n                self.advance()\n                return Token(PLUS, '+')\n\n            if self.current_char == '-':\n                self.advance()\n                return Token(MINUS, '-')\n\n            if self.current_char == '*':\n                self.advance()\n                return Token(MUL, '*')\n\n            if self.current_char == '/':\n                self.advance()\n                return Token(FLOAT_DIV, '/')\n\n            if self.current_char == '(':\n                self.advance()\n                return Token(LPAREN, '(')\n\n            if self.current_char == ')':\n                self.advance()\n                return Token(RPAREN, ')')\n\n            if self.current_char == '.':\n                self.advance()\n                return Token(DOT, '.')\n\n            self.error()\n\n        return Token(EOF, None)\n\n\n###############################################################################\n#                                                                             #\n#  PARSER                                                                     #\n#                                                                             #\n###############################################################################\nclass AST(object):\n    pass\n\n\nclass BinOp(AST):\n    def __init__(self, left, op, right):\n        self.left = left\n        self.token = self.op = op\n        self.right = right\n\n\nclass Num(AST):\n    def __init__(self, token):\n        self.token = token\n        self.value = token.value\n\n\nclass UnaryOp(AST):\n    def __init__(self, op, expr):\n        self.token = self.op = op\n        self.expr = expr\n\n\nclass Compound(AST):\n    \"\"\"Represents a 'BEGIN ... END' block\"\"\"\n\n    def __init__(self):\n        self.children = []\n\n\nclass Assign(AST):\n    def __init__(self, left, op, right):\n        self.left = left\n        self.token = self.op = op\n        self.right = right\n\n\nclass Var(AST):\n    \"\"\"The Var node is constructed out of ID token.\"\"\"\n\n    def __init__(self, token):\n        self.token = token\n        self.value = token.value\n\n\nclass NoOp(AST):\n    pass\n\n\nclass Program(AST):\n    def __init__(self, name, block):\n        self.name = name\n        self.block = block\n\n\nclass Block(AST):\n    def __init__(self, declarations, compound_statement):\n        self.declarations = declarations\n        self.compound_statement = compound_statement\n\n\nclass VarDecl(AST):\n    def __init__(self, var_node, type_node):\n        self.var_node = var_node\n        self.type_node = type_node\n\n\nclass Type(AST):\n    def __init__(self, token):\n        self.token = token\n        self.value = token.value\n\n\nclass ProcedureDecl(AST):\n    def __init__(self, proc_name, block_node):\n        self.proc_name = proc_name\n        self.block_node = block_node\n\n\nclass Parser(object):\n    def __init__(self, lexer):\n        self.lexer = lexer\n        # set current token to the first token taken from the input\n        self.current_token = self.lexer.get_next_token()\n\n    def error(self):\n        raise Exception('Invalid syntax')\n\n    def eat(self, token_type):\n        # compare the current token type with the passed token\n        # type and if they match then \"eat\" the current token\n        # and assign the next token to the self.current_token,\n        # otherwise raise an exception.\n        if self.current_token.type == token_type:\n            self.current_token = self.lexer.get_next_token()\n        else:\n            self.error()\n\n    def program(self):\n        \"\"\"program : PROGRAM variable SEMI block DOT\"\"\"\n        self.eat(PROGRAM)\n        var_node = self.variable()\n        prog_name = var_node.value\n        self.eat(SEMI)\n        block_node = self.block()\n        program_node = Program(prog_name, block_node)\n        self.eat(DOT)\n        return program_node\n\n    def block(self):\n        \"\"\"block : declarations compound_statement\"\"\"\n        declaration_nodes = self.declarations()\n        compound_statement_node = self.compound_statement()\n        node = Block(declaration_nodes, compound_statement_node)\n        return node\n\n    def declarations(self):\n        \"\"\"declarations : VAR (variable_declaration SEMI)+\n                        | (PROCEDURE ID SEMI block SEMI)*\n                        | empty\n        \"\"\"\n        declarations = []\n        if self.current_token.type == VAR:\n            self.eat(VAR)\n            while self.current_token.type == ID:\n                var_decl = self.variable_declaration()\n                declarations.extend(var_decl)\n                self.eat(SEMI)\n\n        while self.current_token.type == PROCEDURE:\n            self.eat(PROCEDURE)\n            proc_name = self.current_token.value\n            self.eat(ID)\n            self.eat(SEMI)\n            block_node = self.block()\n            proc_decl = ProcedureDecl(proc_name, block_node)\n            declarations.append(proc_decl)\n            self.eat(SEMI)\n\n        return declarations\n\n    def variable_declaration(self):\n        \"\"\"variable_declaration : ID (COMMA ID)* COLON type_spec\"\"\"\n        var_nodes = [Var(self.current_token)]  # first ID\n        self.eat(ID)\n\n        while self.current_token.type == COMMA:\n            self.eat(COMMA)\n            var_nodes.append(Var(self.current_token))\n            self.eat(ID)\n\n        self.eat(COLON)\n\n        type_node = self.type_spec()\n        var_declarations = [\n            VarDecl(var_node, type_node) for var_node in var_nodes\n        ]\n        return var_declarations\n\n    def type_spec(self):\n        \"\"\"type_spec : INTEGER\n                     | REAL\n        \"\"\"\n        token = self.current_token\n        if self.current_token.type == INTEGER:\n            self.eat(INTEGER)\n        else:\n            self.eat(REAL)\n        node = Type(token)\n        return node\n\n    def compound_statement(self):\n        \"\"\"\n        compound_statement: BEGIN statement_list END\n        \"\"\"\n        self.eat(BEGIN)\n        nodes = self.statement_list()\n        self.eat(END)\n\n        root = Compound()\n        for node in nodes:\n            root.children.append(node)\n\n        return root\n\n    def statement_list(self):\n        \"\"\"\n        statement_list : statement\n                       | statement SEMI statement_list\n        \"\"\"\n        node = self.statement()\n\n        results = [node]\n\n        while self.current_token.type == SEMI:\n            self.eat(SEMI)\n            results.append(self.statement())\n\n        return results\n\n    def statement(self):\n        \"\"\"\n        statement : compound_statement\n                  | assignment_statement\n                  | empty\n        \"\"\"\n        if self.current_token.type == BEGIN:\n            node = self.compound_statement()\n        elif self.current_token.type == ID:\n            node = self.assignment_statement()\n        else:\n            node = self.empty()\n        return node\n\n    def assignment_statement(self):\n        \"\"\"\n        assignment_statement : variable ASSIGN expr\n        \"\"\"\n        left = self.variable()\n        token = self.current_token\n        self.eat(ASSIGN)\n        right = self.expr()\n        node = Assign(left, token, right)\n        return node\n\n    def variable(self):\n        \"\"\"\n        variable : ID\n        \"\"\"\n        node = Var(self.current_token)\n        self.eat(ID)\n        return node\n\n    def empty(self):\n        \"\"\"An empty production\"\"\"\n        return NoOp()\n\n    def expr(self):\n        \"\"\"\n        expr : term ((PLUS | MINUS) term)*\n        \"\"\"\n        node = self.term()\n\n        while self.current_token.type in (PLUS, MINUS):\n            token = self.current_token\n            if token.type == PLUS:\n                self.eat(PLUS)\n            elif token.type == MINUS:\n                self.eat(MINUS)\n\n            node = BinOp(left=node, op=token, right=self.term())\n\n        return node\n\n    def term(self):\n        \"\"\"term : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*\"\"\"\n        node = self.factor()\n\n        while self.current_token.type in (MUL, INTEGER_DIV, FLOAT_DIV):\n            token = self.current_token\n            if token.type == MUL:\n                self.eat(MUL)\n            elif token.type == INTEGER_DIV:\n                self.eat(INTEGER_DIV)\n            elif token.type == FLOAT_DIV:\n                self.eat(FLOAT_DIV)\n\n            node = BinOp(left=node, op=token, right=self.factor())\n\n        return node\n\n    def factor(self):\n        \"\"\"factor : PLUS factor\n                  | MINUS factor\n                  | INTEGER_CONST\n                  | REAL_CONST\n                  | LPAREN expr RPAREN\n                  | variable\n        \"\"\"\n        token = self.current_token\n        if token.type == PLUS:\n            self.eat(PLUS)\n            node = UnaryOp(token, self.factor())\n            return node\n        elif token.type == MINUS:\n            self.eat(MINUS)\n            node = UnaryOp(token, self.factor())\n            return node\n        elif token.type == INTEGER_CONST:\n            self.eat(INTEGER_CONST)\n            return Num(token)\n        elif token.type == REAL_CONST:\n            self.eat(REAL_CONST)\n            return Num(token)\n        elif token.type == LPAREN:\n            self.eat(LPAREN)\n            node = self.expr()\n            self.eat(RPAREN)\n            return node\n        else:\n            node = self.variable()\n            return node\n\n    def parse(self):\n        \"\"\"\n        program : PROGRAM variable SEMI block DOT\n\n        block : declarations compound_statement\n\n        declarations : VAR (variable_declaration SEMI)+\n                     | (PROCEDURE ID SEMI block SEMI)*\n                     | empty\n\n        variable_declaration : ID (COMMA ID)* COLON type_spec\n\n        type_spec : INTEGER\n\n        compound_statement : BEGIN statement_list END\n\n        statement_list : statement\n                       | statement SEMI statement_list\n\n        statement : compound_statement\n                  | assignment_statement\n                  | empty\n\n        assignment_statement : variable ASSIGN expr\n\n        empty :\n\n        expr : term ((PLUS | MINUS) term)*\n\n        term : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*\n\n        factor : PLUS factor\n               | MINUS factor\n               | INTEGER_CONST\n               | REAL_CONST\n               | LPAREN expr RPAREN\n               | variable\n\n        variable: ID\n        \"\"\"\n        node = self.program()\n        if self.current_token.type != EOF:\n            self.error()\n\n        return node\n\n\n###############################################################################\n#                                                                             #\n#  AST visitors (walkers)                                                     #\n#                                                                             #\n###############################################################################\n\nclass NodeVisitor(object):\n    def visit(self, node):\n        method_name = 'visit_' + type(node).__name__\n        visitor = getattr(self, method_name, self.generic_visit)\n        return visitor(node)\n\n    def generic_visit(self, node):\n        raise Exception('No visit_{} method'.format(type(node).__name__))\n\n\n###############################################################################\n#                                                                             #\n#  SYMBOLS and SYMBOL TABLE                                                   #\n#                                                                             #\n###############################################################################\n\nclass Symbol(object):\n    def __init__(self, name, type=None):\n        self.name = name\n        self.type = type\n\n\nclass VarSymbol(Symbol):\n    def __init__(self, name, type):\n        super().__init__(name, type)\n\n    def __str__(self):\n        return '<{name}:{type}>'.format(name=self.name, type=self.type)\n\n    __repr__ = __str__\n\n\nclass BuiltinTypeSymbol(Symbol):\n    def __init__(self, name):\n        super().__init__(name)\n\n    def __str__(self):\n        return self.name\n\n    __repr__ = __str__\n\n\nclass SymbolTable(object):\n    def __init__(self):\n        self._symbols = OrderedDict()\n        self._init_builtins()\n\n    def _init_builtins(self):\n        self.define(BuiltinTypeSymbol('INTEGER'))\n        self.define(BuiltinTypeSymbol('REAL'))\n\n    def __str__(self):\n        return 'Symbols: {symbols}'.format(\n            symbols=[value for value in self._symbols.values()]\n        )\n\n    __repr__ = __str__\n\n    def define(self, symbol):\n        print('Define: %s' % symbol)\n        self._symbols[symbol.name] = symbol\n\n    def lookup(self, name):\n        print('Lookup: %s' % name)\n        symbol = self._symbols.get(name)\n        # 'symbol' is either an instance of the Symbol class or 'None'\n        return symbol\n\n\nclass SymbolTableBuilder(NodeVisitor):\n    def __init__(self):\n        self.symtab = SymbolTable()\n\n    def visit_Block(self, node):\n        for declaration in node.declarations:\n            self.visit(declaration)\n        self.visit(node.compound_statement)\n\n    def visit_Program(self, node):\n        self.visit(node.block)\n\n    def visit_BinOp(self, node):\n        self.visit(node.left)\n        self.visit(node.right)\n\n    def visit_Num(self, node):\n        pass\n\n    def visit_UnaryOp(self, node):\n        self.visit(node.expr)\n\n    def visit_Compound(self, node):\n        for child in node.children:\n            self.visit(child)\n\n    def visit_NoOp(self, node):\n        pass\n\n    def visit_VarDecl(self, node):\n        type_name = node.type_node.value\n        type_symbol = self.symtab.lookup(type_name)\n        var_name = node.var_node.value\n        var_symbol = VarSymbol(var_name, type_symbol)\n        self.symtab.define(var_symbol)\n\n    def visit_Assign(self, node):\n        var_name = node.left.value\n        var_symbol = self.symtab.lookup(var_name)\n        if var_symbol is None:\n            raise NameError(repr(var_name))\n\n        self.visit(node.right)\n\n    def visit_Var(self, node):\n        var_name = node.value\n        var_symbol = self.symtab.lookup(var_name)\n\n        if var_symbol is None:\n            raise NameError(repr(var_name))\n\n    def visit_ProcedureDecl(self, node):\n        pass\n\n\n###############################################################################\n#                                                                             #\n#  INTERPRETER                                                                #\n#                                                                             #\n###############################################################################\n\nclass Interpreter(NodeVisitor):\n    def __init__(self, tree):\n        self.tree = tree\n        self.GLOBAL_MEMORY = OrderedDict()\n\n    def visit_Program(self, node):\n        self.visit(node.block)\n\n    def visit_Block(self, node):\n        for declaration in node.declarations:\n            self.visit(declaration)\n        self.visit(node.compound_statement)\n\n    def visit_VarDecl(self, node):\n        pass\n\n    def visit_Type(self, node):\n        pass\n\n    def visit_BinOp(self, node):\n        if node.op.type == PLUS:\n            return self.visit(node.left) + self.visit(node.right)\n        elif node.op.type == MINUS:\n            return self.visit(node.left) - self.visit(node.right)\n        elif node.op.type == MUL:\n            return self.visit(node.left) * self.visit(node.right)\n        elif node.op.type == INTEGER_DIV:\n            return self.visit(node.left) // self.visit(node.right)\n        elif node.op.type == FLOAT_DIV:\n            return float(self.visit(node.left)) / float(self.visit(node.right))\n\n    def visit_Num(self, node):\n        return node.value\n\n    def visit_UnaryOp(self, node):\n        op = node.op.type\n        if op == PLUS:\n            return +self.visit(node.expr)\n        elif op == MINUS:\n            return -self.visit(node.expr)\n\n    def visit_Compound(self, node):\n        for child in node.children:\n            self.visit(child)\n\n    def visit_Assign(self, node):\n        var_name = node.left.value\n        var_value = self.visit(node.right)\n        self.GLOBAL_MEMORY[var_name] = var_value\n\n    def visit_Var(self, node):\n        var_name = node.value\n        var_value = self.GLOBAL_MEMORY.get(var_name)\n        return var_value\n\n    def visit_NoOp(self, node):\n        pass\n\n    def visit_ProcedureDecl(self, node):\n        pass\n\n    def interpret(self):\n        tree = self.tree\n        if tree is None:\n            return ''\n        return self.visit(tree)\n\n\ndef main():\n    import sys\n    text = open(sys.argv[1], 'r').read()\n\n    lexer = Lexer(text)\n    parser = Parser(lexer)\n    tree = parser.parse()\n    symtab_builder = SymbolTableBuilder()\n    symtab_builder.visit(tree)\n    print('-----')\n    print('Symbol Table Contents:')\n    print(symtab_builder.symtab)\n\n    interpreter = Interpreter(tree)\n    result = interpreter.interpret()\n    print('-----')\n    print('Run-time GLOBAL_MEMORY contents:')\n    for k, v in sorted(interpreter.GLOBAL_MEMORY.items()):\n        print('%s = %s' % (k, v))\n\n\nif __name__ == '__main__':\n    main()\n\n")))}c.isMDXComponent=!0}}]);