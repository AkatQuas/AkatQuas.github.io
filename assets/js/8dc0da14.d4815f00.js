"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4364],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var o=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,m=a(e,["components","mdxType","originalType","parentName"]),c=p(n),h=i,d=c["".concat(l,".").concat(h)]||c[h]||u[h]||s;return n?o.createElement(d,r(r({ref:t},m),{},{components:n})):o.createElement(d,r({ref:t},m))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=n.length,r=new Array(s);r[0]=h;var a={};for(var l in t)hasOwnProperty.call(t,l)&&(a[l]=t[l]);a.originalType=e,a[c]="string"==typeof e?e:i,r[1]=a;for(var p=2;p<s;p++)r[p]=n[p];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},18353:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>a,toc:()=>p});var o=n(87462),i=(n(67294),n(3905));const s={title:"Depth in Event loop",categories:["programming language","javascript"],tags:["event loop","nodejs"]},r=void 0,a={permalink:"/blog/2019/12/11/depth-in-event-loop",source:"@site/blog/2019-12-11-depth-in-event-loop.md",title:"Depth in Event loop",description:"For those JavaScript programmers, event loop is an important concept, inevitably.",date:"2019-12-11T00:00:00.000Z",formattedDate:"December 11, 2019",tags:[{label:"event loop",permalink:"/blog/tags/event-loop"},{label:"nodejs",permalink:"/blog/tags/nodejs"}],readingTime:8.07,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Depth in Event loop",categories:["programming language","javascript"],tags:["event loop","nodejs"]},prevItem:{title:"Redux \u6e90\u7801\u8bfb\u540e\u611f",permalink:"/blog/2020/02/10/redux-source-code-impression"},nextItem:{title:"Is it possible to break a promise chain?",permalink:"/blog/2019/11/30/promise-interception"}},l={authorsImageUrls:[]},p=[{value:"Browser",id:"browser",level:2},{value:"Node.js",id:"nodejs",level:2},{value:"Microtasks",id:"microtasks",level:3},{value:"Timers phase",id:"timers-phase",level:3},{value:"Pending phase",id:"pending-phase",level:3},{value:"Idle and Prepare phase",id:"idle-and-prepare-phase",level:3},{value:"Poll phase",id:"poll-phase",level:3},{value:"Check phase",id:"check-phase",level:3},{value:"Close phase",id:"close-phase",level:3},{value:"Example",id:"example",level:2},{value:"EventEmitter",id:"eventemitter",level:2},{value:"In the end",id:"in-the-end",level:2}],m={toc:p};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"For those JavaScript programmers, event loop is an important concept, inevitably."),(0,i.kt)("p",null,"Literally, event loop is what JavaScript uses to implement non-blocking execution. Understanding how the event loops works internally would benefit you a lot when programming in JavaScript."),(0,i.kt)("p",null,"There are two major environments JavaScript runs in: ",(0,i.kt)("a",{parentName:"p",href:"#browser"},"browser")," and ",(0,i.kt)("a",{parentName:"p",href:"#node.js"},"Node.js"),"."),(0,i.kt)("h2",{id:"browser"},"Browser"),(0,i.kt)("p",null,"As mentioned in the book ",(0,i.kt)("a",{parentName:"p",href:"https://www.manning.com/books/secrets-of-the-javascript-ninja-second-edition"},"Secrets.of.the.JavaScript.Ninja.2nd.Edition"),":"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note the difference between handling the macrotask and microtask queues: In a single loop iteration, one macrotask at most is processed (others are left waiting in the queue), whereas all microtasks are processed.")),(0,i.kt)("p",null,"Here comes the first question: why only one marcotask is executed in each iteration?"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model"},"HTML standards")," says the reason."),(0,i.kt)("p",null,"According to the description, in each iteration, only one task, aka macrotask, is taken from task queue, is executed, while the microtask queue is flushed to empty. After flushing, there's a phase that the browser would evaluate the necessity to re-render the UI."),(0,i.kt)("p",null,"Here is how the flow works:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Engine starts:\n\n    Evaluate mainline JavaScript Code\n\n    Registering callbacks, timers, etc\n\nFirst loop:\n\n    take one MacroTask from task queue\n\n    flush MicroTasks\n\n    optional UI -rendering\n\nNext loop:\n\n    take one MacroTask from task queue\n\n    flush MicroTasks\n\n    optional UI-rendering\n\nNext loop:\n\n    take one MacroTask from task queue\n\n    flush MicroTasks\n\n    optional UI-rendering\n\nNext loop:\n   ...\n")),(0,i.kt)("p",null,"This loop will continue to the end of the browser page lifetime."),(0,i.kt)("p",null,"To verify the above loop execution, here are two example snippets;"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"// you can just run these code in the console (press F12 please).\nconsole.info('MANILINE> START');\nsetTimeout(() => {\n  console.info('MACRO> setTimeout.1');\n\n  Promise.resolve()\n    .then(() => {\n      console.info('MICRO> setTimeout.1.promise.1');\n\n      Promise.resolve().then(() => {\n        console.info('MICRO> setTimeout.1.promise.inner.1');\n        Promise.resolve().then(() =>\n          console.info('MICRO> setTimeout.1.promise.inner.1.inner')\n        );\n      });\n      Promise.resolve().then(() =>\n        console.info('MICRO> setTimeout.1.promise.inner.2')\n      );\n    })\n    .then(() => {\n      console.info('MICRO> setTimeout.1.promise.1.then');\n    })\n    .then(() => {\n      console.info('MICRO> setTimeout.1.promise.1.then.then');\n    });\n}, 0);\n\nsetTimeout(() => {\n  console.info('MACRO> setTimeout.2');\n\n  Promise.resolve().then(() => console.info('MICRO> setTimeout.2.promise.1'));\n  Promise.resolve().then(() => console.info('MICRO> setTimeout.2.promise.2'));\n}, 0);\n\nsetTimeout(() => console.info('MACRO> setTimeout.3'), 0);\n\nconsole.info('MAINLINE> END');\n")),(0,i.kt)("p",null,"If you open a new tab, press F12, copy and run the above code, here comes the output."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"MANILINE> START\nMAINLINE> END\n        # this line is empty\nMACRO> setTimeout.1\nMICRO> setTimeout.1.promise.1\nMICRO> setTimeout.1.promise.inner.1\nMICRO> setTimeout.1.promise.inner.2\nMICRO> setTimeout.1.promise.1.then\nMICRO> setTimeout.1.promise.inner.1.inner\nMICRO> setTimeout.1.promise.1.then.then\nMACRO> setTimeout.2\nMICRO> setTimeout.2.promise.1\nMICRO> setTimeout.2.promise.2\nMACRO> setTimeout.3\n")),(0,i.kt)("p",null,"As we can clearly see the execution flow."),(0,i.kt)("details",null,(0,i.kt)("summary",null," And another example is actually an html file that you need to load from the browser at the very beginning. The code would run as expected also. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html"},"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n    <title>Event loop</title>\n  </head>\n\n  <body>\n    <div>Division 1</div>\n    <script>\n      console.info('MAINLINE> script.1 START');\n      setTimeout(() => {\n        Promise.resolve().then(() => {\n          console.info('MICRO> script.1.timeout.1.promise');\n        });\n        console.info('MACRO> script.1.timeout.1');\n      });\n      setTimeout(() => {\n        console.info('MACRO> script.1.timeout.2');\n      });\n      console.info('MAINLINE> script.1 END');\n    <\/script>\n    <div>Divison 2</div>\n    <script>\n      console.info('MAINLINE> script.2 START');\n      setTimeout(() => {\n        Promise.resolve().then(() => {\n          console.info('MICRO> script.2.timeout.1.promise');\n        });\n        console.info('MACRO> script.2.timeout.1');\n      });\n      setTimeout(() => {\n        console.info('MACRO> script.2.timeout.2');\n      });\n      Promise.resolve().then(() => {\n        console.info('MAINLINE> promise');\n      });\n      console.info('MAINLINE> script.2 END');\n    <\/script>\n    <p>The correct logging order in console is</p>\n    <ol>\n      <li>MAINLINE> script.1 START</li>\n      <li>MAINLINE> script.1 END</li>\n      <li>MAINLINE> script.2 START</li>\n      <li>MAINLINE> script.2 END</li>\n      <li>MAINLINE> promise</li>\n      <li>MACRO> script.1.timeout.1</li>\n      <li>MICRO> script.1.timeout.1.promise</li>\n      <li>MACRO> script.1.timeout.2</li>\n      <li>MACRO> script.2.timeout.1</li>\n      <li>MICRO> script.2.timeout.1.promise</li>\n      <li>MACRO> script.2.timeout.2</li>\n    </ol>\n  </body>\n</html>\n"))),(0,i.kt)("h2",{id:"nodejs"},"Node.js"),(0,i.kt)("p",null,"Event loop is a bit different running in Node.js environment."),(0,i.kt)("p",null,"Though the ",(0,i.kt)("a",{parentName:"p",href:"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#event-loop-explained"},"official document")," illustrates something on the event loop, I think the ",(0,i.kt)("a",{parentName:"p",href:"https://developer.ibm.com/tutorials/learn-nodejs-the-event-loop/#why-you-need-to-understand-the-event-loop"},"tutorial from IBM")," is better."),(0,i.kt)("a",{id:"event-loop-node"}),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://developer.ibm.com/developer/tutorials/learn-nodejs-the-event-loop/images/figure-1.png",alt:null})),(0,i.kt)("p",null,"Before diving into the execution flow, we have some basic glossaries to clarify."),(0,i.kt)("h3",{id:"microtasks"},"Microtasks"),(0,i.kt)("p",null,"Microtasks execute immediately ",(0,i.kt)("em",{parentName:"p"},"following mainline")," and ",(0,i.kt)("em",{parentName:"p"},"after every phase")," of the event loop."),(0,i.kt)("p",null,"Microtasks are callbacks form ",(0,i.kt)("inlineCode",{parentName:"p"},"process.nextTick()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"then()")," handlers for Promises. (",(0,i.kt)("inlineCode",{parentName:"p"},"process.nextTick()")," has higher priority to ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise"),".)"),(0,i.kt)("h3",{id:"timers-phase"},"Timers phase"),(0,i.kt)("p",null,"Timers have two categories: ",(0,i.kt)("a",{parentName:"p",href:"https://nodejs.org/dist/latest-v12.x/docs/api/timers.html#timers_class_immediate"},"Immediate")," and ",(0,i.kt)("a",{parentName:"p",href:"https://nodejs.org/dist/latest-v12.x/docs/api/timers.html#timers_class_timeout"},"Timeout"),"."),(0,i.kt)("p",null,"An ",(0,i.kt)("em",{parentName:"p"},"immediate")," timer is a Node object that runs immediately during the next Check phase."),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"timeout timer")," is a Node object that runs a callback as soon as possible after the timer expires."),(0,i.kt)("p",null,"Once the timer expires, the callback is invoked during the next Timers phase of the event loop."),(0,i.kt)("p",null,"There are two types of Timeout timers: ",(0,i.kt)("em",{parentName:"p"},"Interval")," and ",(0,i.kt)("em",{parentName:"p"},"Timeout"),"."),(0,i.kt)("p",null,"When there are no more expired timer callbacks to run, the event loop runs any microtasks."),(0,i.kt)("p",null,"After running microtasks, the event loop moves to the Pending phase."),(0,i.kt)("h3",{id:"pending-phase"},"Pending phase"),(0,i.kt)("p",null,"Certain system-level callback are executed during this phase. You don't really need to worry about this phase."),(0,i.kt)("h3",{id:"idle-and-prepare-phase"},"Idle and Prepare phase"),(0,i.kt)("p",null,"Apparently, this phase is \u201conly used internally\u201d. You don't really need to worry about this phase."),(0,i.kt)("h3",{id:"poll-phase"},"Poll phase"),(0,i.kt)("p",null,"I/O callbacks are executed during this phase."),(0,i.kt)("p",null,"Normally, if the poll queue is empty, it blocks and waits for any in-flight I/O operations to complete, then execute their callbacks right away."),(0,i.kt)("p",null,"However, if timers are scheduled the poll phase will end."),(0,i.kt)("p",null,"Any microtasks will be run as necessary, and the event loop proceeds to the check phase."),(0,i.kt)("h3",{id:"check-phase"},"Check phase"),(0,i.kt)("p",null,"This phase is a sort of \u201cpost I/O\u201d phase during which only ",(0,i.kt)("inlineCode",{parentName:"p"},"setImmediate()")," callbacks are executed. This allows you to run code that executes as soon as the poll phase becomes idle."),(0,i.kt)("p",null,"Once the check phase callback queue is empty, any microtasks run, and the event loop proceeds to the close phase."),(0,i.kt)("h3",{id:"close-phase"},"Close phase"),(0,i.kt)("p",null,"This phase is executed if a socket or handle is closed suddenly."),(0,i.kt)("h2",{id:"example"},"Example"),(0,i.kt)("p",null,"The following code should be run like ",(0,i.kt)("inlineCode",{parentName:"p"},"node <file>.js"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const fs = require('fs');\nconst EventEmitter = require('events').EventEmitter;\nconst ITERATIONS_MAX = 3;\nlet iteration = 0;\nconst event = new EventEmitter();\n\nconsole.info('MAINLINE> START');\n\nconsole.info('MAINLINE> Registering Event');\nevent.on('simple', (eventName, message, source, timestamp) => {\n  console.info(\n    'EVENTS> Received event: name \"%s\", message \"%s\", source \"%s\", timestamp %s',\n    eventName,\n    message,\n    source,\n    timestamp\n  );\n});\n\nconst hrtime = process.hrtime().join('.');\nevent.emit('simple', 'simpleEvent', 'Custom message', 'MAINLINE', hrtime);\n\nPromise.resolve().then(() => {\n  console.info('MAINLINE> promise.1');\n});\nprocess.nextTick(() => {\n  console.info('MAINLINE> process.nextTick');\n});\nPromise.resolve().then(() => {\n  console.info('MAINLINE> promise.2');\n});\nconst interval = setInterval(() => {\n  console.info('TIMERS PHASE> START: iteration %d: setInterval', iteration);\n  if (iteration >= ITERATIONS_MAX) {\n    console.info('TIMERS PHASE> Max interval count exceeded. Goodbye.');\n    clearInterval(interval);\n  } else {\n    {\n      const htime = process.hrtime().join('.');\n      event.emit(\n        'simple',\n        'simpleEvent',\n        'Custom message A from ' + iteration,\n        'setInterval.EventEmitter',\n        htime\n      );\n    }\n    setTimeout(\n      (ite) => {\n        console.info(\n          'TIMERS EXPIRED (from iteration %d)> setInterval.setTimeout',\n          ite\n        );\n        Promise.resolve().then(() => {\n          console.info(\n            'TIMERS PHASE MICROTASK> setInterval.setTimeout.promise 1'\n          );\n        });\n        process.nextTick(() => {\n          console.info(\n            'TIMERS PHASE MICROTASK> setInterval.setTimeout.process.nextTick'\n          );\n        });\n        Promise.resolve().then(() => {\n          console.info(\n            'TIMERS PHASE MICROTASK> setInterval.setTimeout.promise 2'\n          );\n        });\n      },\n      0,\n      iteration\n    );\n    fs.readdir('./', (err, files) => {\n      if (err) throw err;\n      console.info('POLL PHASE> fs.readdir() callback');\n      process.nextTick(() => {\n        console.info(\n          'POLL PHASE MICROTASK> setInterval.fs.readdir.process.nextTick'\n        );\n      });\n    });\n    setImmediate(() => {\n      console.info('CHECK PHASE> setInterval.setImmediate');\n      process.nextTick(() => {\n        console.info(\n          'CHECK PHASE MICROTASK> setInterval.setImmediate.process.nextTick'\n        );\n      });\n    });\n    {\n      const htime = process.hrtime().join('.');\n      event.emit(\n        'simple',\n        'simpleEvent',\n        'Custom message B from ' + iteration,\n        'setInterval.EventEmitter',\n        htime\n      );\n    }\n\n    process.nextTick((ite) => {\n      console.info(\n        'TIMER PHASE MICROTASK> iteration %d, setInterval.process.nextTick',\n        ite\n      );\n    }, iteration);\n  }\n  console.info('TIMERS PHASE> END: iteration %d: setInterval', iteration);\n\n  iteration++;\n}, 0);\nconsole.info('MAINLINE> END');\n")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"After running the above scripts, the terminal would print like (click to open the output result): "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-txt"},'MAINLINE> START\nMAINLINE> Registering Event\nEVENTS> Received event: name "simpleEvent", message "Custom message", source "MAINLINE", timestamp 385796.462973198\nMAINLINE> END\nMAINLINE> process.nextTick\nMAINLINE> promise.1\nMAINLINE> promise.2\nTIMERS PHASE> START: iteration 0: setInterval\nEVENTS> Received event: name "simpleEvent", message "Custom message A from 0", source "setInterval.EventEmitter", timestamp 385796.464664300\nEVENTS> Received event: name "simpleEvent", message "Custom message B from 0", source "setInterval.EventEmitter", timestamp 385796.465196848\nTIMERS PHASE> END: iteration 0: setInterval\nTIMER PHASE MICROTASK> iteration 0, setInterval.process.nextTick\nPOLL PHASE> fs.readdir() callback\nPOLL PHASE MICROTASK> setInterval.fs.readdir.process.nextTick\nCHECK PHASE> setInterval.setImmediate\nCHECK PHASE MICROTASK> setInterval.setImmediate.process.nextTick\nTIMERS EXPIRED (from iteration 0)> setInterval.setTimeout\nTIMERS PHASE MICROTASK> setInterval.setTimeout.process.nextTick\nTIMERS PHASE MICROTASK> setInterval.setTimeout.promise 1\nTIMERS PHASE MICROTASK> setInterval.setTimeout.promise 2\nTIMERS PHASE> START: iteration 1: setInterval\nEVENTS> Received event: name "simpleEvent", message "Custom message A from 1", source "setInterval.EventEmitter", timestamp 385796.466206990\nEVENTS> Received event: name "simpleEvent", message "Custom message B from 1", source "setInterval.EventEmitter", timestamp 385796.466439664\nTIMERS PHASE> END: iteration 1: setInterval\nTIMER PHASE MICROTASK> iteration 1, setInterval.process.nextTick\nPOLL PHASE> fs.readdir() callback\nPOLL PHASE MICROTASK> setInterval.fs.readdir.process.nextTick\nCHECK PHASE> setInterval.setImmediate\nCHECK PHASE MICROTASK> setInterval.setImmediate.process.nextTick\nTIMERS EXPIRED (from iteration 1)> setInterval.setTimeout\nTIMERS PHASE MICROTASK> setInterval.setTimeout.process.nextTick\nTIMERS PHASE MICROTASK> setInterval.setTimeout.promise 1\nTIMERS PHASE MICROTASK> setInterval.setTimeout.promise 2\nTIMERS PHASE> START: iteration 2: setInterval\nEVENTS> Received event: name "simpleEvent", message "Custom message A from 2", source "setInterval.EventEmitter", timestamp 385796.468226076\nEVENTS> Received event: name "simpleEvent", message "Custom message B from 2", source "setInterval.EventEmitter", timestamp 385796.468287021\nTIMERS PHASE> END: iteration 2: setInterval\nTIMER PHASE MICROTASK> iteration 2, setInterval.process.nextTick\nPOLL PHASE> fs.readdir() callback\nPOLL PHASE MICROTASK> setInterval.fs.readdir.process.nextTick\nCHECK PHASE> setInterval.setImmediate\nCHECK PHASE MICROTASK> setInterval.setImmediate.process.nextTick\nTIMERS EXPIRED (from iteration 2)> setInterval.setTimeout\nTIMERS PHASE MICROTASK> setInterval.setTimeout.process.nextTick\nTIMERS PHASE MICROTASK> setInterval.setTimeout.promise 1\nTIMERS PHASE MICROTASK> setInterval.setTimeout.promise 2\nTIMERS PHASE> START: iteration 3: setInterval\nTIMERS PHASE> Max interval count exceeded. Goodbye.\nTIMERS PHASE> END: iteration 3: setInterval\n'))),(0,i.kt)("p",null,"As we can see:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"First, mainline runs, followed by its microtask, (remember, ",(0,i.kt)("inlineCode",{parentName:"p"},"process.nextTick")," comes before ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise"),").")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Then, Timers phase and its microtask, (again, ",(0,i.kt)("inlineCode",{parentName:"p"},"process.nextTick")," comes before ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise"),").")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Then, Poll phase and its microtask.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Then, Check phase and its microtask.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Loop to the next Timers phase, and so on."))),(0,i.kt)("p",null,"You can check the ",(0,i.kt)("a",{parentName:"p",href:"#event-loop-node"},"illustration image")," again."),(0,i.kt)("h2",{id:"eventemitter"},"EventEmitter"),(0,i.kt)("p",null,"One more thing about the EventEmitter. We register a callback for some event, which would be called in the future, ",(0,i.kt)("em",{parentName:"p"},"asynchronously"),"."),(0,i.kt)("p",null,"When we make the specific event emitted, it will execute ",(0,i.kt)("em",{parentName:"p"},"synchronously")," at that emitting moment."),(0,i.kt)("h2",{id:"in-the-end"},"In the end"),(0,i.kt)("p",null,"Many efforts have been made to figure out it thoroughly. It's may be not easy to understand event loop in such a short article, you could read more if you do need a deeper understanding in event loop."),(0,i.kt)("p",null,"Hope this would help you in your JavaScript programming!"))}c.isMDXComponent=!0}}]);