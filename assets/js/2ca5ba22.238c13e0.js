"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4343],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},f=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),c=p(t),f=i,h=c["".concat(s,".").concat(f)]||c[f]||d[f]||o;return t?a.createElement(h,l(l({ref:n},u),{},{components:t})):a.createElement(h,l({ref:n},u))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,l=new Array(o);l[0]=f;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r[c]="string"==typeof e?e:i,l[1]=r;for(var p=2;p<o;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}f.displayName="MDXCreateElement"},62375:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>p});var a=t(87462),i=(t(67294),t(3905));const o={title:"13 Standard Library",tags:["lisp","interpreter"]},l=void 0,r={unversionedId:"lisp-interpreter-in-c/standard-library",id:"lisp-interpreter-in-c/standard-library",title:"13 Standard Library",description:"document",source:"@site/docs/lisp-interpreter-in-c/13-standard-library.md",sourceDirName:"lisp-interpreter-in-c",slug:"/lisp-interpreter-in-c/standard-library",permalink:"/docs/lisp-interpreter-in-c/standard-library",draft:!1,tags:[{label:"lisp",permalink:"/docs/tags/lisp"},{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",sidebarPosition:13,frontMatter:{title:"13 Standard Library",tags:["lisp","interpreter"]},sidebar:"tutorialSidebar",previous:{title:"12 Strings",permalink:"/docs/lisp-interpreter-in-c/strings"},next:{title:"Before start",permalink:"/docs/lisp-interpreter-in-py/chapter-00"}},s={},p=[{value:"Minimalism",id:"minimalism",level:2},{value:"Atoms",id:"atoms",level:2},{value:"Building Blocks",id:"building-blocks",level:2},{value:"Logical Operators",id:"logical-operators",level:2},{value:"Miscellaneous Functions",id:"miscellaneous-functions",level:2},{value:"List Functions",id:"list-functions",level:2},{value:"Conditional Functions",id:"conditional-functions",level:2}],u={toc:p};function c(e){let{components:n,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,o,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"http://www.buildyourownlisp.com/chapter15_standard_library"},"document")),(0,i.kt)("p",null,"A complete library code could be found ",(0,i.kt)("a",{target:"_blank",href:t(9607).Z},"here")),(0,i.kt)("h2",{id:"minimalism"},"Minimalism"),(0,i.kt)("p",null,"The Lisp we've built has been purposefully minimal. We've only added the fewest number of core structures and builtins. If we chose these carefully, as we did, then it should allow us to add in everything else required to the language."),(0,i.kt)("p",null,"The motivation behind minimalism is two-fold. The first advantage is that it makes the core language simple to debug and easy to learn. This is a great benefit to developers and users. Like ",(0,i.kt)("a",{parentName:"p",href:"http://en.wikipedia.org/wiki/Occam%27s_razor"},"Occam's Razor")," it is almost always better to trim away any waste if it results in an equally expressive language. The second reason is that having a small language is also aesthetically nicer. It is clever, interesting and fun to see how small we can make the core of a language, and still get something useful out of the other side. As hackers, which we should be by now, this is something we enjoy."),(0,i.kt)("h2",{id:"atoms"},"Atoms"),(0,i.kt)("p",null,"When dealing with conditionals we added no new boolean type to the language. Because fo this we didn't add ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," either. Instead, we just used numbers. Readability is still important though, so we can define some constants to represent these values."),(0,i.kt)("p",null,"On a similar note, many lisps use the word ",(0,i.kt)("inlineCode",{parentName:"p"},"nil")," to represent the empty list ",(0,i.kt)("inlineCode",{parentName:"p"},"{}"),". We can add this in too. These constants are sometimes called ",(0,i.kt)("strong",{parentName:"p"},"atoms")," because they are fundamental and constant."),(0,i.kt)("p",null,"The user is not forced to use these named constants, and can use numbers and empty lists instead as they like. This choice empowers users."),(0,i.kt)("h2",{id:"building-blocks"},"Building Blocks"),(0,i.kt)("p",null,"We've already come up with a number of cool functions. One of these is ",(0,i.kt)("inlineCode",{parentName:"p"},"fun")," function that allows us to declare functions in a neater way. We should definitely include this in our standard library. We also had the ",(0,i.kt)("inlineCode",{parentName:"p"},"unpack")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"pack")," functions. These too are going to be essential for users. We should include these along with their ",(0,i.kt)("inlineCode",{parentName:"p"},"curry")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"uncurry")," alias."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"; Fuction Definitions\n(def { fun } ( \\ {f b} {\n    def (head f) (\\ (tail f) b )\n}))\n\n; Unpack List for Function\n(fun { unpack f l } {\n    eval (join (list f) l)\n})\n\n; Pack List for Function\n(fun { pack f & xs } { f xs })\n\n; Curried and Uncurried calling\n(def { curry } unpack)\n(def { uncurry } pack)\n")),(0,i.kt)("p",null,"Say we want to do several things in order. One way we can do this is to put each thing to do as an argument to some function. We know that arguments are evaluated in order from left to right, which is essentially sequencing events. For functions such as ",(0,i.kt)("inlineCode",{parentName:"p"},"print")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"load")," we don't care much about what it evaluates to, but do care about the order in which it happens."),(0,i.kt)("p",null,"Therefore, we can create a ",(0,i.kt)("inlineCode",{parentName:"p"},"do")," function which evaluates a number of expressions in order and returns the last one. This relies on an the ",(0,i.kt)("inlineCode",{parentName:"p"},"last")," function, which returns the final element of a list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"; Perform Several things in Sequence\n(fun { do & l } {\n    if ( == l nil)\n    { nil }\n    { last l }\n})\n")),(0,i.kt)("p",null,"Sometimes we want to save results to local variables using the ",(0,i.kt)("inlineCode",{parentName:"p"},"=")," operator. When we're inside a function this will implicitly only save results locally, but sometimes we want to open up an even more local scope. For this we can create a function ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," which creates an empty function for code to take place in, and evaluates it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"; Open new scope\n(fun { let b } {\n    ((\\ {_} b) ())\n})\n")),(0,i.kt)("p",null,"We can use this in conjunction with ",(0,i.kt)("inlineCode",{parentName:"p"},"do")," to ensure that variables do not leak out of their scope."),(0,i.kt)("h2",{id:"logical-operators"},"Logical Operators"),(0,i.kt)("p",null,"We didn't define any logical operators such as ",(0,i.kt)("inlineCode",{parentName:"p"},"and")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"or")," in our language. This might be a good thing to add in later. For now, we can use arithmetic operators to emulate them. Think about how these functions work when encountering ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," for their various inputs."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"; Logical Functions\n(fun {not x} { - 1 x } )\n(fun { or x y } { + x y } )\n(fun { and x y } { * x y })\n")),(0,i.kt)("h2",{id:"miscellaneous-functions"},"Miscellaneous Functions"),(0,i.kt)("p",null,"Here are a couple of miscellaneous functions that don't really fit in anywhere. See if you can guess their intended functionality."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(fun { flip f a b } { f b a })\n(fun { ghost & xs } { eval xs })\n(fun { comp f g x } { f (g x) })\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"flip")," function takes a function ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," and two arguments ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),". It then applies ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," in the reversed order. This might be useful when we want a function to be ",(0,i.kt)("strong",{parentName:"p"},"partially evaluated"),". If we want to partially evaluate a function by only passing it in it",(0,i.kt)("inlineCode",{parentName:"p"},"s second argument we can use "),"flip` to give us a new function that takes the first two arguments in reversed order."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ghost")," function is kind of interesting. It simply takes in any number of arguments and evaluates them as if they were the expressions itself. So it just sits at the front of an expression like a ghost, not interacting with or changing the behaviour of the program at all."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"comp")," function is used to compose two functions. It takes as input ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),", and an argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),". It then applies this argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"g")," and applies the result again to ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),". This can be used to compose two functions together into a new function that applies both of them in series."),(0,i.kt)("h2",{id:"list-functions"},"List Functions"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"head")," function is used to get the first element of a list, but what it returns is still wrapped in the list. If we want to actually get the element out of this list we need to extract it somehow."),(0,i.kt)("p",null,"Single element lists evaluate to just that element, so we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"eval")," function to do this extraction. We can also define a couple of helper functions for aid extracting the firs, second and third elements of a list. We'll use these function more later."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"; First, Second, or Third Item in List\n(fun {fst l} { eval (head l) })\n(fun {snd l} { eval (head (tail l)) })\n(fun {trd l} { eval (head (tail (tail l))) })\n")),(0,i.kt)("p",null,"To find the length of a list we can recursive over it adding ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," to the length of the tail. To find the ",(0,i.kt)("inlineCode",{parentName:"p"},"nth")," element af a list we can perform the ",(0,i.kt)("inlineCode",{parentName:"p"},"tail")," operation and count down until we reach ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),". To get the last element of a list we can just access the element at the length minus one."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"; List Length\n(fun {len l} {\n    if (== l nil)\n    { 0 }\n    { + 1 (len (tail) l) }\n})\n\n; Nth item in List\n(fun {nth n l} {\n    if (== n 0)\n    { fst l }\n    { nth (- n 1) (tail l) }\n})\n\n; Last item in List\n(fun {last l} {nth (- (len l) 1) l})\n")),(0,i.kt)("p",null,"There are lots of other useful functions that follow this same pattern. We can define functions for taking and dropping the first so many elements of a list, or functions for checking if a value is an element of a list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"; Take N items\n(fun {take n l} {\n    if (== n 0)\n    {nil}\n    {join (head l) (take (- n 1) (tail l))}\n})\n\n; Drop N items\n(fun {drop n l} {\n    if (== n 0)\n    {l}\n    {drop (- n 1) (tail l)}\n})\n\n; Split at N\n(fun {split n l} {list (take n l) (drop n l)})\n\n; Element of List\n(fun {elem x l} {\n    if (== l nil)\n    {false}\n    {if (== x (fst l)) {true} {elem x (tail l)}}\n})\n")),(0,i.kt)("p",null,"For example, we may want a way we can perform some function on every element of a list. This is a function we can define called ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),". It takes as input some function, and some list. For each item in the list it applies ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," to that item and appends it back onto the front of the list. It then applies ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," to the tail of the list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"; Apply Function to List\n(fun {map f l} {\n    if (== l nil)\n    {nil}\n    {join (list (f (fst l))) (map f (tail l))}\n})\n")),(0,i.kt)("p",null,"An adaptation of this ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," is a ",(0,i.kt)("inlineCode",{parentName:"p"},"filter")," function which takes in some functional condition, and only includes items of a list which match that condition."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"; Apply Filter to List\n(fun {filter f l} {\n    if (== l nil)\n    {nil}\n    {join (if (f (fst l)) {head l} {nil}) (filter f (tail l))}\n})\n")),(0,i.kt)("h2",{id:"conditional-functions"},"Conditional Functions"),(0,i.kt)("p",null,"By defining the ",(0,i.kt)("inlineCode",{parentName:"p"},"fun")," function we've already shown how powerful the language is in its ability to define functions that look like new syntax. Another example of this is found in emulating the C ",(0,i.kt)("inlineCode",{parentName:"p"},"switch")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"case")," statements. In C these are built into the language, but for our ",(0,i.kt)("strong",{parentName:"p"},"LISP")," we can define them as part of a library."),(0,i.kt)("p",null,"We can define a function ",(0,i.kt)("inlineCode",{parentName:"p"},"select")," that takes in zero or more two-element lists as input. For each two element list in the arguments it first evaluates the first element of the pair. If this is true then it evaluates and returns the second item, otherwise it performs the same thing again on the rest of the list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'(fun {select & cs} {\n    if (== cs nil)\n    { error "No Selection Found"}\n    { if (fst (fst cs)) {snd (fst cs)} {unpack select (tail cs)}}\n})\n')),(0,i.kt)("p",null,"We can also define a function ",(0,i.kt)("inlineCode",{parentName:"p"},"otherwise")," to always evaluate to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),". This works a little like the ",(0,i.kt)("inlineCode",{parentName:"p"},"default")," keyword in C."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'; Default Case\n(def {otherwise} true)\n\n; Print Day of Month suffix\n(fun {month-day-suffix i} {\n    select\n    {(== i 0) "st"}\n    {(== i 1) "nd"}\n    {(== i 2) "rd"}\n    {otherwise "th"}\n})\n')),(0,i.kt)("p",null,"This is actually more powerful than the C ",(0,i.kt)("inlineCode",{parentName:"p"},"switch")," statement. In C rather than passing in conditions the input value is compared only for equality with a number of constant candidates. We can also define this function in our Lisp, where we compare a value to a number of candidates. In this function we take some value ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," followed by zero or more two-element lists again. If the first element in the two-element list is equal to ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),", the second element is evaluated, otherwise the process continues down the list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'(fun {case x & cs} {\n    if (== cs nil)\n    {error "No case Found"}\n    { if (== x (fst (fst cs))) {snd (fst cs)} {\n        unpack case(join (list x) (tail cs))}}\n})\n\n(fun {day-name x} {\n    case x\n    {0 "Monday"}\n    {1 "Tuesday"}\n    {2 "Wendesday"}\n    {3 "Thursday"}\n    {4 "Friday"}\n    {5 "Saturday"}\n    {6 "Sunday"}\n})\n')))}c.isMDXComponent=!0},9607:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/files/prelude-4d20c5ce8013ae885b0d737136c92af3.lspy"}}]);