"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8959],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>f});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=p(n),d=r,f=c["".concat(s,".").concat(d)]||c[d]||u[d]||i;return n?a.createElement(f,o(o({ref:t},m),{},{components:n})):a.createElement(f,o({ref:t},m))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3966:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const i={title:"ConfigMap and Secret",sidebar_position:10},o=void 0,l={unversionedId:"kubernetes/configmap-secret",id:"kubernetes/configmap-secret",title:"ConfigMap and Secret",description:"ConfigMap and Secret key examples",source:"@site/docs/kubernetes/configmap-secret.md",sourceDirName:"kubernetes",slug:"/kubernetes/configmap-secret",permalink:"/docs/kubernetes/configmap-secret",draft:!1,tags:[],version:"current",sidebarPosition:10,frontMatter:{title:"ConfigMap and Secret",sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"Deployments, Jobs, and DaemonSets",permalink:"/docs/kubernetes/workloads"},next:{title:"Storage and Running Stateful Applications",permalink:"/docs/kubernetes/pv-pvc"}},s={},p=[{value:"ConfigMaps",id:"configmaps",level:2},{value:"Secrets",id:"secrets",level:2}],m={toc:p};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"ConfigMap and Secret key examples")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Valid key name"),(0,r.kt)("th",{parentName:"tr",align:null},"Invalid key name"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},".auth_token"),(0,r.kt)("td",{parentName:"tr",align:null},"Token..properties")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Key.pem"),(0,r.kt)("td",{parentName:"tr",align:null},"auth\\ file.json")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"config_file"),(0,r.kt)("td",{parentName:"tr",align:null},"_","password.txt")))),(0,r.kt)("p",null,"ConfigMap data values are simple UTF-8 text specified directly in the manifest. As of Kubernetes 1.6, ConfigMaps are unable to store binary data."),(0,r.kt)("p",null,"Secret data values hold arbitrary data encoded using base64. The use of base64 encoding makes it possible to store binary data. This does, however, make it more difficult to manage secrets that are stored in YAML files as the base64-encoded value must be put in the YAML. Note that the maximum size for a ConfigMap or secret is 1 MB."),(0,r.kt)("h2",{id:"configmaps"},"ConfigMaps"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/configuration/configmap/"},"Kubernetes ConfigMaps"),"."),(0,r.kt)("p",null,"ConfigMaps are used to provide configuration information for workloads."),(0,r.kt)("p",null,"The key thing is that the ConfigMap is combined with the Pod right before it is run."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Create ConfigMap")),(0,r.kt)("p",null,"From command line:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cat my-config.txt\n\n# This is a sample config file that I might use to configure an application\nparameter1 = value1\nparameter2 = value2\n\n\nkubectl create configmap my-config \\\n  --from-file=my-config.txt \\\n  --from-literal=extra-param=extra-value \\\n  --from-literal=another-param=another-value\n")),(0,r.kt)("p",null,"Using manifest yaml file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\ndata:\n  another-param: another-value\n  extra-param: extra-value\n  my-config.txt: |\n    # This is a sample config file that I might use to configure an application\n    parameter1 = value1\n    parameter2 = value2\nkind: ConfigMap\nmetadata:\n  creationTimestamp: null\n  name: my-config\n  namespace: default\n  resourceVersion: '13556'\n  selfLink: /api/v1/namespaces/default/configmaps/my-config\n  uid: <configmap-uid>\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Using a ConfigMap")),(0,r.kt)("p",null,"A configMap volume!"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Filesystem"),(0,r.kt)("p",{parentName:"li"},"Mount a Configmap into a Pod. A file is created for each entry based on the key name. The contents of that file are set to the value.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Environment variable"),(0,r.kt)("p",{parentName:"li"},"Set the value of an environment variable dynamically.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Command-line argument"),(0,r.kt)("p",{parentName:"li"},"Create the command line for a container based on ConfigMap values dynamically."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Pod\nmetadata:\n  name: kuard-config\nspec:\n  containers:\n    - name: config-in-file\n      image: test-image\n      imagePullPolicy: Always\n      # command line arguments built upon environment variables\n      command:\n        - '/node'\n        - '$(EXTRA_PARAM)'\n      env:\n        # read value from configMap\n        - name: ANOTHER_PARAM\n          valueFrom:\n            configMapKeyRef:\n              name: my-config\n              key: another-param\n        # read value from configMap\n        - name: EXTRA_PARAM\n          valueFrom:\n            configMapKeyRef:\n              name: my-config\n              key: extra-param\n      volumeMounts:\n        # mount the configMap volume to container\n        - name: config-volume\n          mountPath: /config\n  volumes:\n    # this is a configMap volume\n    - name: config-volume\n      configMap:\n        name: my-config\n  restartPolicy: Never\n")),(0,r.kt)("h2",{id:"secrets"},"Secrets"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/configuration/secret/"},"Kubernetes Secrets"),"."),(0,r.kt)("p",null,"Secrets are similar to ConfigMaps but focused on making sensitive information available to the workload."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"By default, Kubernetes secrets are stored in plain text in the ",(0,r.kt)("inlineCode",{parentName:"p"},"etcd")," storage for the cluster.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Create Secrets")),(0,r.kt)("p",null,"From command line:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl create secret generic kuber-tls \\\n  --from-file=kuber.crt \\\n  --from-file=kuber.key\n")),(0,r.kt)("p",null,"Using manifest yaml file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Secret\nmetadata:\n  name: kuber-tls\ntype: kubernetes.io/tls\ndata:\n  # the data is abbreviated in this example\n  kuber.crt: |\n    MIIC2DCCAcCgAwIBAgIBATANBgkqh ...\n  kuber.key: |\n    MIIEpgIBAAKCAQEA7yn3bRHQ5FHMQ ...\n")),(0,r.kt)("details",null,(0,r.kt)("summary",null),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"$ kubectl create secret docker-registry my-image-pull-secret \\\n  --docker-username=<username> \\\n  --docker-password=<password> \\\n  --docker-email=<email-address>\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Secret\nmetadata:\n  name: docker-registry\ntype: Opaque\nstringData:\n  docker-username: <username>\n  docker-password: <password>\n  docker-email: <email-address>\n"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Consuming Secrets")),(0,r.kt)("p",null,"A secrets volume!"),(0,r.kt)("p",null,"Secrets volumes are managed by the kubelet and are created at Pod creation time. Secrets are stored on tmpfs volumes (aka RAM disks), and as such are not written to disk on nodes."),(0,r.kt)("p",null,"Each data element of a secret is stored in a separate file under the target mount point specified in the volume mount."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Pod\nmetadata:\n  name: kuber-tls\nspec:\n  containers:\n    - name: kuber-tls\n      image: kuber-image\n      volumeMounts:\n        - name: tls-cert\n          mountPath: '/tls'\n          readOnly: true\n  volumes:\n    - name: tls-certs\n      secret:\n        secretName: kuber-tls\n")),(0,r.kt)("p",null,"Mounting the kuard-tls secrets volume to ",(0,r.kt)("inlineCode",{parentName:"p"},"/tls")," results in the following files:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"/tls/kuard.crt\n/tls/kuard.key\n")),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Creating")),(0,r.kt)("p",null,"The easiest way to create a Secret or a ConfigMap is via ",(0,r.kt)("inlineCode",{parentName:"p"},"kubectl create secret generic")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"kubectl create configmap"),". There are a variety of ways to specify the data items that go into the secret or ConfigMap. These can be combined in a single command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# Load from the file with the secret data key the same as the filename.\n--from-file=<filename>\n\n# Load from the file with the secret data key explicitly specified.\n--from-file=<key>=<filename>\n\n# Load all the files in the specified directory where the filename is an acceptable key name.\n--from-file=<directory>\n\n# Use the specified key/value pair directly.\n--from-literal=<key>=<value>\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"kubectl edit configmap my-config")))}c.isMDXComponent=!0}}]);