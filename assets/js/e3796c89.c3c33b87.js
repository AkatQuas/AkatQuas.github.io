"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6079],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>m});var a=r(67294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=a.createContext({}),p=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(r),h=n,m=c["".concat(l,".").concat(h)]||c[h]||d[h]||o;return r?a.createElement(m,i(i({ref:t},u),{},{components:r})):a.createElement(m,i({ref:t},u))}));function m(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:n,i[1]=s;for(var p=2;p<o;p++)i[p]=r[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,r)}h.displayName="MDXCreateElement"},6090:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=r(87462),n=(r(67294),r(3905));const o={title:"Building Abstractions with Procedures",tags:["sicp"]},i=void 0,s={unversionedId:"sicp/building-abstractions-with-procedures",id:"sicp/building-abstractions-with-procedures",title:"Building Abstractions with Procedures",description:"The Elements of Programming",source:"@site/docs/sicp/01-building-abstractions-with-procedures.md",sourceDirName:"sicp",slug:"/sicp/building-abstractions-with-procedures",permalink:"/docs/sicp/building-abstractions-with-procedures",draft:!1,tags:[{label:"sicp",permalink:"/docs/tags/sicp"}],version:"current",sidebarPosition:1,frontMatter:{title:"Building Abstractions with Procedures",tags:["sicp"]},sidebar:"tutorialSidebar",previous:{title:"Structure and Interpretation of Computer Programs",permalink:"/docs/sicp/index"},next:{title:"Building Abstractions with Data",permalink:"/docs/sicp/building-abstractions-with-data"}},l={},p=[{value:"The Elements of Programming",id:"the-elements-of-programming",level:2},{value:"Expressions",id:"expressions",level:3},{value:"Naming and the Environment",id:"naming-and-the-environment",level:3},{value:"Evaluating Combinations",id:"evaluating-combinations",level:3},{value:"Compound Procedures",id:"compound-procedures",level:3},{value:"The substitution Model for Procedure Application",id:"the-substitution-model-for-procedure-application",level:3},{value:"Conditional Expressions and Predicates",id:"conditional-expressions-and-predicates",level:3},{value:"Procedures as Black-Box Abstractions",id:"procedures-as-black-box-abstractions",level:3},{value:"Local Names",id:"local-names",level:4},{value:"Internal definitions and block structure",id:"internal-definitions-and-block-structure",level:4},{value:"Procedures and the Processes They Generate",id:"procedures-and-the-processes-they-generate",level:2},{value:"Linear Recursion and Iteration",id:"linear-recursion-and-iteration",level:3},{value:"Tree Recursion",id:"tree-recursion",level:3},{value:"Orders of Growth",id:"orders-of-growth",level:3},{value:"Exponentiation",id:"exponentiation",level:3},{value:"Formulating Abstractions with Higher-Order Procedures",id:"formulating-abstractions-with-higher-order-procedures",level:2},{value:"Constructing Procedures Using Lambda",id:"constructing-procedures-using-lambda",level:3},{value:"Using <code>let</code> to create local variables",id:"using-let-to-create-local-variables",level:4},{value:"Procedures as General Methods",id:"procedures-as-general-methods",level:3},{value:"Procedures as Returned Values",id:"procedures-as-returned-values",level:3},{value:"Abstractions and first-class procedures",id:"abstractions-and-first-class-procedures",level:4}],u={toc:p};function c(e){let{components:t,...r}=e;return(0,n.kt)("wrapper",(0,a.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h2",{id:"the-elements-of-programming"},"The Elements of Programming"),(0,n.kt)("p",null,"Every powerful language has three mechanisms for accomplishing this:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"primitive expressions"),", which represent the simplest entities the language is concerned with,")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"means of combination"),", by which compound elements are built from simpler ones, and")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"means of abstraction"),", by which compound elements can be named and manipulated as units."))),(0,n.kt)("p",null,"In programming, we deal with two kinds of elements: procedures and data. Informally, data is ",(0,n.kt)("em",{parentName:"p"},"stuff")," that we want to manipulate, and procedures are ",(0,n.kt)("em",{parentName:"p"},"descriptions of the rules")," for manipulating the data."),(0,n.kt)("h3",{id:"expressions"},"Expressions"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"primitive expression"),(0,n.kt)("li",{parentName:"ul"},"primitive procedure expression"),(0,n.kt)("li",{parentName:"ul"},"compound expression (combinations)"),(0,n.kt)("li",{parentName:"ul"},"nested combinations")),(0,n.kt)("p",null,"REPL : Reading an expression -> Evaluating the expression -> Print the result -> Loop again"),(0,n.kt)("h3",{id:"naming-and-the-environment"},"Naming and the Environment"),(0,n.kt)("p",null,"A critical aspect of a programming language is the means it provides for using names to refer to computational objects."),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"This is one of the simplest means of abstraction, for it allow programmers to use simple names to refer to the results of compound operations.")),(0,n.kt)("p",null,"It should be clear that the possibility of associating values with symbols and later retrieving them means that the interpreter must maintain some sort of memory that keeps track of the name-object pairs. This memory is called the ",(0,n.kt)("inlineCode",{parentName:"p"},"environment"),"."),(0,n.kt)("h3",{id:"evaluating-combinations"},"Evaluating Combinations"),(0,n.kt)("p",null,"In order to accomplish the evaluation process for a combination we must first perform the evaluation process on each element of the combination. Thus, the evaluation rule is recursive in nature."),(0,n.kt)("p",null,"We take care of the primitive cases by stipulating that"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"the values of numerals are the numbers that they name,"),(0,n.kt)("li",{parentName:"ul"},"the values of built-in operators are the machine instruction sequences that carry out the corresponding operations, and"),(0,n.kt)("li",{parentName:"ul"},"the values of other names are the objects associated with those names in the environment.")),(0,n.kt)("p",null,"The various kinds of expressions (each with its associated evaluation rule) constitute the syntax of the programming language."),(0,n.kt)("h3",{id:"compound-procedures"},"Compound Procedures"),(0,n.kt)("p",null,"The ",(0,n.kt)("em",{parentName:"p"},"procedure definitions"),", a much more powerful abstraction technique by which a compound operation can be given a name, and then referred to as a unit."),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},(0,n.kt)("inlineCode",{parentName:"p"},"function")," is one of the reified procedures.")),(0,n.kt)("p",null,"The general form of a procedure definition is"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"(define (<name> <formal parameters>) (<body>))\n")),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"\u27e8name\u27e9")," is a symbol to be associated with the procedure definition in the environment. The ",(0,n.kt)("inlineCode",{parentName:"p"},"<formal parameters>")," the body of the procedure to refer to the corresponding arguments of the procedure. The ",(0,n.kt)("inlineCode",{parentName:"p"},"<body>")," is an expression that will yield the value of the procedure application, optionally, when the formal parameters are replaced by the actual arguments to which the procedure is applied."),(0,n.kt)("p",null,"Compound procedures are used in exactly the same way as primitive procedures."),(0,n.kt)("h3",{id:"the-substitution-model-for-procedure-application"},"The substitution Model for Procedure Application"),(0,n.kt)("p",null,"To evaluate a combination whose operator names a compound procedure, the interpreter evaluates the elements of the combination and applies the procedure (which is the value of the operator of the combination) to the arguments (which are the values of the operands of the combination)."),(0,n.kt)("p",null,"And, to apply a compound procedure to arguments, evaluate the body of the procedure with each formal parameter replaced by the corresponding argument."),(0,n.kt)("p",null,"The process we have just described is called the ",(0,n.kt)("em",{parentName:"p"},"substitution model")," for procedure application. It can be taken as a model that determines the \u201cmeaning\u201d of procedure application, insofar as the procedures in this chapter are concerned. However, there are two points that should be stressed:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"The purpose of the substitution is to help us think about procedure application, not to provide a description of how the interpreter really works. Typical interpreters do not evaluate procedure applications by manipulating the text of a procedure to substitute values for the formal parameters. In practice, the \u201csubstitution\u201d is accomplished by using a local environment for the formal parameters.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"The substitution model is only the first of these models\u2014a way to get started thinking formally about the evaluation process."))),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"Applicative Order vs Normal Order"),(0,n.kt)("p",{parentName:"blockquote"},"In ",(0,n.kt)("em",{parentName:"p"},"applicative order"),", the interpreter first evaluates the operator and operands and then applies the resulting procedure to the resulting arguments."),(0,n.kt)("p",{parentName:"blockquote"},"In ",(0,n.kt)("em",{parentName:"p"},"normal order"),", the interpreter first substitute operand expressions for parameters until it obtained an expression involving only primitive operators, and would then perform the evaluation.")),(0,n.kt)("h3",{id:"conditional-expressions-and-predicates"},"Conditional Expressions and Predicates"),(0,n.kt)("p",null,"Sometimes, we need to make tests on some procedures, and to perform different operations depending on the result of the tests. Here comes the conditional expression, with its general form:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"(cond (<p1> <e1>)\n      (<p2> <e2>)\n      ...\n      (<pn> <en>))\n")),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"(<px> <ex>)")," is a pair of ",(0,n.kt)("em",{parentName:"p"},"predicate-consequent")," clause. A predicate is an expression whose value is interpreted as either ",(0,n.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,n.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,n.kt)("p",null,"The interpreter would evaluate every predicate until it a predicate is found whose value is true, in which case the interpreter would evaluate the corresponding consequent expression of that clause. If none of the predicates is found to be true, no consequent expression would be evaluated."),(0,n.kt)("p",null,"There's a special form ",(0,n.kt)("inlineCode",{parentName:"p"},"if"),", which is a restricted type of conditional that can be used when there precisely two cases in the case analysis:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"(if <predicate> <consequent> <alternative>)\n")),(0,n.kt)("p",null,"The interpreter starts by evaluating the predicate part of the expression. If the predicate evaluates to be true, then interpreter would then evaluate the consequent expression, otherwise, the alternative expression."),(0,n.kt)("p",null,"Also, there are logical composition operations which help to construct compound predicates."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"(and <e1> <e2> ... <en>)\n\n(or <e1> <e2> ... <en>)\n\n(not <e1>)\n")),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"and")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"or")," would take a short circuit strategy to save the evaluation procedure."),(0,n.kt)("h3",{id:"procedures-as-black-box-abstractions"},"Procedures as Black-Box Abstractions"),(0,n.kt)("p",null,"It is crucial that each procedure accomplishes an identifiable task that can be used as a module in defining other procedures."),(0,n.kt)("p",null,"Sometimes, we are not concerned with ",(0,n.kt)("em",{parentName:"p"},"how")," the procedure computes its result, only with the fact ",(0,n.kt)("em",{parentName:"p"},"what output")," it computes the with our inputs."),(0,n.kt)("p",null,"So a procedure definition should be able to suppress detail. The users of the procedure may not have written the procedure themselves, but may have obtained it from another programmer as a ",(0,n.kt)("em",{parentName:"p"},"black box"),". A user should not need to know how the procedure is implemented in order to use it."),(0,n.kt)("h4",{id:"local-names"},"Local Names"),(0,n.kt)("p",null,"The principle\u2014that the meaning of a procedure should be independent of the parameter names \u2014seems on the surface to be self-evident, but its consequences are profound. The simplest consequence is that the parameter names of a procedure must be ",(0,n.kt)("em",{parentName:"p"},"local")," to the body of the procedure."),(0,n.kt)("p",null,"A formal parameter of a procedure has a very special role in the procedure definition, in that it does not matter what name the formal parameter has. Such a name is called a ",(0,n.kt)("em",{parentName:"p"},"bound variable"),", and we say that the procedure definition binds its formal parameters. The meaning of a procedure definition is unchanged if a bound variable is consistently renamed throughout the definition. If a variable is not bound, we say that it is free. The set of expressions for which a binding defines a name is called the ",(0,n.kt)("em",{parentName:"p"},"scope")," of that name. In a procedure definition, the bound variables declared as the formal parameters of the procedure have the body of the procedure as their scope."),(0,n.kt)("h4",{id:"internal-definitions-and-block-structure"},"Internal definitions and block structure"),(0,n.kt)("p",null,"The formal parameters of a procedure are local to the body of the procedure."),(0,n.kt)("p",null,"In order to solve the name conflict among procedures, we might want to localize the sub-procedures, hiding them inside some bigger procedures."),(0,n.kt)("p",null,"To make this possible, a procedure is allowed to have private internal definitions that are local to that procedure. Such nesting of definitions, called ",(0,n.kt)("em",{parentName:"p"},"block structure"),", is basically the right solution to the simplest name-packaging problem."),(0,n.kt)("p",null,"With internal definition of procedures, we could release some parameters of the internal procedures to be ",(0,n.kt)("em",{parentName:"p"},"free")," rather than ",(0,n.kt)("em",{parentName:"p"},"bound"),". This discipline is called ",(0,n.kt)("em",{parentName:"p"},"lexical scoping"),"."),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"Lexical scoping dictates that free variables in a procedure are taken to refer to bindings made by enclosing procedure definitions; that is, they are looked up in the environment in which the procedure was defined.")),(0,n.kt)("h2",{id:"procedures-and-the-processes-they-generate"},"Procedures and the Processes They Generate"),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"To become experts, we must learn to visualize the processes generated by various types of procedures.")),(0,n.kt)("p",null,"A procedure is a pattern for the ",(0,n.kt)("em",{parentName:"p"},"local evolution")," of a computational process. It specifies how each stage of the process is built upon the previous stage. We would like to be able to make statements about the overall, or ",(0,n.kt)("em",{parentName:"p"},"global"),", behavior of a process whose local evolution has been specified by a procedure."),(0,n.kt)("h3",{id:"linear-recursion-and-iteration"},"Linear Recursion and Iteration"),(0,n.kt)("p",null,"Carrying out ",(0,n.kt)("em",{parentName:"p"},"recursive process")," requires that the interpreter keep track of the operations to be performed later on. If the amount of information needed to keep track of it, which grows linearly with ",(0,n.kt)("em",{parentName:"p"},"n")," (is proportional to ",(0,n.kt)("em",{parentName:"p"},"n"),"), just like the number of steps, is called a ",(0,n.kt)("em",{parentName:"p"},"linear recursive process"),"."),(0,n.kt)("p",null,"By contrast, in an ",(0,n.kt)("em",{parentName:"p"},"iterative process"),", all we need to keep track of, for any ",(0,n.kt)("em",{parentName:"p"},"n"),", are the current values of the variables ",(0,n.kt)("em",{parentName:"p"},"product"),", ",(0,n.kt)("em",{parentName:"p"},"counter"),", and ",(0,n.kt)("em",{parentName:"p"},"max-count"),". In general, an iterative process is one whose state can be summarized by a fixed number of state variables, together with a fixed rule that describes how the state variables should be updated as the process moves from state to state and an (optional) end test that specifies conditions under which the process should terminate."),(0,n.kt)("p",null,"The contrast between the two processes can be seen in another way. In the iterative case, the program variables provide a complete description of the state of the process at any point. If we stopped the computation between steps, all we would need to do to resume the computation is to supply the interpreter with the values of the three program variables. Not so with the recursive process. In this case there is some additional ",(0,n.kt)("em",{parentName:"p"},"hidden")," information, ",(0,n.kt)("em",{parentName:"p"},"maintained by the interpreter and not contained in the program variables"),", which indicates where the process is in negotiating the chain of deferred operations. The longer the chain, the more information must be maintained."),(0,n.kt)("p",null,"As a consequence, some programming languages can describe iterative processes only by resorting to special-purpose ",(0,n.kt)("em",{parentName:"p"},"looping constructs")," such as ",(0,n.kt)("inlineCode",{parentName:"p"},"do"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"repeat"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"until"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"for"),", and ",(0,n.kt)("inlineCode",{parentName:"p"},"while"),"."),(0,n.kt)("p",null,"With a tail-recursive implementation, iteration can be expressed using the ordinary procedure call mechanism, so that special iteration constructs are useful only as syntactic sugar."),(0,n.kt)("h3",{id:"tree-recursion"},"Tree Recursion"),(0,n.kt)("p",null,"Another common pattern of computation is called ",(0,n.kt)("em",{parentName:"p"},"tree recursion"),". Consider computing the sequence of Fibonacci numbers as an example, ",(0,n.kt)("inlineCode",{parentName:"p"},"f(n) = f(n-1) + f(n-2)"),"."),(0,n.kt)("p",null,"This procedure is instructive as a prototypical tree recursion, but it is a terrible way to compute Fibonacci numbers because it does so much redundant computation."),(0,n.kt)("p",null,"In general, the number of steps required by a tree-recursive process will be proportional to the number of nodes in the tree, while the space required will be proportional to the maximum depth of the tree."),(0,n.kt)("p",null,"When we consider processes that operate on hierarchically structured data rather than numbers, we will find that tree recursion is a natural and powerful tool."),(0,n.kt)("h3",{id:"orders-of-growth"},"Orders of Growth"),(0,n.kt)("p",null,"The notion of ",(0,n.kt)("em",{parentName:"p"},"order of growth")," is to obtain a gross measure of the resources required by a process as the inputs become larger."),(0,n.kt)("p",null,"Orders of growth provide only a crude description of the behavior of a process. On the other hand, order of growth provides a useful indication of how we may expect the behavior of the process to change as we change the size of the problem."),(0,n.kt)("h3",{id:"exponentiation"},"Exponentiation"),(0,n.kt)("p",null,"The difference between ",(0,n.kt)("inlineCode",{parentName:"p"},"\u0398(log n)")," growth and ",(0,n.kt)("inlineCode",{parentName:"p"},"\u0398(n)")," growth becomes striking as ",(0,n.kt)("inlineCode",{parentName:"p"},"n")," becomes large."),(0,n.kt)("p",null,"One of the means to reduce execution steps or memory requirements is try to make a problem in ",(0,n.kt)("inlineCode",{parentName:"p"},"n")," to be divided into ",(0,n.kt)("inlineCode",{parentName:"p"},"log n")," executions."),(0,n.kt)("h2",{id:"formulating-abstractions-with-higher-order-procedures"},"Formulating Abstractions with Higher-Order Procedures"),(0,n.kt)("p",null,"One of the things we should demand from a powerful programming language is the ability to build abstractions by assigning names to common patterns and then to work in terms of the abstractions directly."),(0,n.kt)("p",null,"Procedures provide this ability. This is why all but the most primitive programming languages include mechanisms for defining procedures."),(0,n.kt)("p",null,"Programming languages allow us to construct procedures that can accept procedures as arguments or return procedures as values."),(0,n.kt)("p",null,"Procedures that manipulate procedures are called ",(0,n.kt)("em",{parentName:"p"},"higher-order procedures"),"."),(0,n.kt)("h3",{id:"constructing-procedures-using-lambda"},"Constructing Procedures Using Lambda"),(0,n.kt)("p",null,"It seems terribly awkward to have to define trivial procedures outside the higher-order procedures. It would be more convenient to have a way to directly specify special form ",(0,n.kt)("em",{parentName:"p"},"lambda")," which creates inline procedures."),(0,n.kt)("p",null,"In general, ",(0,n.kt)("em",{parentName:"p"},"lambda")," is used to create procedures in the same way as ",(0,n.kt)("em",{parentName:"p"},"define"),", except that no name is specified for the procedure, and there's not an associated name in the environment."),(0,n.kt)("h4",{id:"using-let-to-create-local-variables"},"Using ",(0,n.kt)("inlineCode",{parentName:"h4"},"let")," to create local variables"),(0,n.kt)("p",null,"Another use of ",(0,n.kt)("em",{parentName:"p"},"lambda")," is in creating local variables. We often need local variables in our procedures other than those that have been bound as formal parameters."),(0,n.kt)("p",null,"The general form of a let expression is"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"(let ((\u27e8var1\u27e9 \u27e8exp1\u27e9) (\u27e8var2\u27e9 \u27e8exp2\u27e9)\n...\n(\u27e8varn\u27e9 \u27e8expn\u27e9)) \u27e8body\u27e9)\n")),(0,n.kt)("p",null,"which can be thought of as saying"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"let \u27e8var1\u27e9 have the value \u27e8exp1\u27e9 and\n    \u27e8var2\u27e9 have the value \u27e8exp2\u27e9 and\n    ...\n    \u27e8varn\u27e9 have the value \u27e8expn\u27e9\nin \u27e8body\u27e9\n")),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"let")," allows one to bind variables as locally as possible to where they are to be used.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"The variables' values are computed outside the ",(0,n.kt)("inlineCode",{parentName:"p"},"let"),". This matters when the expressions that provide the values for the local variables depend upon variables having the same names as the local variables themselves."))),(0,n.kt)("h3",{id:"procedures-as-general-methods"},"Procedures as General Methods"),(0,n.kt)("p",null,"Compound procedures is introduced as a mechanism for abstracting patterns of operations to make them independent of the particular inputs involved. With higher-order procedures, there's a more powerful kind of abstraction: procedures used to express general methods of computation, independent of the particular functions involved."),(0,n.kt)("p",null,"Pass procedures as arguments significantly enhances the expressive power of our programming language."),(0,n.kt)("h3",{id:"procedures-as-returned-values"},"Procedures as Returned Values"),(0,n.kt)("p",null,"We can achieve even more expressive power by creating procedures whose returned values are themselves procedures"),(0,n.kt)("h4",{id:"abstractions-and-first-class-procedures"},"Abstractions and first-class procedures"),(0,n.kt)("p",null,"Compound procedures are a crucial abstraction mechanism, because they permit us to express general methods of computing as explicit elements in our programming language. Higher-order procedures permit us to manipulate these general methods to create further abstractions."),(0,n.kt)("p",null,"In general, programming languages impose restrictions on the ways in which computational elements can be manipulated. Elements with the fewest restrictions are said to have first-class status. Some ",(0,n.kt)("em",{parentName:"p"},"rights and privileges")," of first-class elements are:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"They may be named by variables."),(0,n.kt)("li",{parentName:"ul"},"They may be passed as arguments to procedures."),(0,n.kt)("li",{parentName:"ul"},"They may be returned as the results of procedures."),(0,n.kt)("li",{parentName:"ul"},"They may be included in data structures.")),(0,n.kt)("p",null,"Allowing procedures full first-class status poses challenges for efficient implementation, by the interpreter, but bring us enormous gain in expressive power."))}c.isMDXComponent=!0}}]);