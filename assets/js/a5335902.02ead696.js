"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9048],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),c=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},f=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=c(t),f=a,h=d["".concat(l,".").concat(f)]||d[f]||p[f]||o;return t?r.createElement(h,s(s({ref:n},u),{},{components:t})):r.createElement(h,s({ref:n},u))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=f;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i[d]="string"==typeof e?e:a,s[1]=i;for(var c=2;c<o;c++)s[c]=t[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}f.displayName="MDXCreateElement"},2118:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var r=t(87462),a=(t(67294),t(3905));const o={title:"Web server running over TCP",categories:["web server"],tags:["nodejs","tcp"]},s=void 0,i={permalink:"/blog/2018/09/13/web-server-with-tcp",source:"@site/blog/2018-09-13-web-server-with-tcp.md",title:"Web server running over TCP",description:"We are going to build a simple web server upon TCP.",date:"2018-09-13T00:00:00.000Z",formattedDate:"September 13, 2018",tags:[{label:"nodejs",permalink:"/blog/tags/nodejs"},{label:"tcp",permalink:"/blog/tags/tcp"}],readingTime:4.4,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Web server running over TCP",categories:["web server"],tags:["nodejs","tcp"]},prevItem:{title:"New a project using CLI",permalink:"/blog/2018/10/08/react-create-cli"},nextItem:{title:"Super tiny interpreter in JavaScript",permalink:"/blog/2018/08/23/super-tiny-interpreter"}},l={authorsImageUrls:[]},c=[{value:"Hello world",id:"hello-world",level:2},{value:"Read data from TCP",id:"read-data-from-tcp",level:2},{value:"stream parsing from TCP",id:"stream-parsing-from-tcp",level:2},{value:"References",id:"references",level:2}],u={toc:c};function d(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"We are going to build a simple web server upon TCP."),(0,a.kt)("p",null,"An ",(0,a.kt)("inlineCode",{parentName:"p"},"curl")," example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"curl -v -X POST -d 'a=12' http://localhost:3000/\n\n# output\nNote: Unnecessary use of -X or --request, POST is already inferred.\n*   Trying ::1...\n* TCP_NODELAY set\n* Connected to localhost (::1) port 3000 (#0)\n> POST / HTTP/1.1\\r\\n\n> Host: localhost:3000\\r\\n\n> User-Agent: curl/7.54.0\\r\\n\n> Accept: */*\\r\\n\n> Content-Length: 4\\r\\n\n> Content-Type: application/x-www-form-urlencoded\\r\\n\n> \\r\\n\\r\\n\n> 'a=12'\n>\n* upload completely sent off: 4 out of 4 bytes\n< HTTP/1.1 200 OK\\r\\n\n< server: my-custom-server\\r\\n\n< content-type: 12\\r\\n\n< date: Wed, 12 Sep 2018 16:08:16 GMT\\r\\n\n< \\r\\n\\r\\n\n<\n* no chunk, no close, no size. Assume close to signal end\n<\n* Closing connection 0\nHello world!%\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"HTTP message")," consists of the ",(0,a.kt)("inlineCode",{parentName:"p"},"request line"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"header line")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"body entity"),", where the delimiter is ",(0,a.kt)("inlineCode",{parentName:"p"},"\\r\\n")," (whilst the ",(0,a.kt)("inlineCode",{parentName:"p"},"header line")," ends with ",(0,a.kt)("inlineCode",{parentName:"p"},"\\r\\n\\r\\n"),", so we can tell the rest is the ",(0,a.kt)("inlineCode",{parentName:"p"},"body entity"),")."),(0,a.kt)("p",null,"We parse the ",(0,a.kt)("inlineCode",{parentName:"p"},"http message")," with the help of ",(0,a.kt)("inlineCode",{parentName:"p"},"socket"),", which read the incoming request as a ",(0,a.kt)("inlineCode",{parentName:"p"},"Duplex Stream")," (both readable and writable), and encapsulate the writing and reading manipulation as two objects ",(0,a.kt)("inlineCode",{parentName:"p"},"request")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"response"),", then pass them to the handler ",(0,a.kt)("inlineCode",{parentName:"p"},"(req, res) => { /*handler function*/ }"),"."),(0,a.kt)("p",null,"That is it."),(0,a.kt)("h2",{id:"hello-world"},"Hello world"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"http")," create a server to deal with http request."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const http = require('http');\n\nconst server = http.createServer();\n\nserver.on('request', (req, res) => {\n  console.log(`${new Date().toISOString()} - ${req.method} ${req.url}`);\n\n  res.setHeader('Content-Type', 'text/plain');\n  res.end('Hello world!');\n});\n\nserver.listen(3000);\n")),(0,a.kt)("h2",{id:"read-data-from-tcp"},"Read data from TCP"),(0,a.kt)("p",null,"Use ",(0,a.kt)("inlineCode",{parentName:"p"},"net")," module to create a server, which could handle TCP socket stream data."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const net = require('net');\nconst server = net.createServer();\nserver.on('connection', handleConnection);\n\nserver.listen(3000);\n\nfunction handleConnection(socket) {\n  socket.on('data', (chunk) => {\n    console.log('Received chunk:\\n', chunk.toString());\n  });\n  /* response with plain string in HTTP protocol formation */\n  socket.write(\n    'HTTP/1.1 200 OK\\r\\n Sever: my-web-server\\r\\nContent-Length: 0\\r\\n\\r\\n'\n  );\n}\n")),(0,a.kt)("h2",{id:"stream-parsing-from-tcp"},"stream parsing from TCP"),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Read the stream from TCP, parsing it according to HTTP protocol."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const net = require('net');\nconst server = net.createServer();\n\nserver.on('connection', handleConnection);\nserver.listen(3000);\n\nfunction handleConnection(socket) {\n  // subscribe to the readable event once so we can start calling .read()\n\n  socket.once('readable', function () {\n    // set up a buffer to hold the incoming data\n    let reqBuffer = new Buffer('');\n\n    // set up a temporary buffer to read in chunks\n    let buf;\n    let reqHeader;\n\n    while (true) {\n      buf = socket.read();\n\n      if (buf === null) break;\n\n      // concatenate existing request buffer with new data\n      reqBuffer = Buffer.concat([reqBuffer, buf]);\n\n      // check if we've reached \\r\\n\\r\\n, indicating end of header\n      let marker = reqBuffer.indexOf('\\r\\n\\r\\n');\n\n      if (marker !== -1) {\n        // we reached \\r\\n\\r\\n, there could be data after it.\n        let remaining = reqBuffer.slice(marker + 4);\n        // the header is everything we read, up to and not including \\r\\n\\r\\n\n        reqHeader = reqBuffer.slice(0, marker).toString();\n        // this pushes the extra data we read back to the scoket's readable stream\n        socket.unshift(remaining);\n        break;\n      }\n    }\n    console.log(`Request header:\\n${reqHeader}`);\n\n    // at this point, we've stopped reading from the socket and have the headerr as a string\n    // If we wanted to read the whole request body, we would do this:\n    reqBuffer = new Buffer('');\n    while ((buf = socket.read()) !== null) {\n      reqBuffer = Buffer.concat([reqBuffer, buf]);\n    }\n    let reqBody = reqBuffer.toString();\n    console.log(`Request body:\\n${reqBody}`);\n\n    // send a generic response\n    socket.end(\n      'HTTP/1.1 200 OK\\r\\nServer: my-custom-server\\r\\nContent-Length: 0\\r\\n\\r\\n'\n    );\n  });\n}\n"))),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Customized http server based on net TCP server."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const net = require('net');\n\nfunction createWebServer(requestHandler) {\n  const server = net.createServer();\n\n  server.on('connection', handleConnection);\n\n  function handleConnection(socket) {\n    socket.once('readable', function () {\n      let reqBuffer = new Buffer('');\n      let buf, reqHeader;\n      while (true) {\n        buf = socket.read();\n\n        if (buf === null) break;\n\n        reqBuffer = Buffer.concat([reqBuffer, buf]);\n\n        let marker = reqBuffer.indexOf('\\r\\n\\r\\n');\n        if (marker !== -1) {\n          let remaining = reqBuffer.slice(marker + 4);\n          reqHeader = reqBuffer.slice(0, marker).toString();\n          socket.unshift(remaining);\n          break;\n        }\n      }\n\n      /* Request business */\n      const reqHeaders = reqHeader.split('\\r\\n');\n      const reqLine = reqHeaders.shift().split(' ');\n      const headers = reqHeaders.reduce((acc, currentHeader) => {\n        const [key, value] = currentHeader.split(':');\n        return {\n          ...acc,\n          [key.trim().toLowerCase()]: value.trim(),\n        };\n      }, {});\n      const request = {\n        method: reqLine[0],\n        url: reqLine[1],\n        httpVersion: reqLine[2].split('/')[1],\n        headers,\n        socket,\n      };\n\n      /* Response business */\n      let status = 200,\n        statusText = 'OK',\n        headersSent = false,\n        isChunked = false;\n      const responseHeaders = {\n        server: 'my-custom-server',\n      };\n      function setHeader(key, value) {\n        responseHeaders[key.toLowerCase()] = value;\n      }\n      function sendHeaders() {\n        if (!headersSent) {\n          headersSent = true;\n\n          setHeader('date', new Date().toGMTString());\n\n          socket.write(`HTTP/1.1 ${status} ${statusText}\\r\\n`);\n\n          Object.keys(responseHeaders).forEach((headerKey) => {\n            socket.write(`${headerKey}: ${responseHeaders[headerKey]}\\r\\n`);\n          });\n\n          socket.write('\\r\\n');\n        }\n      }\n      const response = {\n        write(chunk) {\n          if (!headersSent) {\n            if (!responseHeaders['content-length']) {\n              isChunked = true;\n              setHeaders('transfer-encoding', 'chunked');\n            }\n            sendHeaders();\n          }\n\n          if (isChunked) {\n            const size = chunk.length.toString(16);\n            socket.write(`${size}\\r\\n`);\n            socket.write(chunk);\n            socket.write('\\r\\n');\n          } else {\n            socket.write(chunk);\n          }\n        },\n        end(chunk) {\n          if (!headersSent) {\n            if (!responseHeaders['content-length']) {\n              setHeader('content-type', chunk ? chunk.length : 0);\n            }\n            sendHeaders();\n          }\n          if (isChunked) {\n            if (chunk) {\n              const size = chunk.length.toString(16);\n              socket.write(`${size}\\r\\n`);\n              socket.write(chunk);\n              socket.write('\\r\\n\\r\\n');\n            }\n            socket.end('\\r\\n\\r\\n');\n          } else {\n            socket.end(chunk);\n          }\n        },\n        setHeader,\n        setStatus(newStatus, newStatusText) {\n          (status = newStatus), (statusText = newStatusText);\n        },\n        json(data) {\n          if (headersSent) {\n            throw new Error('Header sent, cannot proceed to send JSON');\n          }\n          const json = new Buffer(JSON.stringify(data));\n          setHeader('content-type', 'application/json;charest=utf-8');\n          setHeader('content-length', json.length);\n          sendHeaders();\n          socket.end(json);\n        },\n      };\n      requestHandler(request, response);\n    });\n  }\n\n  return {\n    listen: (port) => server.listen(port),\n  };\n}\n\nconst webServer = createWebServer((req, res) => {\n  console.log(`${new Date().toISOString()} - ${req.method} ${req.url}`);\n  res.setHeader('Content-Type', 'text/plain');\n  res.end('Hello world!');\n});\n\nwebServer.listen(3000);\n"))),(0,a.kt)("h2",{id:"references"},"References"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://www.codementor.io/ziad-saab/let-s-code-a-web-server-from-scratch-with-nodejs-streams-h4uc9utji"},"original tutorial")))}d.isMDXComponent=!0}}]);