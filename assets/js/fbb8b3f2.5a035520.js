"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1832],{3905:(e,n,t)=>{t.d(n,{Zo:()=>f,kt:()=>m});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var i=r.createContext({}),p=function(e){var n=r.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},f=function(e){var n=p(e.components);return r.createElement(i.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,f=l(e,["components","mdxType","originalType","parentName"]),c=p(t),d=a,m=c["".concat(i,".").concat(d)]||c[d]||u[d]||o;return t?r.createElement(m,s(s({ref:n},f),{},{components:t})):r.createElement(m,s({ref:n},f))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=d;var l={};for(var i in n)hasOwnProperty.call(n,i)&&(l[i]=n[i]);l.originalType=e,l[c]="string"==typeof e?e:a,s[1]=l;for(var p=2;p<o;p++)s[p]=t[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},88223:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var r=t(87462),a=(t(67294),t(3905));const o={title:"08",tags:["lisp","interpreter"]},s=void 0,l={unversionedId:"lisp-interpreter-in-py/chapter-08",id:"lisp-interpreter-in-py/chapter-08",title:"08",description:"In this article, we'll talk about unary operators, namely unary plus (+) and unary minus (-) operators.",source:"@site/docs/lisp-interpreter-in-py/chapter-08.md",sourceDirName:"lisp-interpreter-in-py",slug:"/lisp-interpreter-in-py/chapter-08",permalink:"/docs/lisp-interpreter-in-py/chapter-08",draft:!1,tags:[{label:"lisp",permalink:"/docs/tags/lisp"},{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",frontMatter:{title:"08",tags:["lisp","interpreter"]},sidebar:"tutorialSidebar",previous:{title:"07",permalink:"/docs/lisp-interpreter-in-py/chapter-07"},next:{title:"09",permalink:"/docs/lisp-interpreter-in-py/chapter-09"}},i={},p=[],f={toc:p};function c(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"In this article, we'll talk about unary operators, namely unary plus (+) and unary minus (-) operators."),(0,a.kt)("p",null,"What is a unary operator then? A ",(0,a.kt)("em",{parentName:"p"},"unary operator")," is an operator that operates on one ",(0,a.kt)("em",{parentName:"p"},"operand")," only."),(0,a.kt)("p",null,"Here are the rules for unary plus and unary minus operators:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The unary minus (-) operator produces the negation of its numeric operand"),(0,a.kt)("li",{parentName:"ol"},"The unary plus (+) operator yields its numeric operand without change"),(0,a.kt)("li",{parentName:"ol"},"The unary operators have higher precedence than the binary operators +, -, ","*",", and /")),(0,a.kt)("p",null,"Let's take a look at expression, \u201c5 - - 2\u201d:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part8_exp2.png",alt:""}),(0,a.kt)("p",null,"In the expression \"5 - - 2\" the first '-' represents the ",(0,a.kt)("em",{parentName:"p"},"binary")," subtraction operation and the second '-' represents the ",(0,a.kt)("em",{parentName:"p"},"unary")," minus operation, the negation."),(0,a.kt)("p",null,"And some more examples:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part8_exp3.png",alt:""}),(0,a.kt)("img",{src:"./imgs/lsbasi_part8_exp4.png",alt:""}),(0,a.kt)("p",null,"Now we update ",(0,a.kt)("em",{parentName:"p"},"factor")," rule to handle unary plus and unary minus operators:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part8_factor_update.png",alt:""}),(0,a.kt)("p",null,"so the full grammar changs to:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part8_grammar.png",alt:""}),(0,a.kt)("p",null,"The next step is to add an AST node class to represent unary operators."),(0,a.kt)("p",null,"This one will do:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"class UnaryOp(AST):\n    def __init__(self, op, expr):\n        self.token = self.op = op\n        self.expr = expr\n")),(0,a.kt)("p",null,"The constructor takes two parameters: ",(0,a.kt)("em",{parentName:"p"},"op"),", which represents the unary operator token (plus or minus) and ",(0,a.kt)("em",{parentName:"p"},"expr"),", which represents an AST node."),(0,a.kt)("p",null,"Our updated grammar had changes to the ",(0,a.kt)("em",{parentName:"p"},"factor")," rule, so that's what we're going to modify in our parser - the ",(0,a.kt)("em",{parentName:"p"},"factor"),' method. We will add code to the method to handle the "(PLUS | MINUS) factor" sub-rule:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'def factor(self):\n    """factor : (PLUS | MINUS) factor | INTEGER | LPAREN expr RPAREN"""\n    token = self.current_token\n    if token.type == PLUS:\n        self.eat(PLUS)\n        node = UnaryOp(token, self.factor())\n        return node\n    elif token.type == MINUS:\n        self.eat(MINUS)\n        node = UnaryOp(token, self.factor())\n        return node\n    elif token.type == INTEGER:\n        self.eat(INTEGER)\n        return Num(token)\n    elif token.type == LPAREN:\n        self.eat(LPAREN)\n        node = self.expr()\n        self.eat(RPAREN)\n        return node\n')),(0,a.kt)("p",null,"And now we need to extend the ",(0,a.kt)("em",{parentName:"p"},"Interpreter")," class and add a ",(0,a.kt)("em",{parentName:"p"},"visit_UnaryOp")," method to interpret unary nodes:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def visit_UnaryOp(self, node):\n    op = node.op.type\n    if op == PLUS:\n        return +self.visit(node.expr)\n    elif op == MINUS:\n        return -self.visit(node.expr)\n")),(0,a.kt)("p",null,"The complete code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"\"\"\" SPI - Simple Pascal Interpreter \"\"\"\n\n###############################################################################\n#                                                                             #\n#  LEXER                                                                      #\n#                                                                             #\n###############################################################################\n\n# Token types\n#\n# EOF (end-of-file) token is used to indicate that\n# there is no more input left for lexical analysis\nINTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = (\n    'INTEGER', 'PLUS', 'MINUS', 'MUL', 'DIV', '(', ')', 'EOF'\n)\n\n\nclass Token(object):\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n\n    def __str__(self):\n        \"\"\"String representation of the class instance.\n        Examples:\n            Token(INTEGER, 3)\n            Token(PLUS, '+')\n            Token(MUL, '*')\n        \"\"\"\n        return 'Token({type}, {value})'.format(\n            type=self.type,\n            value=repr(self.value)\n        )\n\n    def __repr__(self):\n        return self.__str__()\n\n\nclass Lexer(object):\n    def __init__(self, text):\n        # client string input, e.g. \"4 + 2 * 3 - 6 / 2\"\n        self.text = text\n        # self.pos is an index into self.text\n        self.pos = 0\n        self.current_char = self.text[self.pos]\n\n    def error(self):\n        raise Exception('Invalid character')\n\n    def advance(self):\n        \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\"\n        self.pos += 1\n        if self.pos > len(self.text) - 1:\n            self.current_char = None  # Indicates end of input\n        else:\n            self.current_char = self.text[self.pos]\n\n    def skip_whitespace(self):\n        while self.current_char is not None and self.current_char.isspace():\n            self.advance()\n\n    def integer(self):\n        \"\"\"Return a (multidigit) integer consumed from the input.\"\"\"\n        result = ''\n        while self.current_char is not None and self.current_char.isdigit():\n            result += self.current_char\n            self.advance()\n        return int(result)\n\n    def get_next_token(self):\n        \"\"\"Lexical analyzer (also known as scanner or tokenizer)\n        This method is responsible for breaking a sentence\n        apart into tokens. One token at a time.\n        \"\"\"\n        while self.current_char is not None:\n\n            if self.current_char.isspace():\n                self.skip_whitespace()\n                continue\n\n            if self.current_char.isdigit():\n                return Token(INTEGER, self.integer())\n\n            if self.current_char == '+':\n                self.advance()\n                return Token(PLUS, '+')\n\n            if self.current_char == '-':\n                self.advance()\n                return Token(MINUS, '-')\n\n            if self.current_char == '*':\n                self.advance()\n                return Token(MUL, '*')\n\n            if self.current_char == '/':\n                self.advance()\n                return Token(DIV, '/')\n\n            if self.current_char == '(':\n                self.advance()\n                return Token(LPAREN, '(')\n\n            if self.current_char == ')':\n                self.advance()\n                return Token(RPAREN, ')')\n\n            self.error()\n\n        return Token(EOF, None)\n\n\n###############################################################################\n#                                                                             #\n#  PARSER                                                                     #\n#                                                                             #\n###############################################################################\n\nclass AST(object):\n    pass\n\n\nclass BinOp(AST):\n    def __init__(self, left, op, right):\n        self.left = left\n        self.token = self.op = op\n        self.right = right\n\n\nclass Num(AST):\n    def __init__(self, token):\n        self.token = token\n        self.value = token.value\n\n\nclass UnaryOp(AST):\n    def __init__(self, op, expr):\n        self.token = self.op = op\n        self.expr = expr\n\n\nclass Parser(object):\n    def __init__(self, lexer):\n        self.lexer = lexer\n        # set current token to the first token taken from the input\n        self.current_token = self.lexer.get_next_token()\n\n    def error(self):\n        raise Exception('Invalid syntax')\n\n    def eat(self, token_type):\n        # compare the current token type with the passed token\n        # type and if they match then \"eat\" the current token\n        # and assign the next token to the self.current_token,\n        # otherwise raise an exception.\n        if self.current_token.type == token_type:\n            self.current_token = self.lexer.get_next_token()\n        else:\n            self.error()\n\n    def factor(self):\n        \"\"\"factor : (PLUS | MINUS) factor | INTEGER | LPAREN expr RPAREN\"\"\"\n        token = self.current_token\n        if token.type == PLUS:\n            self.eat(PLUS)\n            node = UnaryOp(token, self.factor())\n            return node\n        elif token.type == MINUS:\n            self.eat(MINUS)\n            node = UnaryOp(token, self.factor())\n            return node\n        elif token.type == INTEGER:\n            self.eat(INTEGER)\n            return Num(token)\n        elif token.type == LPAREN:\n            self.eat(LPAREN)\n            node = self.expr()\n            self.eat(RPAREN)\n            return node\n\n    def term(self):\n        \"\"\"term : factor ((MUL | DIV) factor)*\"\"\"\n        node = self.factor()\n\n        while self.current_token.type in (MUL, DIV):\n            token = self.current_token\n            if token.type == MUL:\n                self.eat(MUL)\n            elif token.type == DIV:\n                self.eat(DIV)\n\n            node = BinOp(left=node, op=token, right=self.factor())\n\n        return node\n\n    def expr(self):\n        \"\"\"\n        expr   : term ((PLUS | MINUS) term)*\n        term   : factor ((MUL | DIV) factor)*\n        factor : (PLUS | MINUS) factor | INTEGER | LPAREN expr RPAREN\n        \"\"\"\n        node = self.term()\n\n        while self.current_token.type in (PLUS, MINUS):\n            token = self.current_token\n            if token.type == PLUS:\n                self.eat(PLUS)\n            elif token.type == MINUS:\n                self.eat(MINUS)\n\n            node = BinOp(left=node, op=token, right=self.term())\n\n        return node\n\n    def parse(self):\n        node = self.expr()\n        if self.current_token.type != EOF:\n            self.error()\n        return node\n\n###############################################################################\n#                                                                             #\n#  INTERPRETER                                                                #\n#                                                                             #\n###############################################################################\n\n\nclass NodeVisitor(object):\n    def visit(self, node):\n        method_name = 'visit_' + type(node).__name__\n        visitor = getattr(self, method_name, self.generic_visit)\n        return visitor(node)\n\n    def generic_visit(self, node):\n        raise Exception('No visit_{} method'.format(type(node).__name__))\n\n\nclass Interpreter(NodeVisitor):\n    def __init__(self, parser):\n        self.parser = parser\n\n    def visit_BinOp(self, node):\n        if node.op.type == PLUS:\n            return self.visit(node.left) + self.visit(node.right)\n        elif node.op.type == MINUS:\n            return self.visit(node.left) - self.visit(node.right)\n        elif node.op.type == MUL:\n            return self.visit(node.left) * self.visit(node.right)\n        elif node.op.type == DIV:\n            return self.visit(node.left) / self.visit(node.right)\n\n    def visit_Num(self, node):\n        return node.value\n\n    def visit_UnaryOp(self, node):\n        op = node.op.type\n        if op == PLUS:\n            return +self.visit(node.expr)\n        elif op == MINUS:\n            return -self.visit(node.expr)\n\n    def interpret(self):\n        tree = self.parser.parse()\n        if tree is None:\n            return ''\n        return self.visit(tree)\n\n\ndef main():\n    while True:\n        try:\n            text = input('spi> ')\n        except EOFError:\n            break\n        if not text:\n            continue\n\n        lexer = Lexer(text)\n        parser = Parser(lexer)\n        interpreter = Interpreter(parser)\n        result = interpreter.interpret()\n        print(result)\n\n\nif __name__ == '__main__':\n    main()\n")),(0,a.kt)("p",null,"Next, we will take a look at the Pascal."))}c.isMDXComponent=!0}}]);