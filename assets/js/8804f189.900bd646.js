"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6616],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>u});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=a.createContext({}),m=function(e){var n=a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=m(e.components);return a.createElement(i.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},f=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=m(t),f=r,u=p["".concat(i,".").concat(f)]||p[f]||d[f]||s;return t?a.createElement(u,l(l({ref:n},c),{},{components:t})):a.createElement(u,l({ref:n},c))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var s=t.length,l=new Array(s);l[0]=f;var o={};for(var i in n)hasOwnProperty.call(n,i)&&(o[i]=n[i]);o.originalType=e,o[p]="string"==typeof e?e:r,l[1]=o;for(var m=2;m<s;m++)l[m]=t[m];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}f.displayName="MDXCreateElement"},68182:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>m});var a=t(87462),r=(t(67294),t(3905));const s={title:"13 Introduction to semantic analysis",tags:["lisp","interpreter"]},l=void 0,o={unversionedId:"lisp-interpreter-in-py/chapter-13",id:"lisp-interpreter-in-py/chapter-13",title:"13 Introduction to semantic analysis",description:"While our Pascal program can be grammatically correct and the parser can successfully build an abstract syntax tree, the program still can contain some pretty serious errors. To catch those errors we need to use the abstract syntax tree and the informaiton from the symbol table.",source:"@site/docs/lisp-interpreter-in-py/chapter-13.md",sourceDirName:"lisp-interpreter-in-py",slug:"/lisp-interpreter-in-py/chapter-13",permalink:"/docs/lisp-interpreter-in-py/chapter-13",draft:!1,tags:[{label:"lisp",permalink:"/docs/tags/lisp"},{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",frontMatter:{title:"13 Introduction to semantic analysis",tags:["lisp","interpreter"]},sidebar:"tutorialSidebar",previous:{title:"12",permalink:"/docs/lisp-interpreter-in-py/chapter-12"},next:{title:"14",permalink:"/docs/lisp-interpreter-in-py/chapter-14"}},i={},m=[],c={toc:m};function p(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"While our Pascal program can be grammatically correct and the parser can successfully build an ",(0,r.kt)("em",{parentName:"p"},"abstract syntax tree"),", the program still can contain some pretty serious errors. To catch those errors we need to use the ",(0,r.kt)("em",{parentName:"p"},"abstract syntax tree")," and the informaiton from the ",(0,r.kt)("em",{parentName:"p"},"symbol table"),"."),(0,r.kt)("p",null,"Why can't we check for those errors during parsing, that is, during ",(0,r.kt)("em",{parentName:"p"},"syntax analysis"),"? Why do we have to build an ",(0,r.kt)("em",{parentName:"p"},"AST")," and something called the symbol table to do that?"),(0,r.kt)("p",null,"In a nutshell, for convenience and the separation of concerns. By moving those extra checks into a separate phase, we can focus on one task at a time without making our parser and interpreter do more work than they are supposed to do."),(0,r.kt)("p",null,"When the parser has finished building the AST, we know that the program is grammatically correct; that is, that its syntax is correct according to our grammar rules and now we can separately focus on checking for errors that require additional context and information that the parser did not have at the time of building the AST. To make it more concrete, let's take a look at the following Pascal assignment statement:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"x := x + y;\n")),(0,r.kt)("p",null,"The parser will handle it all right because, grammatically, the statement is correct (according to our previously defined grammar rules for assignment statements and expressions). But that's not the end of the story yet, because Pascal has a requirement that variables must be declared with their corresponding types before they are used. How does the parser know whether x and y have been declared yet?"),(0,r.kt)("p",null,"Well, it doesn't and that's why we need a separate semantic analysis phase to answer the question (among many others) of whether the variables have been declared prior to their use."),(0,r.kt)("p",null,"Basically, ",(0,r.kt)("em",{parentName:"p"},"semantic analysis")," is just a process to help us determine whether a program makes sense, and that it has meaning, according to a language definition."),(0,r.kt)("p",null,"What does it even mean for a program to make sense? It depends in large part on a language definition and language requirements."),(0,r.kt)("p",null,"Pascal language and, specifically, Free Pascal's compiler, has certain requirements that, if not followed in a program, would lead to an error from the ",(0,r.kt)("em",{parentName:"p"},"fpc"),' compiler indicating that the program doesn\'t "make sense", that it is correct, even though the syntax might look okay. Here are some of those requirements:'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The variables must be declared before they are used")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The variable must have matching types when used in arithmetic expressions (this is a big part of ",(0,r.kt)("em",{parentName:"p"},"semantic analysis")," called ",(0,r.kt)("em",{parentName:"p"},"type checking")," that we'll cover separately).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"There should be no duplicate declarations (Pascal prohibits, for example, having a local variable in a procedure with the same name as one of the procedure's formal parameters)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A name reference in a call to procedure must refer to the actual declared procedure (It doesn't make sense in Pascal if, in the procedure call foo(), the name ",(0,r.kt)("em",{parentName:"p"},"foo")," refers to a variable foo of a primitive type INTEGER)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A procedure call must have the correct number of arguments and the arguments' types must match those of formal parameters in the procedure declaration"))),(0,r.kt)("p",null,"It is much easier to enforce the above requirements when we have enough context about the program, namely, an intermediate representation in the form of an AST that we can walk and the symbol table with information about different program entities like variables, procedures, and functions."),(0,r.kt)("p",null,"After we implement the semantic analysis phase, the structure of our Pascal interpreter will look something like this:"),(0,r.kt)("img",{src:"./imgs/lsbasi_part13_img03.png",alt:""}),(0,r.kt)("p",null,"From the picture above you can see that our lexer will get source code as an input, transform that into tokens that the parser will consume and use them to verify that the program is grammatically correct, and then it will generate an abstract syntax tree that our new semantic analysis phase will use to enforce different Pascal language requirements. During the semantic analysis phase, the semantic analyzer will also build and use the symbol table. After the semantic analysis, our interpreter will take the AST, evaluate the program by walking the AST, and produce the program output."),(0,r.kt)("p",null,"Let's get into the details of the semantic analysis phase."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Symbols and symbol tables")),(0,r.kt)("p",null,"In the following section, we're going to discuss how to implement some semantic checks and how to build the symbol table: in other words, we are going to discuss how to perform a semantic analysis of our Pascal programs."),(0,r.kt)("p",null,"Even though ",(0,r.kt)("em",{parentName:"p"},"semantic analysis")," sounds fancy and deep, it's just another step after parsing our program and creating an AST to check the source program for some additional errors that the parser could not catch due to a lack of additional information (context)."),(0,r.kt)("p",null,"Today we're going to focus on the following two static semantic checks","*",":"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"That variables are declared before they are used"),(0,r.kt)("li",{parentName:"ol"},"That there are no duplicate variable declarations")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"*","ASIDE: Static semantic checks are the checks that we can make before interpreting (evaluating) the program, that is, before calling the interpret method on an instance of the Interpreter class. All the Pascal requirements mentioned before can be enforced with static semantic checks by walking an AST and using information from the symbol table."),(0,r.kt)("p",{parentName:"blockquote"},"Dynamic semantic checks, on the other hand, would require checks to be performed during the interpretation (evaluation) of the program. For example, a check that there is no division by zero, and that an array index is not out of bounds would be a dynamic semantic check. Our focus today is on static semantic checks.")),(0,r.kt)("p",null,"Let's start with our first check and make sure that in our Pascal programs variables are declared before they are used. Take a look at the following syntactically correct but semantically incorrect program:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"program Main;\n    var x : integer;\n\nbegin\n    x := y;\nend.\n")),(0,r.kt)("p",null,"The program above has one variable declaration and two variable references."),(0,r.kt)("img",{src:"./imgs/lsbasi_part13_img04.png",alt:""}),(0,r.kt)("p",null,"Here is the AST diagram for the above program:"),(0,r.kt)("img",{src:"./imgs/lsbasi_part13_img05.png",alt:""}),(0,r.kt)("p",null,"So, it is a grammatically (syntactically) correct program, but the program doesn't make sense because we don't even know what type the variable y has (that's why we need declarations) and if it will make sense to assign y to x. What if y is a string, does it make sense to assign a string to an integer? It does not, at least not in Pascal."),(0,r.kt)("p",null,"So the program above has a semantic error because the variable y is not declared and we don't know its type. In order for us to be able to catch errors like that, we need to learn how to check that variables are declared before they are used."),(0,r.kt)("p",null,"A both syntactically correct and semantically correct sample program would be like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"program Main;\n    var x,y : integer;\n\nbegin\n    x := x + y;\nend.\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"It has two variable declarations: x and y")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"It has also three variable references"))),(0,r.kt)("img",{src:"./imgs/lsbasi_part13_img06.png",alt:""}),(0,r.kt)("p",null,"The program is grammatically correct, all the variables are declared, and we can see that adding two integers and assigning the result to an integer makes perfect sense."),(0,r.kt)("p",null,"But how do we programmatically check that the variables (variable references) x and y in the assignment statement ",(0,r.kt)("inlineCode",{parentName:"p"},"x := x +y;")," have been declared?"),(0,r.kt)("p",null,"We can do this in several steps by implementing the following algorithm:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Go over all variable declarations"),(0,r.kt)("li",{parentName:"ol"},"For every variable declaration you encounter, collect all necessary information about the declared variable"),(0,r.kt)("li",{parentName:"ol"},"Store the collected information in some stash for future reference by using the variables name as a key"),(0,r.kt)("li",{parentName:"ol"},"When you see a variable reference, such as in the assignment statement ",(0,r.kt)("inlineCode",{parentName:"li"},"x := x + y"),", search the stash by the variable's name to see if the stash has any information about the variable. If it does, the variable has been declared. If it doesn't, the variable hasn't been declared yet, which is a semantic error.")),(0,r.kt)("p",null,"This is what a flowchart of our algorithm could look like:"),(0,r.kt)("img",{src:"./imgs/lsbasi_part13_img07.png",alt:""}),(0,r.kt)("p",null,"Before we can implement the algorithm, we need to answer several questions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A. What information about variables do we need to collect?"),(0,r.kt)("li",{parentName:"ul"},"B. Where and how should we store the collected information?"),(0,r.kt)("li",{parentName:"ul"},'C. How do we implement the "go over all variable declarations" step?')),(0,r.kt)("p",null,"So, what necessary information do we need to collect about a variable? Here are the important parts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Name (the name of a declared variable which we will be looking up variables by their names later)"),(0,r.kt)("li",{parentName:"ul"},"Category (what kind of identifier it is: variable, type, procedure, and so on)"),(0,r.kt)("li",{parentName:"ul"},"Type (for type checking)")),(0,r.kt)("p",null,"Symbols will hold that information (name, category, type) about the variables."),(0,r.kt)("p",null,"Again, a ",(0,r.kt)("em",{parentName:"p"},"symbol")," is an identifier of some program entity like a variable, subroutine, or built-in type."),(0,r.kt)("p",null,"In the code, we'll represent symbols with a class called ",(0,r.kt)("em",{parentName:"p"},"Symbol")," that has fields ",(0,r.kt)("em",{parentName:"p"},"name")," and ",(0,r.kt)("em",{parentName:"p"},"type")," :"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Symbol(object):\n    def __init__(self, name, type=None):\n        self.name = name\n        self.type = type\n")),(0,r.kt)("p",null,"What about the ",(0,r.kt)("em",{parentName:"p"},"category"),"?"),(0,r.kt)("p",null,"We will encode category into the class name. Alternatively, we could store the category of a symbol in the dedicated ",(0,r.kt)("em",{parentName:"p"},"category")," field of the ",(0,r.kt)("em",{parentName:"p"},"Symbol")," class as in:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Symbol(object):\n    def __init__(self, name, type=None):\n        self.name = name\n        self.type = type\n        self.category = category\n")),(0,r.kt)("p",null,"However, it's more explicit to create a hierarchy of classes where the name of the class indicates its category."),(0,r.kt)("p",null,"You can see that variables x and y are declared as integers from the sample code above. What is the ",(0,r.kt)("em",{parentName:"p"},"integer")," type? The integer type is another kind of symbol, a ",(0,r.kt)("em",{parentName:"p"},"built-in type symbol"),". It's called built-in because it does not have to be declared explicitly in a Pascal program."),(0,r.kt)("p",null,"It's the interpreter's responsibility to declare that type symbol and make it available to programmers."),(0,r.kt)("p",null,"We are going to make a separate class for built-in types called ",(0,r.kt)("em",{parentName:"p"},"BuiltinTypeSymbol"),". Here is the class definition for our built-in types:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class BuiltinTypesSymbol(Symbol):\n    def __init__(self, name):\n        super().__init__(name)\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return \"<{class_name}(name='{name}')\".format(\n            class_name=self.__class__.__name__,\n            name=self.name\n        )\n")),(0,r.kt)("p",null,"The class ",(0,r.kt)("em",{parentName:"p"},"BuiltinTypeSymbol")," inherits from the ",(0,r.kt)("em",{parentName:"p"},"Symbol")," class, and its constructor requires only the ",(0,r.kt)("em",{parentName:"p"},"name")," of the type, like ",(0,r.kt)("em",{parentName:"p"},"INTEGER")," or ",(0,r.kt)("em",{parentName:"p"},"REAL"),"."),(0,r.kt)("p",null,"The 'builtin type' category is encoded in the class name, as we discussed earlier, and the ",(0,r.kt)("em",{parentName:"p"},"type")," parameter from the base class is automatically set to ",(0,r.kt)("em",{parentName:"p"},"None")," when we create a new instance of the ",(0,r.kt)("em",{parentName:"p"},"BuiltinTypeSymbol")," class."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"ASIDE"),(0,r.kt)("p",{parentName:"blockquote"},"The double underscore or dunder (as in \u201cDouble Underscore\u201d) methods ",(0,r.kt)("inlineCode",{parentName:"p"},"__str__")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"__repr__")," are special Python methods. We've defined them to have a nice formatted message when we print a symbol object to standard output.")),(0,r.kt)("p",null,"By the way, built-in types are the reason why the type parameter in the Scope class constructor is an optional parameter."),(0,r.kt)("p",null,"Now comes the variable symbols."),(0,r.kt)("p",null,"We represent them in code by a ",(0,r.kt)("em",{parentName:"p"},"VarSymbol")," class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class VarSymbol(Symbol):\n    def __init__(self, name, type):\n        super().__init__(name, type)\n\n    def __str__ (self):\n        return \"<{class_name}(name='{name}', type='{type}')>\".format(\n            class_name=self.__class__.__name__,\n            name=self.name,\n            type=self.type,\n        )\n\n    __repr__ = __str__\n")),(0,r.kt)("p",null,"In this class, we made both the ",(0,r.kt)("em",{parentName:"p"},"name")," and the ",(0,r.kt)("em",{parentName:"p"},"type")," parameters required and the class name ",(0,r.kt)("em",{parentName:"p"},"VarSymbol")," clearly indicates that an instance of the class will identify a variable symbol (the category is ",(0,r.kt)("em",{parentName:"p"},"variable"),"). The ",(0,r.kt)("em",{parentName:"p"},"type")," parameter is an instance of the ",(0,r.kt)("em",{parentName:"p"},"BuiltinTypeSymbol")," class."),(0,r.kt)("p",null,'Okay, now onto "Where and how should we store the collected information?"'),(0,r.kt)("p",null,"The answer is the ",(0,r.kt)("em",{parentName:"p"},"symbol table"),". A symbol table is an abstract data type for tracking various symbols in source code. Think of it as a dictionary where the key is the symbol's name and the value is an instance of the symbol class (or one of its subclasses). We'll create a dedicated class aptly named ",(0,r.kt)("em",{parentName:"p"},"SymbolTable")," with an ",(0,r.kt)("em",{parentName:"p"},"insert")," method, which takes a symbol as a parameter and store it internally in the ",(0,r.kt)("em",{parentName:"p"},"_","symbol")," ordered dictionary using the symbol's name as a key and the symbol instance as a value, to store symbols into the table."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class SymbolTable(object):\n    def __init__(self):\n        self._symbols = OrderedDict()\n\n    def __str__(self):\n        symtab_header = 'Symbol table contents'\n        lines = ['\\n', symtab_header, '_' * len(symtab_header)]\n        lines.extend(\n            ( '%7s: %r' % (k,v) ) for k,v in self._symbols.items()\n        )\n        lines.append('\\n')\n        s = '\\n'.join(lines)\n        return s\n\n    __repr__ = __str__\n\n    def insert(self, symbol):\n        print('Insert: %s ' % symbol.name)\n        self._symbols[symbol.name] = symbol\n")),(0,r.kt)("p",null,"Now, \"How do we implement the 'go over all variable declarations' step?\""),(0,r.kt)("p",null,"It's pretty easy because we already have an AST built by the parser. What we need to do is just to create a new AST visitor class that will be responsible for walking over the tree and doing different actions when visiting ",(0,r.kt)("em",{parentName:"p"},"VarDecl")," AST nodes!"),(0,r.kt)("p",null,"Below is the skeleton for the ",(0,r.kt)("em",{parentName:"p"},"SemanticAnalyzer")," class with enough ",(0,r.kt)("em",{parentName:"p"},"visit_xxx")," methods to be able to successfully walk the AST of the sample program above:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class SemanticAnalyzer(NodeVisitor):\n    def __init__(self):\n        self.symtab = SymbolTable()\n\n    def visit_Block(self, node):\n        for declaration in node.declarations:\n            self.visit(declaration)\n        self.visit(node.compound_statement)\n\n    def visit_Program(self, node):\n        self.visit(node.block)\n\n    def visit_Compound(self, node):\n        for child in node.children:\n            self.visit(child)\n\n    def visit_NoOp(self, node):\n        pass\n\n    def visit_VarDecl(self, node):\n\n\n        # We have all the information we need to create a variable symbol\n        # Create the symbol and insert it into the symbol table\n        var_name = node.var_node.value\n        var_symbol = VarSymbol(var_name, type_symbol)\n")),(0,r.kt)("p",null,"Here are the steps of the algorithm for static semantic check again:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Go over all variable declarations"),(0,r.kt)("li",{parentName:"ol"},"For every variable declaration you encounter, collect all necessary information about the declared variable"),(0,r.kt)("li",{parentName:"ol"},"Store the collected information in some stash for future references by using the variable's name as a key"),(0,r.kt)("li",{parentName:"ol"},"When you see a variable reference such as in the assignment statement x := x + y, search the stash by the variable's name to see if the stash has any information about the variable. If it does, the variable has been declared. If it doesn't, the variable hasn't been declared yet, which is a semantic error.")),(0,r.kt)("p",null,"For step 4, we need make some changes to the symbol table and semantic analyzer:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Add a method to our symbol table that will be able to look up a symbol by name")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Update the semantic analyzer to look up a name in the symbol table every time it encounters a variable reference"))),(0,r.kt)("p",null,"So, adding the ",(0,r.kt)("em",{parentName:"p"},"lookup")," method, which takes a symbol name as a parameter and returns a symbol if it finds it or ",(0,r.kt)("em",{parentName:"p"},"None")," if not, to ",(0,r.kt)("em",{parentName:"p"},"SymbolTable"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class SymbolTable(object):\n    ...\n\n    def lookup(self,name):\n        print('Lookup: %s' % name)\n        symbol = self._symbols.get(name)\n\n        # 'symbol' is either an instance of the Symbol class or None\n        return symbol\n")),(0,r.kt)("p",null,"Also, we need update the ",(0,r.kt)("em",{parentName:"p"},"SymbolTable")," class to initialize built-in types by adding a method ",(0,r.kt)("em",{parentName:"p"},"_","init_builtins")," and calling it in the ",(0,r.kt)("em",{parentName:"p"},"SymbolTable"),"'s constructor."),(0,r.kt)("p",null,"Here is the full code for our updated ",(0,r.kt)("em",{parentName:"p"},"SymbolTable")," class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class SymbolTable(object):\n    def __init__(self):\n        self._symbols = OrderedDict()\n        self._init_builtins()\n\n    def _init_builtins(self):\n        self.insert(BuiltinTypeSymbol('INTEGER'))\n        self.insert(BuiltinTypeSymbol('REAL'))\n\n    def __str__(self):\n        symtab_header = 'Symbol table contents'\n        lines = ['\\n', symtab_header, '_' * len(symtab_header)]\n        lines.extend(\n            ('%7s: %r' % (key, value))\n            for key, value in self._symbols.items()\n        )\n        lines.append('\\n')\n        s = '\\n'.join(lines)\n        return s\n\n    __repr__ = __str__\n\n    def insert(self, symbol):\n        print('Insert: %s' % symbol.name)\n        self._symbols[symbol.name] = symbol\n\n    def lookup(self, name):\n        print('Lookup: %s' % name)\n        symbol = self._symbols.get(name)\n        # 'symbol' is either an instance of the Symbol class or None\n        return symbol\n")),(0,r.kt)("p",null,"We need to update the ",(0,r.kt)("em",{parentName:"p"},"SemanticAnalyzer"),"'s ",(0,r.kt)("em",{parentName:"p"},"visit_VarDecl")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def visit_VarDecl(self, node):\n    type_name = node.type_node.value\n    type_symbol = self.symtable.lookup(type_name)\n\n\n    # We have all the information we need to create a variable symbol.\n    # Create the symbol and insert it into the symbol table.\n    var_name = node.var_node.value\n    var_symbol = VarSymbol(var_name, type_symbol)\n    self.symtab.insert(var_symbol)\n")),(0,r.kt)("p",null,"Now let's switch our attention to variable references. What we need to do is extend our semantic analyzer so that every time it encounters a variable reference it would search the symbol table by the variable reference name using the symbol table's ",(0,r.kt)("em",{parentName:"p"},"lookup")," name. We would add a method called ",(0,r.kt)("em",{parentName:"p"},"visit_Var"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def visit_Var(self, node):\n    var_name = node.value\n    var_symbol = self.symtab.lookup(var_name)\n")),(0,r.kt)("p",null,"Usually we encounter the variable references in the ",(0,r.kt)("em",{parentName:"p"},"assignment")," or ",(0,r.kt)("em",{parentName:"p"},"operation"),", we need to add responding visit methods, for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def visit_Assign(self, node):\n    # right-hand side\n    self.visit(node.right)\n\n    # left-hande side\n    self.visit(node.left)\n\ndef visit_BinOp(self, node):\n    self.visit(node.left)\n    self.visit(node.right)\n")),(0,r.kt)("p",null,"Literally, we have implemented all steps of the algorithm for a static semantic check that verifies that all variables in the program are declared before they are used!"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Semantic Errors")),(0,r.kt)("p",null,"What if our program has a variable reference that doesn't resolve to any declaration; that is, it's not declared? That's a semantic error and we need to extend our semantic analyzer to signal that error."),(0,r.kt)("p",null,"To signal the error, we need to modify the ",(0,r.kt)("em",{parentName:"p"},"SemanticAnalyzer"),"'s ",(0,r.kt)("em",{parentName:"p"},"visit_Var")," method to throw an exception if the ",(0,r.kt)("em",{parentName:"p"},"lookup")," method cannot resolve a name to a symbol and returns ",(0,r.kt)("em",{parentName:"p"},"None"),". Here is the updated code for ",(0,r.kt)("em",{parentName:"p"},"visit_Var"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def visit_Var(self, node):\n    var_name = node.value\n    var_symbol = self.symtab.lookup(var_name)\n    if var_symbol is None:\n        raise Exception(\n            \"Error: Symbol(identifier) not found '%s'\" % var_name\n        )\n")),(0,r.kt)("p",null,"That is good for reference checking, now we need to move on to another static semantic check."),(0,r.kt)("p",null,"For fun and profit, let's extend the semantic analyzer to check duplicate identifiers in declarations. We need to modify the ",(0,r.kt)("em",{parentName:"p"},"visit_VarDecl")," method to check whether the symbol table already has a symbol with the same name before inserting a new symbol."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def visit_VarDecl(self, node):\n    type_name = node.type_node.value\n    type_symbol = self.symtab.lookup(type_name)\n\n    # We have all the information we need to create a variable symbol.\n    # Create the symbol and insert it into the symbol table.\n    var_name = node.var_node.value\n    var_symbol = VarSymbol(var_name, type_symbol)\n\n    # Signal an error if the table alrady has a symbol\n    # with the same name\n    if self.symtab.lookup(var_name) is not None:\n        raise Exception(\n            \"Error: Duplicate identifier '%s' found\" % var_name\n        )\n\n    self.symtab.insert(var_symbol)\n")),(0,r.kt)("p",null,"Next, we'll tackle the topic of scopes and semantic checks in the presence of nested scopes."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Appendix")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"\"\"\" SPI - Simple Pascal Interpreter. Part 13.\"\"\"\n\nfrom collections import OrderedDict\n\n###############################################################################\n#                                                                             #\n#  LEXER                                                                      #\n#                                                                             #\n###############################################################################\n\n# Token types\n#\n# EOF (end-of-file) token is used to indicate that\n# there is no more input left for lexical analysis\nINTEGER = 'INTEGER'\nREAL = 'REAL'\nINTEGER_CONST = 'INTEGER_CONST'\nREAL_CONST = 'REAL_CONST'\nPLUS = 'PLUS'\nMINUS = 'MINUS'\nMUL = 'MUL'\nINTEGER_DIV = 'INTEGER_DIV'\nFLOAT_DIV = 'FLOAT_DIV'\nLPAREN = 'LPAREN'\nRPAREN = 'RPAREN'\nID = 'ID'\nASSIGN = 'ASSIGN'\nBEGIN = 'BEGIN'\nEND = 'END'\nSEMI = 'SEMI'\nDOT = 'DOT'\nPROGRAM = 'PROGRAM'\nVAR = 'VAR'\nCOLON = 'COLON'\nCOMMA = 'COMMA'\nPROCEDURE = 'PROCEDURE'\nEOF = 'EOF'\n\n\nclass Token(object):\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n\n    def __str__(self):\n        \"\"\"String representation of the class instance.\n\n        Examples:\n            Token(INTEGER, 3)\n            Token(PLUS, '+')\n            Token(MUL, '*')\n        \"\"\"\n        return 'Token({type}, {value})'.format(\n            type=self.type,\n            value=repr(self.value)\n        )\n\n    def __repr__(self):\n        return self.__str__()\n\n\nRESERVED_KEYWORDS = {\n    'PROGRAM': Token(PROGRAM, 'PROGRAM'),\n    'PROCEDURE': Token(PROCEDURE, 'PROCEDURE'),\n    'VAR': Token(VAR, 'VAR'),\n    'DIV': Token(INTEGER_DIV, 'DIV'),\n    'INTEGER': Token(INTEGER, 'INTEGER'),\n    'REAL': Token(REAL, 'REAL'),\n    'BEGIN': Token(BEGIN, 'BEGIN'),\n    'END': Token(END, 'END'),\n}\n\n\nclass Lexer(object):\n    def __init__(self, text):\n        # client string input, e.g. \"4 + 2 * 3 - 6 / 2\"\n        self.text = text\n        # self.pos is an index into self.text\n        self.pos = 0\n        self.current_char = self.text[self.pos]\n\n    def error(self):\n        raise Exception('Invalid character')\n\n    def advance(self):\n        \"\"\"Advance the `pos` pointer and set the `current_char` variable.\"\"\"\n        self.pos += 1\n        if self.pos > len(self.text) - 1:\n            self.current_char = None  # Indicates end of input\n        else:\n            self.current_char = self.text[self.pos]\n\n    def peek(self):\n        peek_pos = self.pos + 1\n        if peek_pos > len(self.text) - 1:\n            return None\n        else:\n            return self.text[peek_pos]\n\n    def skip_whitespace(self):\n        while self.current_char is not None and self.current_char.isspace():\n            self.advance()\n\n    def skip_comment(self):\n        while self.current_char != '}':\n            self.advance()\n        self.advance()  # the closing curly brace\n\n    def number(self):\n        \"\"\"Return a (multidigit) integer or float consumed from the input.\"\"\"\n        result = ''\n        while self.current_char is not None and self.current_char.isdigit():\n            result += self.current_char\n            self.advance()\n\n        if self.current_char == '.':\n            result += self.current_char\n            self.advance()\n\n            while (\n                self.current_char is not None and\n                self.current_char.isdigit()\n            ):\n                result += self.current_char\n                self.advance()\n\n            token = Token(REAL_CONST, float(result))\n        else:\n            token = Token(INTEGER_CONST, int(result))\n\n        return token\n\n    def _id(self):\n        \"\"\"Handle identifiers and reserved keywords\"\"\"\n        result = ''\n        while self.current_char is not None and self.current_char.isalnum():\n            result += self.current_char\n            self.advance()\n\n        token = RESERVED_KEYWORDS.get(result, Token(ID, result))\n        return token\n\n    def get_next_token(self):\n        \"\"\"Lexical analyzer (also known as scanner or tokenizer)\n\n        This method is responsible for breaking a sentence\n        apart into tokens. One token at a time.\n        \"\"\"\n        while self.current_char is not None:\n\n            if self.current_char.isspace():\n                self.skip_whitespace()\n                continue\n\n            if self.current_char == '{':\n                self.advance()\n                self.skip_comment()\n                continue\n\n            if self.current_char.isalpha():\n                return self._id()\n\n            if self.current_char.isdigit():\n                return self.number()\n\n            if self.current_char == ':' and self.peek() == '=':\n                self.advance()\n                self.advance()\n                return Token(ASSIGN, ':=')\n\n            if self.current_char == ';':\n                self.advance()\n                return Token(SEMI, ';')\n\n            if self.current_char == ':':\n                self.advance()\n                return Token(COLON, ':')\n\n            if self.current_char == ',':\n                self.advance()\n                return Token(COMMA, ',')\n\n            if self.current_char == '+':\n                self.advance()\n                return Token(PLUS, '+')\n\n            if self.current_char == '-':\n                self.advance()\n                return Token(MINUS, '-')\n\n            if self.current_char == '*':\n                self.advance()\n                return Token(MUL, '*')\n\n            if self.current_char == '/':\n                self.advance()\n                return Token(FLOAT_DIV, '/')\n\n            if self.current_char == '(':\n                self.advance()\n                return Token(LPAREN, '(')\n\n            if self.current_char == ')':\n                self.advance()\n                return Token(RPAREN, ')')\n\n            if self.current_char == '.':\n                self.advance()\n                return Token(DOT, '.')\n\n            self.error()\n\n        return Token(EOF, None)\n\n\n###############################################################################\n#                                                                             #\n#  PARSER                                                                     #\n#                                                                             #\n###############################################################################\nclass AST(object):\n    pass\n\n\nclass BinOp(AST):\n    def __init__(self, left, op, right):\n        self.left = left\n        self.token = self.op = op\n        self.right = right\n\n\nclass Num(AST):\n    def __init__(self, token):\n        self.token = token\n        self.value = token.value\n\n\nclass UnaryOp(AST):\n    def __init__(self, op, expr):\n        self.token = self.op = op\n        self.expr = expr\n\n\nclass Compound(AST):\n    \"\"\"Represents a 'BEGIN ... END' block\"\"\"\n\n    def __init__(self):\n        self.children = []\n\n\nclass Assign(AST):\n    def __init__(self, left, op, right):\n        self.left = left\n        self.token = self.op = op\n        self.right = right\n\n\nclass Var(AST):\n    \"\"\"The Var node is constructed out of ID token.\"\"\"\n\n    def __init__(self, token):\n        self.token = token\n        self.value = token.value\n\n\nclass NoOp(AST):\n    pass\n\n\nclass Program(AST):\n    def __init__(self, name, block):\n        self.name = name\n        self.block = block\n\n\nclass Block(AST):\n    def __init__(self, declarations, compound_statement):\n        self.declarations = declarations\n        self.compound_statement = compound_statement\n\n\nclass VarDecl(AST):\n    def __init__(self, var_node, type_node):\n        self.var_node = var_node\n        self.type_node = type_node\n\n\nclass Type(AST):\n    def __init__(self, token):\n        self.token = token\n        self.value = token.value\n\n\nclass ProcedureDecl(AST):\n    def __init__(self, proc_name, block_node):\n        self.proc_name = proc_name\n        self.block_node = block_node\n\n\nclass Parser(object):\n    def __init__(self, lexer):\n        self.lexer = lexer\n        # set current token to the first token taken from the input\n        self.current_token = self.lexer.get_next_token()\n\n    def error(self):\n        raise Exception('Invalid syntax')\n\n    def eat(self, token_type):\n        # compare the current token type with the passed token\n        # type and if they match then \"eat\" the current token\n        # and assign the next token to the self.current_token,\n        # otherwise raise an exception.\n        if self.current_token.type == token_type:\n            self.current_token = self.lexer.get_next_token()\n        else:\n            self.error()\n\n    def program(self):\n        \"\"\"program : PROGRAM variable SEMI block DOT\"\"\"\n        self.eat(PROGRAM)\n        var_node = self.variable()\n        prog_name = var_node.value\n        self.eat(SEMI)\n        block_node = self.block()\n        program_node = Program(prog_name, block_node)\n        self.eat(DOT)\n        return program_node\n\n    def block(self):\n        \"\"\"block : declarations compound_statement\"\"\"\n        declaration_nodes = self.declarations()\n        compound_statement_node = self.compound_statement()\n        node = Block(declaration_nodes, compound_statement_node)\n        return node\n\n    def declarations(self):\n        \"\"\"declarations : VAR (variable_declaration SEMI)+\n                        | (PROCEDURE ID SEMI block SEMI)*\n                        | empty\n        \"\"\"\n        declarations = []\n        if self.current_token.type == VAR:\n            self.eat(VAR)\n            while self.current_token.type == ID:\n                var_decl = self.variable_declaration()\n                declarations.extend(var_decl)\n                self.eat(SEMI)\n\n        while self.current_token.type == PROCEDURE:\n            self.eat(PROCEDURE)\n            proc_name = self.current_token.value\n            self.eat(ID)\n            self.eat(SEMI)\n            block_node = self.block()\n            proc_decl = ProcedureDecl(proc_name, block_node)\n            declarations.append(proc_decl)\n            self.eat(SEMI)\n\n        return declarations\n\n    def variable_declaration(self):\n        \"\"\"variable_declaration : ID (COMMA ID)* COLON type_spec\"\"\"\n        var_nodes = [Var(self.current_token)]  # first ID\n        self.eat(ID)\n\n        while self.current_token.type == COMMA:\n            self.eat(COMMA)\n            var_nodes.append(Var(self.current_token))\n            self.eat(ID)\n\n        self.eat(COLON)\n\n        type_node = self.type_spec()\n        var_declarations = [\n            VarDecl(var_node, type_node) for var_node in var_nodes\n        ]\n        return var_declarations\n\n    def type_spec(self):\n        \"\"\"type_spec : INTEGER\n                     | REAL\n        \"\"\"\n        token = self.current_token\n        if self.current_token.type == INTEGER:\n            self.eat(INTEGER)\n        else:\n            self.eat(REAL)\n        node = Type(token)\n        return node\n\n    def compound_statement(self):\n        \"\"\"\n        compound_statement: BEGIN statement_list END\n        \"\"\"\n        self.eat(BEGIN)\n        nodes = self.statement_list()\n        self.eat(END)\n\n        root = Compound()\n        for node in nodes:\n            root.children.append(node)\n\n        return root\n\n    def statement_list(self):\n        \"\"\"\n        statement_list : statement\n                       | statement SEMI statement_list\n        \"\"\"\n        node = self.statement()\n\n        results = [node]\n\n        while self.current_token.type == SEMI:\n            self.eat(SEMI)\n            results.append(self.statement())\n\n        return results\n\n    def statement(self):\n        \"\"\"\n        statement : compound_statement\n                  | assignment_statement\n                  | empty\n        \"\"\"\n        if self.current_token.type == BEGIN:\n            node = self.compound_statement()\n        elif self.current_token.type == ID:\n            node = self.assignment_statement()\n        else:\n            node = self.empty()\n        return node\n\n    def assignment_statement(self):\n        \"\"\"\n        assignment_statement : variable ASSIGN expr\n        \"\"\"\n        left = self.variable()\n        token = self.current_token\n        self.eat(ASSIGN)\n        right = self.expr()\n        node = Assign(left, token, right)\n        return node\n\n    def variable(self):\n        \"\"\"\n        variable : ID\n        \"\"\"\n        node = Var(self.current_token)\n        self.eat(ID)\n        return node\n\n    def empty(self):\n        \"\"\"An empty production\"\"\"\n        return NoOp()\n\n    def expr(self):\n        \"\"\"\n        expr : term ((PLUS | MINUS) term)*\n        \"\"\"\n        node = self.term()\n\n        while self.current_token.type in (PLUS, MINUS):\n            token = self.current_token\n            if token.type == PLUS:\n                self.eat(PLUS)\n            elif token.type == MINUS:\n                self.eat(MINUS)\n\n            node = BinOp(left=node, op=token, right=self.term())\n\n        return node\n\n    def term(self):\n        \"\"\"term : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*\"\"\"\n        node = self.factor()\n\n        while self.current_token.type in (MUL, INTEGER_DIV, FLOAT_DIV):\n            token = self.current_token\n            if token.type == MUL:\n                self.eat(MUL)\n            elif token.type == INTEGER_DIV:\n                self.eat(INTEGER_DIV)\n            elif token.type == FLOAT_DIV:\n                self.eat(FLOAT_DIV)\n\n            node = BinOp(left=node, op=token, right=self.factor())\n\n        return node\n\n    def factor(self):\n        \"\"\"factor : PLUS factor\n                  | MINUS factor\n                  | INTEGER_CONST\n                  | REAL_CONST\n                  | LPAREN expr RPAREN\n                  | variable\n        \"\"\"\n        token = self.current_token\n        if token.type == PLUS:\n            self.eat(PLUS)\n            node = UnaryOp(token, self.factor())\n            return node\n        elif token.type == MINUS:\n            self.eat(MINUS)\n            node = UnaryOp(token, self.factor())\n            return node\n        elif token.type == INTEGER_CONST:\n            self.eat(INTEGER_CONST)\n            return Num(token)\n        elif token.type == REAL_CONST:\n            self.eat(REAL_CONST)\n            return Num(token)\n        elif token.type == LPAREN:\n            self.eat(LPAREN)\n            node = self.expr()\n            self.eat(RPAREN)\n            return node\n        else:\n            node = self.variable()\n            return node\n\n    def parse(self):\n        \"\"\"\n        program : PROGRAM variable SEMI block DOT\n\n        block : declarations compound_statement\n\n        declarations : VAR (variable_declaration SEMI)+\n                     | (PROCEDURE ID SEMI block SEMI)*\n                     | empty\n\n        variable_declaration : ID (COMMA ID)* COLON type_spec\n\n        type_spec : INTEGER\n\n        compound_statement : BEGIN statement_list END\n\n        statement_list : statement\n                       | statement SEMI statement_list\n\n        statement : compound_statement\n                  | assignment_statement\n                  | empty\n\n        assignment_statement : variable ASSIGN expr\n\n        empty :\n\n        expr : term ((PLUS | MINUS) term)*\n\n        term : factor ((MUL | INTEGER_DIV | FLOAT_DIV) factor)*\n\n        factor : PLUS factor\n               | MINUS factor\n               | INTEGER_CONST\n               | REAL_CONST\n               | LPAREN expr RPAREN\n               | variable\n\n        variable: ID\n        \"\"\"\n        node = self.program()\n        if self.current_token.type != EOF:\n            self.error()\n\n        return node\n\n\n###############################################################################\n#                                                                             #\n#  AST visitors (walkers)                                                     #\n#                                                                             #\n###############################################################################\n\nclass NodeVisitor(object):\n    def visit(self, node):\n        method_name = 'visit_' + type(node).__name__\n        visitor = getattr(self, method_name, self.generic_visit)\n        return visitor(node)\n\n    def generic_visit(self, node):\n        raise Exception('No visit_{} method'.format(type(node).__name__))\n\n\n###############################################################################\n#                                                                             #\n#  SYMBOLS and SYMBOL TABLE                                                   #\n#                                                                             #\n###############################################################################\n\nclass Symbol(object):\n    def __init__(self, name, type=None):\n        self.name = name\n        self.type = type\n\n\nclass VarSymbol(Symbol):\n    def __init__(self, name, type):\n        super().__init__(name, type)\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return \"<{class_name}(name='{name}', type='{type}')>\".format(\n            class_name=self.__class__.__name__,\n            name=self.name,\n            type=self.type\n        )\n\n    __repr__ = __str__\n\n\nclass BuiltinTypeSymbol(Symbol):\n    def __init__(self, name):\n        super().__init__(name)\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return \"<{class_name}(name='{name}')>\".format(\n            class_name=self.__class__.__name__,\n            name=self.name\n        )\n\n\nclass SymbolTable(object):\n    def __init__(self):\n        self._symbols = OrderedDict()\n        self._init_builtins()\n\n    def _init_builtins(self):\n        self.insert(BuiltinTypeSymbol('INTEGER'))\n        self.insert(BuiltinTypeSymbol('REAL'))\n\n    def __str__(self):\n        symtab_header = 'Symbol table contents'\n        lines = ['\\n', symtab_header, '_' * len(symtab_header)]\n        lines.extend(\n            ('%7s: %r' % (k,v)) for k,v in self._symbols.items()\n        )\n        lines.append('\\n')\n        s = '\\n'.join(lines)\n        return s\n\n    __repr__ = __str__\n\n    def insert(self, symbol):\n        print('Insert: %s' % symbol)\n        self._symbols[symbol.name] = symbol\n\n    def lookup(self, name):\n        print('Lookup: %s' % name)\n        symbol = self._symbols.get(name)\n        # 'symbol' is either an instance of the Symbol class or 'None'\n        return symbol\n\n\nclass SemanticAnalyzer(NodeVisitor):\n    def __init__(self):\n        self.symtab = SymbolTable()\n\n    def visit_Block(self, node):\n        for declaration in node.declarations:\n            self.visit(declaration)\n        self.visit(node.compound_statement)\n\n    def visit_Program(self, node):\n        self.visit(node.block)\n\n    def visit_Compound(self, node):\n        for child in node.children:\n            self.visit(child)\n\n    def visit_Num(self, node):\n        pass\n\n    def visit_NoOp(self, node):\n        pass\n\n    def visit_BinOp(self, node):\n        self.visit(node.left)\n        self.visit(node.right)\n\n    def visit_UnaryOp(self, node):\n        self.visit(node.expr)\n\n    def visit_VarDecl(self, node):\n        type_name = node.type_node.value\n        type_symbol = self.symtab.lookup(type_name)\n\n        # we have all the information to create a variable symbol.\n        # Create the symbol and insert it into the symbol table.\n\n        var_name = node.var_node.value\n        var_symbol = VarSymbol(var_name, type_symbol)\n\n        if self.symtab.lookup(var_name) is not None:\n            raise Exception(\n                \"Error: Duplicate identifier '%s' found\" % var_name\n            )\n\n        self.symtab.insert(var_symbol)\n\n    def visit_Assign(self, node):\n        self.visit(node.right)\n\n        self.visit(node.left)\n\n    def visit_Var(self, node):\n        var_name = node.value\n        var_symbol = self.symtab.lookup(var_name)\n\n        if var_symbol is None:\n            raise Exception(\n                \"Error: Symbol(identifier) not found '%s'\" % var_name\n            )\n\n\n###############################################################################\n#                                                                             #\n#  INTERPRETER                                                                #\n#                                                                             #\n###############################################################################\n\nclass Interpreter(NodeVisitor):\n    def __init__(self, tree):\n        self.tree = tree\n        self.GLOBAL_MEMORY = OrderedDict()\n\n    def visit_Program(self, node):\n        self.visit(node.block)\n\n    def visit_Block(self, node):\n        for declaration in node.declarations:\n            self.visit(declaration)\n        self.visit(node.compound_statement)\n\n    def visit_VarDecl(self, node):\n        pass\n\n    def visit_Type(self, node):\n        pass\n\n    def visit_BinOp(self, node):\n        if node.op.type == PLUS:\n            return self.visit(node.left) + self.visit(node.right)\n        elif node.op.type == MINUS:\n            return self.visit(node.left) - self.visit(node.right)\n        elif node.op.type == MUL:\n            return self.visit(node.left) * self.visit(node.right)\n        elif node.op.type == INTEGER_DIV:\n            return self.visit(node.left) // self.visit(node.right)\n        elif node.op.type == FLOAT_DIV:\n            return float(self.visit(node.left)) / float(self.visit(node.right))\n\n    def visit_Num(self, node):\n        return node.value\n\n    def visit_UnaryOp(self, node):\n        op = node.op.type\n        if op == PLUS:\n            return +self.visit(node.expr)\n        elif op == MINUS:\n            return -self.visit(node.expr)\n\n    def visit_Compound(self, node):\n        for child in node.children:\n            self.visit(child)\n\n    def visit_Assign(self, node):\n        var_name = node.left.value\n        var_value = self.visit(node.right)\n        self.GLOBAL_MEMORY[var_name] = var_value\n\n    def visit_Var(self, node):\n        var_name = node.value\n        var_value = self.GLOBAL_MEMORY.get(var_name)\n        return var_value\n\n    def visit_NoOp(self, node):\n        pass\n\n    def visit_ProcedureDecl(self, node):\n        pass\n\n    def interpret(self):\n        tree = self.tree\n        if tree is None:\n            return ''\n        return self.visit(tree)\n\n\ndef main():\n    import sys\n    text = open(sys.argv[1], 'r').read()\n\n    lexer = Lexer(text)\n    parser = Parser(lexer)\n    tree = parser.parse()\n\n    semantic_analyzer = SemanticAnalyzer()\n\n    try:\n        semantic_analyzer.visit(tree)\n    except Exception as e:\n        print(e)\n\n    print(semantic_analyzer.symtab)\n\n    # interpreter = Interpreter(tree)\n    # result = interpreter.interpret()\n    # print('-----')\n    # print('Run-time GLOBAL_MEMORY contents:')\n    # for k, v in sorted(interpreter.GLOBAL_MEMORY.items()):\n    #     print('%s = %s' % (k, v))\n\n\nif __name__ == '__main__':\n    main()\n\n")))}p.isMDXComponent=!0}}]);