"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4447],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>d});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},h="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=p(a),m=i,d=h["".concat(l,".").concat(m)]||h[m]||c[m]||o;return a?n.createElement(d,r(r({ref:t},u),{},{components:a})):n.createElement(d,r({ref:t},u))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=a[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},47390:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=a(87462),i=(a(67294),a(3905));const o={title:"Metalinguistic Abstraction",tags:["sicp"]},r=void 0,s={unversionedId:"sicp/metalinguistic-abstraction",id:"sicp/metalinguistic-abstraction",title:"Metalinguistic Abstraction",description:"There is one general techniques for expert programmers to control the complexity of sophisticated systems:",source:"@site/docs/sicp/04-metalinguistic-abstraction.md",sourceDirName:"sicp",slug:"/sicp/metalinguistic-abstraction",permalink:"/docs/sicp/metalinguistic-abstraction",draft:!1,tags:[{label:"sicp",permalink:"/docs/tags/sicp"}],version:"current",sidebarPosition:4,frontMatter:{title:"Metalinguistic Abstraction",tags:["sicp"]},sidebar:"tutorialSidebar",previous:{title:"Modularity, Objects, and State",permalink:"/docs/sicp/modularity-objects-state"},next:{title:"Computing with Register Machines",permalink:"/docs/sicp/computing-with-register-machines"}},l={},p=[{value:"The Metacircular Evaluator",id:"the-metacircular-evaluator",level:2},{value:"The Core of the Evaluator",id:"the-core-of-the-evaluator",level:3},{value:"Eval",id:"eval",level:4},{value:"Apply",id:"apply",level:4},{value:"Evaluator Data Structures",id:"evaluator-data-structures",level:3},{value:"Running the Evaluator as a Program",id:"running-the-evaluator-as-a-program",level:3},{value:"Data as Programs",id:"data-as-programs",level:3},{value:"Internal Definitions",id:"internal-definitions",level:3},{value:"Separating Syntactic Analysis from Execution",id:"separating-syntactic-analysis-from-execution",level:3},{value:"Variations on a Scheme--Lazy Evaluation",id:"variations-on-a-scheme--lazy-evaluation",level:2},{value:"Normal Order and Applicative Order",id:"normal-order-and-applicative-order",level:3},{value:"An Interpreter with Lazy Evaluation",id:"an-interpreter-with-lazy-evaluation",level:3},{value:"Streams as Lazy Lists",id:"streams-as-lazy-lists",level:3},{value:"Variations on a Scheme--Nondeterministic Computing",id:"variations-on-a-scheme--nondeterministic-computing",level:2},{value:"Amb and Search",id:"amb-and-search",level:3},{value:"Implementing the Amb Evaluator",id:"implementing-the-amb-evaluator",level:3},{value:"Logic Programming",id:"logic-programming",level:2},{value:"Deductive Information Retrieval",id:"deductive-information-retrieval",level:3},{value:"How the Query System Works",id:"how-the-query-system-works",level:3},{value:"Is Logic Programming Mathematical Logic?",id:"is-logic-programming-mathematical-logic",level:3}],u={toc:p};function h(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"There is one general techniques for expert programmers to control the complexity of sophisticated systems:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Combining primitive elements to form compound objects")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Abstracting compound objects to form higher-level building blocks,")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Preserving modularity by adopting appropriate large-scale views of system structure."))),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Metalinguistic abstraction")," - establishing new languages - plays an important role in all branches of engineering design."),(0,i.kt)("p",null,"In programming not only can programmers formulate new languages, but they can also implement these languages by constructing evaluators."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"An ",(0,i.kt)("em",{parentName:"p"},"evaluator")," (or ",(0,i.kt)("em",{parentName:"p"},"interpreter"),") for a programming language is a procedure that, when applied to an expression of the language, performs the actions required to evaluate that expression.")),(0,i.kt)("p",null,"It is no exaggeration to regard this as the most fundamental idea in programming:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"The evaluator, which determines the meaning of expressions in a programming language, is just another program.\n")),(0,i.kt)("h2",{id:"the-metacircular-evaluator"},"The Metacircular Evaluator"),(0,i.kt)("p",null,"Evaluation is a process, so it is appropriate to describe teh evaluation process using Lisp, which is the tool for describing processes."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"An evaluator that is written in the same language that it evaluates is said to be ",(0,i.kt)("em",{parentName:"p"},"metacircular"),".")),(0,i.kt)("p",null,"The metacircular evaluator is essentially a Scheme formulation of the environment model of evaluation. The model has two basic parts:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"To evaluate a combination (a compound expression other than a special form), evaluate the subexpressions and then apply the value of the operator subexpression to the values of the operand subexpressions.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"To apply a compound procedure to a set of arguments, evaluate the body of the procedure in a new environment. To construct this environment, extend the environment part of the procedure object by a frame in which the formal parameters of the procedure are bound to the arguments to which the procedure is applied."))),(0,i.kt)("p",null,"These two rules describe the essence of the evaluation process, a basic cycle in which expressions to be evaluated in environments are reduced to procedures to be applied to arguments, which in turn are reduced to new expressions to be evaluated in new environments, and so on, until we get down to symbols, whose values are looked up in the environment, and to primitive procedures, which are applied directly."),(0,i.kt)("p",null,"This evaluation cycle will be embodied by the interplay between the two critical procedures in the evaluator, ",(0,i.kt)("inlineCode",{parentName:"p"},"eval")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"apply"),"."),(0,i.kt)("p",null,"The implementation of the evaluator will depend upon procedures that define the ",(0,i.kt)("em",{parentName:"p"},"syntax")," of the expressions to be evaluated."),(0,i.kt)("h3",{id:"the-core-of-the-evaluator"},"The Core of the Evaluator"),(0,i.kt)("h4",{id:"eval"},"Eval"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"eval")," takes as arguments an expression and an environment. It classifies the expression and directs its evaluation. ",(0,i.kt)("inlineCode",{parentName:"p"},"eval")," is structured as a case analysis of the syntactic type of the expression to be evaluated."),(0,i.kt)("p",null,"In order to keep the procedure general, we express the determination of the type of an expression abstractly, making no commitment to any particular representation for the various types of expressions. Each type of expression has a predicate that tests for it and an abstract means for selecting its parts. This ",(0,i.kt)("em",{parentName:"p"},"abstract syntax")," makes it easy to see how we can change the syntax of the language by using the same evaluator, but with a different collection of syntax procedures."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Primitive expressions")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For self-evaluating expressions, such as numbers, ",(0,i.kt)("inlineCode",{parentName:"p"},"eval")," returns the expression itself.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"eval")," must look up variables in the environment to find their values."))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Special forms")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For quoted expressions, ",(0,i.kt)("inlineCode",{parentName:"p"},"eval")," returns the expression that was quoted.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"An assignment to (or a definition of) a variable must recursively call ",(0,i.kt)("inlineCode",{parentName:"p"},"eval")," to compute the new value to be associated with the variable. The environment must be modified to change (or create) the binding of the variable.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"An ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," expression requires special processing of its parts, so as to evaluate the consequent if the predicate is true, and otherwise to evaluate the alternative.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A ",(0,i.kt)("inlineCode",{parentName:"p"},"lambda")," expression must be transformed into an applicable procedure by packaging together teh parameters and body specified by the ",(0,i.kt)("inlineCode",{parentName:"p"},"lambda")," expression with the environment of the evaluation.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A ",(0,i.kt)("inlineCode",{parentName:"p"},"begin")," expression requires evaluating its sequence of expressions in the order in which they appear.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A case analysis (",(0,i.kt)("inlineCode",{parentName:"p"},"cond"),") is transformed into a nest of ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," expressions and then evaluated."))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Combinations")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"For a procedure application, ",(0,i.kt)("inlineCode",{parentName:"li"},"eval")," must evaluate the operator part and the operands of the combination. The resulting procedure and arguments are passed to ",(0,i.kt)("inlineCode",{parentName:"li"},"apply"),", which handles the actual procedure application.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"In most Lisp implementations, dispatching on the type of an expression is done in a ",(0,i.kt)("em",{parentName:"p"},"data-directed style"),". This allows a programmer to add new types of expressions that ",(0,i.kt)("inlineCode",{parentName:"p"},"eval")," can distinguish, without modifying the definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"eval")," itself.")),(0,i.kt)("h4",{id:"apply"},"Apply"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"apply")," takes two arguments, a procedure and a list of arguments to which the procedure should be applied."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"apply")," classifies procedures into two kinds:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It calls ",(0,i.kt)("inlineCode",{parentName:"p"},"apply-primitive-procedure")," to apply primitives;")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It applies compound procedures by sequentially evaluating the expressions that make up the body of the procedure."))),(0,i.kt)("p",null,"The environment for the evaluation of the body of a compound procedure is constructed by extending the base environment carried by the procedure to include a frame that binds the parameters of the procedure to the arguments to which the procedure is to be applied."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Procedure arguments")),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"eval")," processes a procedure application, it uses some helper procedure to produce the list of arguments to which the procedure is to be applied."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Conditionals")),(0,i.kt)("p",null,"First, we would use some helper procedure to evaluate the predicate part of an ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," expression in the given environment. If the result is true, we continue to evaluate the consequent, otherwise it evaluates the alternative:"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Sequences")),(0,i.kt)("p",null,"This is used by ",(0,i.kt)("inlineCode",{parentName:"p"},"apply")," to evaluate the sequence of expressions in a procedure body and by ",(0,i.kt)("inlineCode",{parentName:"p"},"eval")," te evaluate the sequence of expressions is a ",(0,i.kt)("inlineCode",{parentName:"p"},"begin")," expression. It takes as arguments a sequence of expressions and an environment, and evaluates the expressions in the order in which they occur. The value returned is the value of the final expression."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The sequence-evaluation is done by recursivly: evaluate the first expression and use the sequence-evaluation on the rest part of the expressions, until we reached the final expression.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Assignments and definitions")),(0,i.kt)("p",null,"This procedure calls ",(0,i.kt)("inlineCode",{parentName:"p"},"eval")," to find the value to be assigned and transmits the variable and the resulting value to set to variable, which is installed in the designated environment."),(0,i.kt)("h3",{id:"evaluator-data-structures"},"Evaluator Data Structures"),(0,i.kt)("p",null,"In addition to defining the external syntax of expressions, the evaluator implementation must also define the data structures that the evaluator manipulates internally, as part of the execution of a program, such as the representation of procedures and environments and the representation of true and false."),(0,i.kt)("p",null,"We use data abstraction to isolate the rest of the evaluator from the detailed choice of representation, we could change the environment representation as we wish. In a production-quality Lisp system, the speed of the evaluator's environment operations, especially that of variable lookup, has a major impact on the performance of the system."),(0,i.kt)("h3",{id:"running-the-evaluator-as-a-program"},"Running the Evaluator as a Program"),(0,i.kt)("p",null,"Givent the evaluator, we have a description of the process by which Lisp expressions are evaluated. One advantage of expressing the evaluator as a program is that we can run the program. This gives us, running within Lisp, a working model of how Lisp itself evaluates expressions. This can serve as a framework for experimenting with evaluation rules."),(0,i.kt)("p",null,"The evaluator program reduces expressions ultimately to the application of primitive procedures. Therefore, all that we need to run the evaluator is to create a mechanism that calls on the underlying Lisp system to model the application of primitive procedures."),(0,i.kt)("p",null,"There must be a binding for each primitive procedure name, so that when ",(0,i.kt)("inlineCode",{parentName:"p"},"eval")," evaluates the operator of an application of a primitive, it will find an object to pass to ",(0,i.kt)("inlineCode",{parentName:"p"},"apply"),". We thus set up a global environment that associates unique objects with the names of the primitive procedures that can appear in the expressions we will be evaluating. The global environment also includes bindings for the symbols ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),", so they can be used as variables in expressions to be evaluated."),(0,i.kt)("p",null,"For convenience in running the metacircular evaluator, we provide a ",(0,i.kt)("em",{parentName:"p"},"driver loop")," that models the read-eval-print loop of the underlying Lisp system. It prints a prompt, reads an input expression, evaluates this expression in the global environment, and prints the result. We precede each printed result by an output prompt so as to distinguish the value of the expression from other output that may be printed."),(0,i.kt)("h3",{id:"data-as-programs"},"Data as Programs"),(0,i.kt)("p",null,"One operational view of the meaning of a program is that a program is a description of an abstract machine."),(0,i.kt)("p",null,"In a similar way, we can regard the evaluator as a very special machine that takes as input ",(0,i.kt)("em",{parentName:"p"},"a description of a machine"),". Given this input, the evaluator configures itself to emulate the machine described."),(0,i.kt)("p",null,"From this perspective, the evaluator is seen to be a ",(0,i.kt)("em",{parentName:"p"},"universal machine"),". It mimics other machines when these are described as Lisp programs."),(0,i.kt)("p",null,"One striking aspect of the evaluator is that it acts as a bridge between the data objects that are manipulated by our programming language and the programming language itself."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Imagine that the evaluator program is running, and that a user is typing expressions to the evaluator and observing the results. From the perspective of the user, an input expression such as ",(0,i.kt)("inlineCode",{parentName:"p"},"(* x x)")," is an expression in the programming language, which the evaluator should execute. From the perspective of the evaluator, however, the expression is simply a list (in this case, ",(0,i.kt)("em",{parentName:"p"},"a list of three symbols: ",(0,i.kt)("inlineCode",{parentName:"em"},"*"),", ",(0,i.kt)("inlineCode",{parentName:"em"},"x"),", and ",(0,i.kt)("inlineCode",{parentName:"em"},"x")),") that is to be manipulated according to a well-defined set of rules.")),(0,i.kt)("h3",{id:"internal-definitions"},"Internal Definitions"),(0,i.kt)("p",null,"The environment model of evaluation and our metacircular evaluator execute definitions in sequence, extending the environment frame one definition at a time."),(0,i.kt)("p",null,"However, when it comes to the internal definitions used to implement block structure, no calls to these procedures will be evaluated until all of them have been defined. In fact, the sequential evaluation mechanism will give the same result as a mechanism that directly implements simultaneous definition for any procedure in which the internal definitions come first in a body and evaluation of the value expressions for teh defined variables doesn't actually use any of the defined variables."),(0,i.kt)("p",null,"There is a simple way to treat definitions so that internally defined names have truly simultaneous scope--just create all local variables that will be in the current environment before evaluating any of the value expressions. One way to do this is by a syntax transformation on ",(0,i.kt)("inlineCode",{parentName:"p"},"lambda")," expressions. Before evaluating the body of a ",(0,i.kt)("inlineCode",{parentName:"p"},"lambda")," expression, we ",(0,i.kt)("em",{parentName:"p"},"scan out")," and eliminate all the internal definitions in the body. The internally defined variables will be created with a declaration and then set to their values by assignment."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(lambda \u27e8vars\u27e9\n  (define u \u27e8e1\u27e9)\n  (define v \u27e8e2\u27e9)\n  \u27e8e3\u27e9)\n\n# would be transformed into\n(lambda \u27e8vars\u27e9\n  (let ((u '*unassigned*)\n        (v '*unassigned*))\n        (set! u \u27e8e1\u27e9)\n        (set! v \u27e8e2\u27e9)\n        \u27e8e3\u27e9))\n")),(0,i.kt)("h3",{id:"separating-syntactic-analysis-from-execution"},"Separating Syntactic Analysis from Execution"),(0,i.kt)("p",null,"The evaluator implemented above is simple, but it is very inefficient, because the syntactic analysis of expressions is interleaved with their execution. Thus if a program is executed many times, its syntax is analyzed many times."),(0,i.kt)("p",null,"We can transform the evaluator to be significantly more efficient by arranging things so that syntactic analysis is performed only once."),(0,i.kt)("p",null,"We split ",(0,i.kt)("inlineCode",{parentName:"p"},"eval"),", which takes an expression and an environment, into two parts."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The procedure ",(0,i.kt)("inlineCode",{parentName:"p"},"analyze")," takes only the expression. It performs the syntactic analysis and returns a new procedure, the ",(0,i.kt)("em",{parentName:"p"},"execution procedure"),", that encapsulates the work to be done in executing the analyzed expression.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"execution")," procedure takes an environment as its argument and completes the evaluation. Looking up a variable value must still be done in the execution phase, since this depends upon knowing the environment."))),(0,i.kt)("p",null,"This saves work because ",(0,i.kt)("inlineCode",{parentName:"p"},"analyze")," will be called only once on an expression, while the execution procedure may be called many times."),(0,i.kt)("h2",{id:"variations-on-a-scheme--lazy-evaluation"},"Variations on a Scheme--Lazy Evaluation"),(0,i.kt)("p",null,"Indeed, new languages are often invented by first writing an evaluator that embeds the new language within an existing high-level language."),(0,i.kt)("p",null,"For example, if we wish to discuss some aspect of a proposed modification to Lisp with another member of the Lisp community, we can supply an evaluator that embodies the change. The recipient can then experiment with the new evaluator and send back comments as further modifications."),(0,i.kt)("p",null,"Not only does the high-level implementation base make it easier to test and debug the evaluator; in addition, the embedding enables the designer to snarf features from the underlying language, just as our embedded Lisp evaluator uses primitives and control structure from the underlying Lisp. Only later (if ever) need the designer go to the trouble of building a complete implementation in a low-level language or in hardware."),(0,i.kt)("h3",{id:"normal-order-and-applicative-order"},"Normal Order and Applicative Order"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"applicative-order language"),": all the arguments to procedures are evaluated when the procedure is applied."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"normal-order language"),": delay the evaluation of procedure arguments until the actual argument values are needed."),(0,i.kt)("p",null,"Delaying evaluation of procedure arguments until the last possible moment is called ",(0,i.kt)("em",{parentName:"p"},"lazy evaluation"),". An advantage of lazy evaluation is that some procedures can do useful computation even if evaluation of some of their arguments would produce errors or would not terminate."),(0,i.kt)("p",null,"If the body of a procedure is entered before an argument has been evaluated we say that the procedure is ",(0,i.kt)("em",{parentName:"p"},"non-strict")," in that argument. If the argument is evaluated before the body of the procedure is entered we say that the procedure is ",(0,i.kt)("em",{parentName:"p"},"strict")," in that argument."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The ",(0,i.kt)("em",{parentName:"p"},"strict")," versus ",(0,i.kt)("em",{parentName:"p"},"non-strict")," terminology means essentially the same thing as ",(0,i.kt)("em",{parentName:"p"},"applicative-order")," versus ",(0,i.kt)("em",{parentName:"p"},"normal-order"),", except that it refers to individual procedures and arguments rather than to the language as a whole.")),(0,i.kt)("p",null,"In a purely applicative- order language, all procedures are strict in each argument. In a purely normal-order language, all compound procedures are non-strict in each argument, and primitive procedures may be either strict or non-strict. There are also languages that give programmers detailed control over the strictness of the procedures they define."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"One can do useful computation, combining elements to form data structures and operating on the resulting data structures, even if the values of the elements are not known. It makes perfect sense, for instance, to compute the length of a list without knowing the values of the individual elements in the list.")),(0,i.kt)("h3",{id:"an-interpreter-with-lazy-evaluation"},"An Interpreter with Lazy Evaluation"),(0,i.kt)("p",null,"The basic idea is that, when applying a procedure, the interpreter must determine which arguments are to be evaluated and which are to be delayed. The delayed arguments are not evaluated; instead, they are transformed into objects called ",(0,i.kt)("em",{parentName:"p"},"thunks"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The word thunk was invented by an informal working group that was discussing the implementation of call-by-name in Algol 60. They observed that most of the analysis of (\u201cthinking about\u201d) the expression could be done at compile time; thus, at run time, the expression would already have been \u201cthunk\u201d about.")),(0,i.kt)("p",null,"The thunk must contain the information required to produce the value of the argument when it is needed, as if it had been evaluated at the time of the application. Thus, the thunk must contain the argument expression, and the environment in which the procedure application is being evaluated. We need to pass the environment to construct thunks when the arguments are to be delayed."),(0,i.kt)("p",null,"The process of evaluating the expression in a thunk is called ",(0,i.kt)("em",{parentName:"p"},"forcing"),". In general, a thunk will be forced only when its value is needed:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"when it is passed to a primitive procedure that will use the value of the thunk;"),(0,i.kt)("li",{parentName:"ul"},"when it is the value of a predicate of a conditional;"),(0,i.kt)("li",{parentName:"ul"},"when it is the value of an operator that is about to be applied as a procedure;")),(0,i.kt)("p",null,"One design choice we have available is whether to memoize thunks: with memoization, the first time a thunk is forced, it stores the value that is computed. Subsequent forcing simply return the stored value without repeating the computation. This design is more efficient in most applications."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Representing thunks")),(0,i.kt)("p",null,"The evaluator must arrange to create thunks when procedures are applied to arguments and to force these thunks later."),(0,i.kt)("p",null,"A thunk must package an expression together with the environment, so that the argument can be produced later."),(0,i.kt)("p",null,"To force the thunk, we simply extract the expression and environment from the thunk and evaluate the expression in the environment."),(0,i.kt)("p",null,"Considering memoization: When a thunk is forced, we will turn it into an evaluated thunk by replacing the stored expression with its value and changing the thunk tag so that it can be recognized as already evaluated."),(0,i.kt)("h3",{id:"streams-as-lazy-lists"},"Streams as Lazy Lists"),(0,i.kt)("p",null,"With lazy evaluation, streams and lists can be identical."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Lists could be view as iterators with already evaluated objects, whilst streams the generators with thunk to be evaluated in the future.")),(0,i.kt)("h2",{id:"variations-on-a-scheme--nondeterministic-computing"},"Variations on a Scheme--Nondeterministic Computing"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Nondeterministic computing")," is a programming paradigm, and is useful for ",(0,i.kt)("em",{parentName:"p"},"generate and test")," applications."),(0,i.kt)("p",null,"The key idea is that expressions in a nondeterministic language can have more than one possible value. The nondeterministic program evaluator will work by automatically choosing a possible value and keeping track of the choice. If a subsequent requirement is not met, the evaluator will try a different choice, and it will keep trying new choices until the evaluation succeeds, or until we run out of choices."),(0,i.kt)("p",null,"Just as the lazy evaluator frees the programmer from the details of how values are delayed and forced, the nondeterministic program evaluator will free the programmer from the details of how choices are made."),(0,i.kt)("p",null,"It is instructive to contrast the different images of time evoked by nondeterministic evaluation and stream processing:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Stream processing uses lazy evaluation to decouple the time when the stream of possible answers is assembled from the time when the actual stream elements are produced. The evaluator supports the illusion that all the possible answers are laid out before us in a timeless sequence.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"With nondeterministic evaluation, an expression represents the exploration of a set of possible worlds, each determined by a set of choices. Some possible worlds lead to dead ends, while others have useful values. The nondeterministic program evaluator supports the illusion that time branches, and that our programs have different possible execution histories. When we reach a dead end, we can revisit a previous choice point and proceed along a different branch."))),(0,i.kt)("h3",{id:"amb-and-search"},"Amb and Search"),(0,i.kt)("p",null,"To support nondeterminism, a special form called ",(0,i.kt)("inlineCode",{parentName:"p"},"amb")," is introduced."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(amb <e1> <e2> ... <en>)\n")),(0,i.kt)("p",null,"The expression returns the value of one of the n expressions ",(0,i.kt)("em",{parentName:"p"},"ambiguously"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"amb")," with a single choice produces an ordinary (single) value."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"amb")," with no choices is an expression with no acceptable values. It's the responsibility of the designer to decide whether ",(0,i.kt)("inlineCode",{parentName:"p"},"amb")," should fail on no acceptable values."),(0,i.kt)("p",null,"Abstractly, we can imagine that evaluating an ",(0,i.kt)("inlineCode",{parentName:"p"},"amb")," expression causes time to split into branches, where the computation continues on each branch with one of the possible values of the expression. We say that ",(0,i.kt)("inlineCode",{parentName:"p"},"amb")," represents a ",(0,i.kt)("em",{parentName:"p"},"nondeterministic choice point"),"."),(0,i.kt)("p",null,"If we had a machine with a sufficient number of processors that could be dynamically allocated, we could implement the search in a straightforward way. Execution would proceed as in a sequential machine, until an ",(0,i.kt)("inlineCode",{parentName:"p"},"amb")," expression is encountered. At this point, more processors would be allocated and initialized to continue all parallel executions implied by the choice. Each processor would proceed sequentially as if it were the only choice, until it either terminates by encountering a failure, or it further subdivides, or it finishes."),(0,i.kt)("p",null,"If we have a machine with only one processor, or a few concurrent processes, we must consider the alternatives sequentially. One could imagine modifying an evaluator to pick at random a branch to follow whenever it encounters a choice point. Random choice, however, can easily lead to failing values. We might try running the evaluator over and over, making random choices and hoping to find a non-failing value, but it is better to ",(0,i.kt)("em",{parentName:"p"},"systematically search")," all possible execution paths."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"amb")," evaluator could be implemented with a systematic search as follows:"),(0,i.kt)("p",null,"When the evaluator encounters an application of ",(0,i.kt)("inlineCode",{parentName:"p"},"amb"),", it initially selects the first alternative. This selection may itself lead to a further choice. The evaluator will always initially choose the first alternative at each choice point. If a choice results in a failure, then the evaluator automagically ",(0,i.kt)("em",{parentName:"p"},"backtracks")," to the most recent choice point and tries the next alternative. If it runs out of alternatives at any choice point, the evaluator will back up to the previous choice point and resume from there. This process leads to a search strategy known as ",(0,i.kt)("em",{parentName:"p"},"depth-first search")," or ",(0,i.kt)("em",{parentName:"p"},"chronological backtracking"),"."),(0,i.kt)("p",null,"The advantage of nondeterministic programming is that we can suppress the details of how search is carried out, thereby expressing the programs at a higher level of abstraction."),(0,i.kt)("h3",{id:"implementing-the-amb-evaluator"},"Implementing the Amb Evaluator"),(0,i.kt)("p",null,"The execution procedures in the ",(0,i.kt)("inlineCode",{parentName:"p"},"amb")," evaluator take three arguments: the environment, and two procedures called ",(0,i.kt)("em",{parentName:"p"},"continuation procedures"),". The evaluation of an expression will finish by calling one of these two continuations: If the evaluation results in a value, the ",(0,i.kt)("em",{parentName:"p"},"success continuation")," is called with that value; if the evaluation results in the discovery of a dead end, the ",(0,i.kt)("em",{parentName:"p"},"failure continuation")," is called. Constructing and calling appropriate continuations is the mechanism by which the nondeterministic evaluator implements backtracking."),(0,i.kt)("p",null,"It is the job of the success continuation to receive a value and proceed with the computation. Along with that value, the success continuation is passed another failure continuation, which is to be called subsequently if the use of that value leads to a dead end."),(0,i.kt)("p",null,"It is the job of the failure continuation to try another branch of the nondeterministic process. The essence of the nondeterministic language is in the fact that expressions may represent choices among alternatives. The evaluation of such an expression must proceed with one of the indicated alternative choices, even though it is not known in advance which choices will lead to acceptable results. To deal with this, the evaluator picks one of the alternatives and passes this value to the success continuation. Together with this value, the evaluator constructs and passes along a failure continuation that can be called later to choose a different alternative."),(0,i.kt)("p",null,"In addition, if a side-effect operation (such as assignment to a variable) occurs on a branch of the process resulting from a choice, it may be necessary, when the process finds a dead end, to undo the side effect before making a new choice. This is accomplished by having the side-effect operation produce a failure continuation that undoes the side effect and propagates the failure."),(0,i.kt)("p",null,"In summary, failure continuations are constructed by:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"amb")," expressions: to provide a mechanism to make alternative choices if the current choice made by the ",(0,i.kt)("inlineCode",{parentName:"li"},"amb")," expression leads to a dead end;"),(0,i.kt)("li",{parentName:"ul"},"the top-level driver: to provide a mechanism to report failure when the choices are exhausted;"),(0,i.kt)("li",{parentName:"ul"},"assignments: to intercept failures and undo assignments during backtracking")),(0,i.kt)("p",null,"Failure continuations are also called during processing of a failure:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"When the failure continuation created by an assignment finishes undoing a side effect, it calls the failure continuation it intercepted, in order to propagate the failure back to the choice point that led to this assignment or to the top-level."),(0,i.kt)("li",{parentName:"ul"},"When the failure continuation for an ",(0,i.kt)("inlineCode",{parentName:"li"},"amb")," runs out of choices, it calls the failure continuation that was originally given to the ",(0,i.kt)("inlineCode",{parentName:"li"},"amb"),", in order to propagate the failure back to the previous choice point or to the top-level.")),(0,i.kt)("h2",{id:"logic-programming"},"Logic Programming"),(0,i.kt)("p",null,"Indeed, programming languages require that the programmer express knowledge in a form that indicates the step-by-step methods for solving particular problems. On the other hand, high-level languages provide, as part of the language implementation, a substantial amount of methodological knowledge that frees the user from concern with numerous details of how a specified computation will progress."),(0,i.kt)("p",null,"Most programming languages are organized around computing the values of mathematical functions. Expression-oriented languages (such as Lisp, Fortran, and Algol) capitalize on the ",(0,i.kt)("em",{parentName:"p"},"pun")," that an expression that describes the value of a function may also be interpreted as a means of computing that value. Because of this, most programming languages are strongly biased toward unidirectional computations (computations with well-defined inputs and outputs)."),(0,i.kt)("p",null,"In a constraint system the direction and the order of computation are not so well specified; in carrying out a computation the system must therefore provide more detailed ",(0,i.kt)("em",{parentName:"p"},"how to")," knowledge than would be the case with an ordinary arithmetic computation. This does not mean that the user is released altogether from the responsibility of providing imperative knowledge. There are many constraint networks that implement the same set of constraints, and the user must choose from the set of mathematically equivalent networks a suitable network to specify a particular computation."),(0,i.kt)("p",null,"The nondeterministic program evaluator also moves away from the view that programming is about constructing algorithms for computing unidirectional functions. In a nondeterministic language, expressions can have more than one value, and, as a result, the computation is dealing with relations rather than with single-valued functions. Logic programming extends this idea by combining a relational vision of programming with a powerful kind of symbolic pattern matching called ",(0,i.kt)("strong",{parentName:"p"},"unification"),"."),(0,i.kt)("p",null,"This approach, when it works, can be very powerful way to write programs. Part of the power comes from the fact that a single ",(0,i.kt)("em",{parentName:"p"},"what is")," fact can be used to solve a number of different problems that would have different ",(0,i.kt)("em",{parentName:"p"},"how to")," components."),(0,i.kt)("p",null,"Contemporary logic programming languages have substantial deficiencies, in that their general ",(0,i.kt)("em",{parentName:"p"},"how to")," methods can lead them into spurious infinite loops or other undesirable behavior."),(0,i.kt)("h3",{id:"deductive-information-retrieval"},"Deductive Information Retrieval"),(0,i.kt)("p",null,"Logic programming excels in providing interfaces, something such as pattern-directed access, to data bases for information retrieval."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Something like Regular Expression which also use a pattern to test strings.")),(0,i.kt)("h3",{id:"how-the-query-system-works"},"How the Query System Works"),(0,i.kt)("p",null,"The query system is organized around two central operations called pattern matching and unification."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Pattern matching")),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"pattern matcher")," is a program that tests whether some datum fits a specific pattern. The pattern matcher used by the query system takes as inputs a pattern, a datum, and a frame that specifies bindings for various pattern variables. It checks whether the datum matches the pattern in a way that is consistent with the bindings already in the frame. If so, it returns the given frame augmented by any bindings that may have been determined by the match. Otherwise, it indicates that the match has failed."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Streams of frames")),(0,i.kt)("p",null,"The testing of patterns against frames is organized through the use of streams. Given a single frame, the matching process runs through the data-base entries one by one. For each data-base entry, the matcher generates either a special symbol indicating that the match has failed or an extension to the frame. The results for all the data-base entries are collected into a stream, which is passed through a filter to weed out the failures. The result is a stream of all the frames that extend the given frame via a match to some assertion in the data base ."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Unification")),(0,i.kt)("p",null,"In order to handle rules in the query language, we must be able to find the rules whose conclusions match a given query pattern. Rule conclusions are like assertions except that they can contain variables, so we will need a generalization of pattern matching-\u2014called ",(0,i.kt)("em",{parentName:"p"},"unification"),"\u2014\u2014in which both the ",(0,i.kt)("em",{parentName:"p"},"pattern")," and the ",(0,i.kt)("em",{parentName:"p"},"datum")," may contain variables."),(0,i.kt)("p",null,"A unifier takes two patterns, each containing constants and variables, and determines whether it is possible to assign values to the variables that will make the two patterns equal. With complex patterns, performing unification may seem to require deduction. We may think of this process as solving a set of equations among the pattern components. In general, these are simultaneous equations, which may require substantial manipulation to solve."),(0,i.kt)("p",null,"In a successful pattern match, all pattern variables become bound, and the values to which they are bound contain only constants. This is also true of all the examples of unification we have seen so far. In general, however, a successful unification may not completely determine the variable values; some variables may remain unbound and others may be bound to values that contain variables."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Applying rules")),(0,i.kt)("p",null,"Unification is the key to the component of the query system that makes inferences from rules."),(0,i.kt)("p",null,"In general, the query evaluator uses the following method to apply a rule when trying to establish a query pattern in a frame that specifies bindings for some pattern variables:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Unify the query with the conclusion of the rule to form, if successful, an extension of the original frame."),(0,i.kt)("li",{parentName:"ul"},"Relative to the extended frame, evaluate the query formed by the body of the rule.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Just as procedure definitions are the means of abstraction in Lisp, rule definitions are the means of abstraction in the query language. In each case, we unwind the abstraction by creating appropriate bindings and evaluating the rule or procedure body relative to these.")),(0,i.kt)("h3",{id:"is-logic-programming-mathematical-logic"},"Is Logic Programming Mathematical Logic?"),(0,i.kt)("p",null,"The identification of the query language with mathematical logic is not really valid, though, because the query language provides a ",(0,i.kt)("em",{parentName:"p"},"control structure")," that interprets the logical statements procedurally."),(0,i.kt)("p",null,"The aim of logic programming is to provide the programmer with techniques for decomposing a computational problem into two separate problems: ",(0,i.kt)("em",{parentName:"p"},"what is to be computed"),", and ",(0,i.kt)("em",{parentName:"p"},"how this should be computed"),"."),(0,i.kt)("p",null,"This is accomplished by selecting a subset of the statements of mathematical logic that is powerful enough to be able to describe anything one might want to compute, yet weak enough to have a controllable procedural interpretation."),(0,i.kt)("p",null,"The intention here is that, on the one hand, a program specified in a logic programming language should be an effective program that can be carried out by a computer. Control (",(0,i.kt)("em",{parentName:"p"},"how to compute"),") is effected by using the order of evaluation of the language. We should be able to arrange the order of clauses and the order of sub-goals within each clause so that the computation is done in an order deemed to be effective and efficient. At the same time, we should be able to view the result of the computation (",(0,i.kt)("em",{parentName:"p"},"what to compute"),") as a simple consequence of the laws of logic."))}h.isMDXComponent=!0}}]);