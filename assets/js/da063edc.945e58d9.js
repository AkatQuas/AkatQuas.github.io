"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6220],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),l=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(p.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=l(n),m=a,f=h["".concat(p,".").concat(m)]||h[m]||u[m]||o;return n?r.createElement(f,i(i({ref:t},c),{},{components:n})):r.createElement(f,i({ref:t},c))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[h]="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},85288:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var r=n(87462),a=(n(67294),n(3905));const o={title:"01 Why study interpreters and compilers?",tags:["lisp","interpreter"]},i=void 0,s={unversionedId:"lisp-interpreter-in-py/chapter-01",id:"lisp-interpreter-in-py/chapter-01",title:"01 Why study interpreters and compilers?",description:"I will give you three reasons.",source:"@site/docs/lisp-interpreter-in-py/chapter-01.md",sourceDirName:"lisp-interpreter-in-py",slug:"/lisp-interpreter-in-py/chapter-01",permalink:"/docs/lisp-interpreter-in-py/chapter-01",draft:!1,tags:[{label:"lisp",permalink:"/docs/tags/lisp"},{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",frontMatter:{title:"01 Why study interpreters and compilers?",tags:["lisp","interpreter"]},sidebar:"tutorialSidebar",previous:{title:"Before start",permalink:"/docs/lisp-interpreter-in-py/chapter-00"},next:{title:"02",permalink:"/docs/lisp-interpreter-in-py/chapter-02"}},p={},l=[],c={toc:l};function h(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"I will give you three reasons."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"To write an interpreter or a compiler you have to have a lot of technical skills that you need to use together. Writing an interpreter or a compiler will help you improve those skills and become a better software developer. As well, the skills you will learn are useful in writing any software, not just interpreters or compilers.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"You really want to know how computers work. Often interpreters and compilers look like magic. And you shouldn't be comfortable with that magic. You want to demystify the process of building an interpreter and a compiler, understand how they work, and get in control of things.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"You want to create your own programming language or domain specific language. If you create one, you will also need to create either an interpreter or a compiler for it. Recently, there has been a resurgence of interest in new programming languages. And you can see a new programming language pop up almost every day: Elixir, Go, Rust just to name a few."))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"What are interpreters and compilers?")),(0,a.kt)("p",null,"The goal of an interpreter or a compiler is to translate a source program in some high-level language into some other form. Pretty vague, but later in the series you will learn exactly what the source program is translated into."),(0,a.kt)("p",null,"At this point you may also wonder what the difference is between an interpreter and a compiler. For the purpose of this series, let's agree that if a translator translates a source program into machine language, it is a compiler. If a translator processes and executes the source program without translating it into machine language first, it is an interpreter. Visually it looks something like this:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part1_compiler_interpreter.png",alt:""}),(0,a.kt)("p",null,"We are going to create a simple interpreter for a large subset of Pascal language. At the end of this series you will have working ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Pascal_%28programming_language%29"},"Pascal")," interpreter and a source-level debugger like ",(0,a.kt)("a",{parentName:"p",href:"https://docs.python.org/2/library/pdb.html"},"Python's pdb"),"."),(0,a.kt)("p",null,"The implementation language of the Pascal interpreter will be Python, but you can use any language you want because the ideas presented don't depend on any particular implementation language."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"# Token types\n#\n# EOF (end-of-file) token is used to indicate that\n# there is no more input left for lexical analysis\nINTEGER, PLUS, EOF = 'INTEGER', 'PLUS', 'EOF'\n\n\nclass Token(object):\n    def __init__(self, type, value):\n        # token type: INTEGER, PLUS, EOF\n        self.type = type\n        # token value: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, '+', or None\n        self.value = value\n\n    def __str__(self):\n        \"\"\"String representation of the class instance.\n\n        Examples:\n            Token(INTEGER, 3)\n            Token(PLUS, '+')\n        \"\"\"\n        return 'Token({type}, {value})'.format(\n            type=self.type,\n            value=repr(self.value)\n        )\n\n    def __repr__(self):\n        return self.__str__()\n\nclass Interpreter(object):\n    def __init__(self, text):\n        # client string input, e.g. \"3+5\"\n        self.text = text\n        # self.pos is an index into self.text\n        self.pos = 0\n        # current token instance\n        self.current_token = None\n\n    def error(self):\n        raise Exception('Error parsing input')\n\n    def get_next_token(self):\n        \"\"\"Lexical analyzer (also know as scanner or tokenizer)\n\n        This method is responsible for breaking a sentence\n        apart into tokens. One token at a time.\n        \"\"\"\n        text = self.text\n\n        # is self.pos index past the end of the self.text ?\n        # if so, then return EOF token because there is no more\n        # input left to convert into tokens\n        if self.pos > len(text) - 1:\n            return Token(EOF, None)\n\n        # get a character at the position self.pos and decide\n        # what token to create based on the single character\n        current_char = text[self.pos]\n\n        # if the character is a digit then convert it to\n        # integer, create an INTEGER token, increment self.pos\n        # index to point to the next character after the digit,\n        # and return the INTEGER token\n        if current_char.isdigit():\n            token = Token(INTEGER, int(current_char))\n            self.pos += 1\n            return token\n\n        if current_char == '+':\n            token = Token(PLUS, current_char)\n            self.pos += 1\n            return token\n\n        self.error()\n\n    def eat(self, token_type):\n        # compare the current token type with the passed token\n        # type and if they match then \"eat\" the current token\n        # and assign the next token to the self.current_token,\n        # otherwise raise an exception\n        if self.current_token.type == token_type:\n            self.current_token = self.get_next_token()\n        else:\n            self.error()\n\n    def expr(self):\n        \"\"\" expr -> INTEGER PLUS INTEGER \"\"\"\n        # set current token to the first token taken from the input\n        self.current_token = self.get_next_token()\n\n        # we expect the current token to be a single-digit integer\n        left = self.current_token\n        self.eat(INTEGER)\n\n        # we expect the current token to be a '+' token\n        op = self.current_token\n        self.eat(PLUS)\n\n        # we expect the current token to be a single-digit integer\n        right = self.current_token\n        self.eat(INTEGER)\n\n        # after the above call the self.current_token is set to\n        # EOF token\n\n        # at this point INTEGER PLUS INTEGER sequence of tokens\n        # has been successfully found and the method can just\n        # return the result of adding two integers, thus\n        # effectively interpreting client input\n        result = left.value + right.value\n        return result\n\ndef main():\n    while True:\n        try:\n            try:\n                text = input('calc> ')\n            except NameError: # python3\n                text = raw_input('calc> ')\n        except EOFError:\n            break\n        if not text:\n            continue\n        interpreter = Interpreter(text)\n        result = interpreter.expr()\n        print(result)\n\n\nif __name__ == '__main__':\n    main()\n")),(0,a.kt)("p",null,"For your simple calculator to work properly without throwing an exception, your input needs to follow certain rules:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Only single digit integers are allowed in the input"),(0,a.kt)("li",{parentName:"ul"},"The only arithmetic operation supported at the moment is addition"),(0,a.kt)("li",{parentName:"ul"},"No whitespace characters are allowed anywhere in the input")),(0,a.kt)("p",null,"Those restrictions are necessary to make the calculator simple."),(0,a.kt)("p",null,"When you enter an expression ",(0,a.kt)("em",{parentName:"p"},"3+5")," on the command line your interpreter gets a string ",(0,a.kt)("em",{parentName:"p"},"3+5")," . In order for the interpreter to actually understand what to do with that string it first needs to break the input ",(0,a.kt)("em",{parentName:"p"},"3+5")," into components called tokens. A token is an object that has a type and a value. For example, for the string ",(0,a.kt)("em",{parentName:"p"},"3")," the type of the token will be ",(0,a.kt)("strong",{parentName:"p"},"INTEGER")," and the corresponding value will be integer ",(0,a.kt)("em",{parentName:"p"},"3"),"."),(0,a.kt)("p",null,"The process of breaking the input string into tokens is called ",(0,a.kt)("strong",{parentName:"p"},"lexical analysis"),". So, the first step your interpreter needs to do is read the input of characters and convert it into a stream of tokens."),(0,a.kt)("p",null,"The part of the interpreter that does it is called a ",(0,a.kt)("strong",{parentName:"p"},"lexical analyzer"),", or lexer for short. You might also encounter other names for the same component, like scanner or tokenizer. They all mean the same: the part of your interpreter or compiler that turns the input of characters into a stream of tokens."),(0,a.kt)("p",null,"The method ",(0,a.kt)("em",{parentName:"p"},"get_next_token")," of the ",(0,a.kt)("em",{parentName:"p"},"Interpreter")," class is your lexical analyzer. Every time you call it, you get the next token created from the input of characters passed to the interpreter."),(0,a.kt)("p",null,"Let's take a closer look at the method itself and see how it actually dose its job of converting characters into tokens. The input is stored in the variable ",(0,a.kt)("em",{parentName:"p"},"text")," that holds the input string and ",(0,a.kt)("em",{parentName:"p"},"pos")," is an index into that string. ",(0,a.kt)("em",{parentName:"p"},"pos")," is initially set to 0 and points to the character ",(0,a.kt)("em",{parentName:"p"},"3"),". The method first checks whether the character is a digit and if so, it increments ",(0,a.kt)("em",{parentName:"p"},"pos")," and returns a token instance with the type ",(0,a.kt)("strong",{parentName:"p"},"INTEGER")," and the value set to the integer value of the string ",(0,a.kt)("em",{parentName:"p"},"3"),", which is an integer ",(0,a.kt)("em",{parentName:"p"},"3"),":"),(0,a.kt)("img",{src:"./imgs/lsbasi_part1_lexer1.png",alt:""}),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"pos")," now points to the ",(0,a.kt)("em",{parentName:"p"},"+")," character in the ",(0,a.kt)("em",{parentName:"p"},"text"),". The next time you call the method, it tests if a character at the position ",(0,a.kt)("em",{parentName:"p"},"pos")," is a digit and then it tests if the character is a plus sign, which it is. As a result the method increments ",(0,a.kt)("em",{parentName:"p"},"pos")," and returns a newly created token with the type ",(0,a.kt)("strong",{parentName:"p"},"PLUS")," and value ",(0,a.kt)("em",{parentName:"p"},"+"),":"),(0,a.kt)("img",{src:"./imgs/lsbasi_part1_lexer2.png",alt:""}),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"pos")," now points to character ",(0,a.kt)("em",{parentName:"p"},"5"),". When you call the ",(0,a.kt)("em",{parentName:"p"},"get_next_token")," method again the method checks if it's a digit, which it is, so it increments ",(0,a.kt)("em",{parentName:"p"},"pos")," and returns a new INTEGER token with the value of the token set to integer ",(0,a.kt)("em",{parentName:"p"},"5"),":"),(0,a.kt)("img",{src:"./imgs/lsbasi_part1_lexer3.png",alt:""}),(0,a.kt)("p",null,"Because the ",(0,a.kt)("em",{parentName:"p"},"pos")," index is now past the end of the string ",(0,a.kt)("em",{parentName:"p"},"3+5")," the ",(0,a.kt)("em",{parentName:"p"},"get_next_token")," method returns the EOF token every time you call it:"),(0,a.kt)("img",{src:"./imgs/lsbasi_part1_lexer4.png",alt:""}),(0,a.kt)("p",null,"So, now your interpreter has access to the stream of tokens made from the input characters, the interpreter needs to do something with it: it needs to find the structure in the flat stream of tokens it gets from the lexer ",(0,a.kt)("em",{parentName:"p"},"get_next_token"),". Your interpreter expects to find the following structure in that stream: ",(0,a.kt)("strong",{parentName:"p"},"INTEGER -> PLUS -> INTEGER"),". That is, it tries to find a sequence of tokens: integer followed by a plus sign followed by an integer."),(0,a.kt)("p",null,"The method responsible for finding and interpreting that structure is ",(0,a.kt)("em",{parentName:"p"},"expr"),". This method verifies that the sequence of tokens does indeed correspond to the expected sequence of tokens, i.e ",(0,a.kt)("strong",{parentName:"p"},"INTEGER -> PLUS -> INTEGER"),". After it's successfully confirmed the structure, it generates the result by adding the value of the token on the left side of the PLUS and the right side of the PLUS, thus successfully interpreting the arithmetic expression you passed to the interpreter."),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"expr")," method itself uses the helper method ",(0,a.kt)("em",{parentName:"p"},"eat")," to verify that the token type passed to the ",(0,a.kt)("em",{parentName:"p"},"eat")," method matches the current token type. After matching the passed token type the ",(0,a.kt)("em",{parentName:"p"},"eat")," method gets the next token and assigns it to the ",(0,a.kt)("em",{parentName:"p"},"current_token"),' variable, thus effectively "eating" the currently matched token and advancing the imaginary pointer in the stream of tokens. If the structure in the stream of tokens doesn\'t correspond to the expected ',(0,a.kt)("strong",{parentName:"p"},"INTEGER PLUS INTEGER")," sequence of tokens the ",(0,a.kt)("em",{parentName:"p"},"eat")," method throws an exception."),(0,a.kt)("p",null,"Let's recap what your interpreter does to evaluate an arithmetic expression:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},'The interpreter accepts an input string, let\'s say "3+5"'),(0,a.kt)("li",{parentName:"ol"},"The interpreter calls the ",(0,a.kt)("em",{parentName:"li"},"expr")," method to find a structure in the stream of tokens returned by the lexical analyzer ",(0,a.kt)("em",{parentName:"li"},"get_next_token"),". The structure it tries to find is of the form ",(0,a.kt)("strong",{parentName:"li"},"INTEGER PLUS INTEGER"),". After it's confirmed the structure, it interprets the input by adding the values of two ",(0,a.kt)("strong",{parentName:"li"},"INTEGER")," tokens because it's clear to the interpreter at that point that what it needs to do is add two integers, 3 and 5.")))}h.isMDXComponent=!0}}]);