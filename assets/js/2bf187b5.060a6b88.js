"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[21],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),p=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=p(e.components);return r.createElement(s.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(t),m=a,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||i;return t?r.createElement(h,o(o({ref:n},u),{},{components:t})):r.createElement(h,o({ref:n},u))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[c]="string"==typeof e?e:a,o[1]=l;for(var p=2;p<i;p++)o[p]=t[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},68103:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var r=t(87462),a=(t(67294),t(3905));const i={title:"06 Error Handling",tags:["lisp","interpreter"]},o=void 0,l={unversionedId:"lisp-interpreter-in-c/error-handling",id:"lisp-interpreter-in-c/error-handling",title:"06 Error Handling",description:"document",source:"@site/docs/lisp-interpreter-in-c/06-error-handling.md",sourceDirName:"lisp-interpreter-in-c",slug:"/lisp-interpreter-in-c/error-handling",permalink:"/docs/lisp-interpreter-in-c/error-handling",draft:!1,tags:[{label:"lisp",permalink:"/docs/tags/lisp"},{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",sidebarPosition:6,frontMatter:{title:"06 Error Handling",tags:["lisp","interpreter"]},sidebar:"tutorialSidebar",previous:{title:"05 Evaluation",permalink:"/docs/lisp-interpreter-in-c/evaluation"},next:{title:"07 S-Expressions",permalink:"/docs/lisp-interpreter-in-c/s-expressions"}},s={},p=[{value:"Crashes",id:"crashes",level:2},{value:"Lisp Value",id:"lisp-value",level:2},{value:"Enumerations",id:"enumerations",level:2},{value:"Lisp Value Function",id:"lisp-value-function",level:2},{value:"Evaluating Errors",id:"evaluating-errors",level:2},{value:"Plumbing",id:"plumbing",level:2}],u={toc:p};function c(e){let{components:n,...i}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"http://www.buildyourownlisp.com/chapter8_error_handling"},"document")),(0,a.kt)("p",null,"codes:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{target:"_blank",href:t(45178).Z},"error-handling.c"))),(0,a.kt)("h2",{id:"crashes"},"Crashes"),(0,a.kt)("p",null,"At the moment, the ",(0,a.kt)("a",{target:"_blank",href:t(95932).Z},"program")," can produce syntax errors but it still has no functionality for reporting errors in the evaluation of expressions. We need to build in some kind of error handling functionality to do this. It can be awkward in C, but if we start off on the right track, it will pay off later on when our system gets more complicated."),(0,a.kt)("p",null,"C programs crashing is a fact of life. If anything goes wrong the operating system kicks them out. Programs can crash for many different reasons, and in many different ways."),(0,a.kt)("h2",{id:"lisp-value"},"Lisp Value"),(0,a.kt)("p",null,"There are several ways to deal with errors in C, but in this context my preferred method is to make errors a possible result of evaluating an expression. Then we can say that, in Lisp, an expression will evaluate to either a ",(0,a.kt)("strong",{parentName:"p"},"number"),", or an ",(0,a.kt)("strong",{parentName:"p"},"error"),". For example ",(0,a.kt)("inlineCode",{parentName:"p"},"+ 1 2")," will evaluate to a number, but ",(0,a.kt)("inlineCode",{parentName:"p"},"/ 10 0")," will evaluate to an error."),(0,a.kt)("p",null,"For this we need a data structure that can act as either one thing or anything. For simplicity\u2019s sake we are just going to use a ",(0,a.kt)("inlineCode",{parentName:"p"},"struct")," with fields specific to each thing that can be represented, and a special field ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," to tell us exactly what fields are meaningful to access."),(0,a.kt)("p",null,"This we are going to call an ",(0,a.kt)("inlineCode",{parentName:"p"},"lval"),", which stands for ",(0,a.kt)("strong",{parentName:"p"},"Lisp Value"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"typedef struct {\n    int type;\n    long num;\n    int err;\n} lval;\n")),(0,a.kt)("h2",{id:"enumerations"},"Enumerations"),(0,a.kt)("p",null,"You'll notice the type of the fields ",(0,a.kt)("inlineCode",{parentName:"p"},"type"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"err"),", is ",(0,a.kt)("inlineCode",{parentName:"p"},"int"),". This means they are represented by a single integer number."),(0,a.kt)("p",null,"The reason we pick ",(0,a.kt)("inlineCode",{parentName:"p"},"int")," is that we will assign meaning to each integer value, to encode what we require. For example, we can make a rule ",(0,a.kt)("strong",{parentName:"p"},'"If ',(0,a.kt)("inlineCode",{parentName:"strong"},"type")," is ",(0,a.kt)("inlineCode",{parentName:"strong"},"0"),' then the structure is a Number."'),", or ",(0,a.kt)("strong",{parentName:"p"},'"If ',(0,a.kt)("inlineCode",{parentName:"strong"},"type")," is ",(0,a.kt)("inlineCode",{parentName:"strong"},"1"),' then the structure is an Error."')," This is a simple and effective way of doing things."),(0,a.kt)("p",null,"But if we litter our code with stray ",(0,a.kt)("inlineCode",{parentName:"p"},"0")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," then it is going to become increasingly unclear as to what is happening. Instead, we can use named constants that have been assigned these integer values. This gives the reader an indication as to ",(0,a.kt)("strong",{parentName:"p"},"why")," one might be comparing a number to ",(0,a.kt)("inlineCode",{parentName:"p"},"0")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," and ",(0,a.kt)("strong",{parentName:"p"},"what")," is meant in this context."),(0,a.kt)("p",null,"In C this is supported using an ",(0,a.kt)("inlineCode",{parentName:"p"},"enum"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/* Create Enumeration of Possible lval Types */\nenum { LVAL_NUM, LVAL_ERR };\n")),(0,a.kt)("p",null,"An ",(0,a.kt)("inlineCode",{parentName:"p"},"enum")," is a declaration of variables which under the hood are automatically assigned integer constant values. Above describes how we would declare some enumerated values for the ",(0,a.kt)("inlineCode",{parentName:"p"},"type")," field."),(0,a.kt)("p",null,"We also want to declare an enumeration for the ",(0,a.kt)("inlineCode",{parentName:"p"},"error")," field. We have three error cases in our particular program. There is division by zero, an unknown operator, or being passed a number that is too large to be represented internally using a ",(0,a.kt)("inlineCode",{parentName:"p"},"long"),". These can be enumerated as follows."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/* Create Enumeration of Possible err Types */\nenum { LERR_DIV_ZERO, LERR_BAD_OP, LERR_BAD_NUM };\n")),(0,a.kt)("h2",{id:"lisp-value-function"},"Lisp Value Function"),(0,a.kt)("p",null,"Our ",(0,a.kt)("inlineCode",{parentName:"p"},"lval")," type is almost ready to go. Unlike the previous ",(0,a.kt)("inlineCode",{parentName:"p"},"long")," type we have no current method for creating new instances of it. To do this we can declare two functions that construct an ",(0,a.kt)("inlineCode",{parentName:"p"},"lval")," of either an ",(0,a.kt)("strong",{parentName:"p"},"error")," type or a ",(0,a.kt)("strong",{parentName:"p"},"number")," type."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/* Create a new number type lval */\nlval leval_num(long x) {\n    lval v;\n    v.type = LVAL_NUM;\n    v.num = x;\n    return v;\n}\n\n/* Create a new error type lval */\nlval lval_err(int x) {\n    lval v;\n    v.type = LVAL_ERR;\n    v.err = x;\n    return v;\n}\n")),(0,a.kt)("p",null,"These functions first create an ",(0,a.kt)("inlineCode",{parentName:"p"},"lval")," called ",(0,a.kt)("inlineCode",{parentName:"p"},"v"),", and assign the fields before returning it."),(0,a.kt)("p",null,"Because our ",(0,a.kt)("inlineCode",{parentName:"p"},"lval")," function can now be one of two things we can no longer just use ",(0,a.kt)("inlineCode",{parentName:"p"},"printf")," to output it. We will want to behave differently depending upon the type of the ",(0,a.kt)("inlineCode",{parentName:"p"},"lval")," that is given. There is a concise way to do this in C using the ",(0,a.kt)("inlineCode",{parentName:"p"},"switch")," statement. This takes some value as input and compares it to other known values, known as ",(0,a.kt)("strong",{parentName:"p"},"cases"),". When the values are equal it executes the code that follows up until the next ",(0,a.kt)("inlineCode",{parentName:"p"},"break")," statement."),(0,a.kt)("p",null,"Using this we can build a function that can print an ",(0,a.kt)("inlineCode",{parentName:"p"},"lval")," of any type like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'/* Print an "lval" */\nlval_print(lval v) {\n    swith (v.type) {\n        case LVAL_NUM: printf("%li", v.num); break;\n\n        case LVAL_ERR:\n            if (v.err == LERR_DIV_ZERO) {\n                printf("Error: Division by Zero!");\n            }\n            if (v.err == LERR_BAD_OP)   {\n                printf("Error: Invalid Operator!");\n            }\n            if (v.err == LERR_BAD_NUM)  {\n                printf("Error: Invalid Number!");\n            }\n            break;\n    }\n}\n\n/* Print an "lval" followed by a newline */\nvoid lval_println(lavl v) { lval_print(v); putchar(\'\\n\'); }\n')),(0,a.kt)("h2",{id:"evaluating-errors"},"Evaluating Errors"),(0,a.kt)("p",null,"Now that we know how to work with the ",(0,a.kt)("inlineCode",{parentName:"p"},"lval")," type, we need to change our evaluation function to use it instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"long"),"."),(0,a.kt)("p",null,"As well as changing the type signatures we need to change the functions such that they work correctly upon encountering either an ",(0,a.kt)("strong",{parentName:"p"},"error")," as input, or a ",(0,a.kt)("strong",{parentName:"p"},"number")," as input."),(0,a.kt)("p",null,"In our ",(0,a.kt)("inlineCode",{parentName:"p"},"eval_op")," function, if we encounter an error we should return it right away, and only do computation if both the arguments are numbers. We should modify our code to return an error rather than attempt to divide by zero. This will fix the crash described at the beginning of this chapter."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'lval eval_op(lval x, char* op, lval y) {\n\n    /* If either value is an error return it */\n    if (x.type == LVAL_ERR) { return x; }\n    if (y.type == LVAL_ERR) { return y; }\n\n    if (strcmp(op, "+") == 0) { return lval_num(x.num + y.num); }\n    if (strcmp(op, "-") == 0) { return lval_num(x.num - y.num); }\n    if (strcmp(op, "*") == 0) { return lval_num(x.num * y.num); }\n    if (strcmp(op, "/") == 0) {\n        /* If second operand is zero return error */\n        return y.num == 0\n          ? lval_err(LERR_DIV_ZERO)\n          : lval_num(x.num / y.num);\n    }\n\n    return lval_err(LERR_BAD_OP);\n}\n')),(0,a.kt)("p",null,"We need to give a similar treatment to our ",(0,a.kt)("inlineCode",{parentName:"p"},"eval")," function. In this case because we've defined ",(0,a.kt)("inlineCode",{parentName:"p"},"eval_op")," to robustly handle errors we just need to add the error conditions to our number conversion function."),(0,a.kt)("p",null,"In this case we use the ",(0,a.kt)("inlineCode",{parentName:"p"},"strtol")," function to convert from ",(0,a.kt)("inlineCode",{parentName:"p"},"string")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"long"),". This allows us to check a special variable ",(0,a.kt)("inlineCode",{parentName:"p"},"errno")," to ensure the conversion goes correctly. This is a more robust way to convert numbers than our previous method using ",(0,a.kt)("inlineCode",{parentName:"p"},"atoi"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'lval eval(mpc_ast_t* t) {\n    if (strstr(t->tag, "number")) {\n        errno = 0;\n        long x = strtol(t->contents, NULL, 10);\n        return errno != ERANGE ? lval_num(x) : lval_err(LERR_BAD_NUM);\n    }\n\n    char* op = t->children[1]->contents;\n    lval x = eval(t->children[2]);\n\n    int i = 3;\n    while (strstr(t->children[i]->tag, "expr")) {\n        x = eval_op(x, op, eval(t->children[i]));\n        i++;\n    }\n    return x;\n}\n')),(0,a.kt)("p",null,"This final small step is to change how we print the result found by our evaluation to use our newly defined printing function which can print any type of ",(0,a.kt)("inlineCode",{parentName:"p"},"lval"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"lval result = eval(r.output);\nlval_println(result);\nmpc_ast_delete(r.output);\n")),(0,a.kt)("h2",{id:"plumbing"},"Plumbing"),(0,a.kt)("p",null,"In programming, we call that something is ",(0,a.kt)("strong",{parentName:"p"},"plumbing"),", roughly speaking, we are saying that is to following instructions to try to tie together a bunch of libraries or components, without fully understanding how they work internally."),(0,a.kt)("p",null,"It requires ",(0,a.kt)("strong",{parentName:"p"},"faith")," and ",(0,a.kt)("strong",{parentName:"p"},"intuition"),". ",(0,a.kt)("strong",{parentName:"p"},"Faith")," is required to believe that if the stars align, and every incantation is correctly performed for this magical machine, the right thing will really happen. And ",(0,a.kt)("strong",{parentName:"p"},"intuition")," is required to work out what has gone wrong, and how to fix things when they don't go as planned."))}c.isMDXComponent=!0},45178:(e,n,t)=>{t.d(n,{Z:()=>r});const r=t.p+"assets/files/error-handling-7c65de85bfe2907255b5d074fe5cb2be.c"},95932:(e,n,t)=>{t.d(n,{Z:()=>r});const r=t.p+"assets/files/parsing-evaluation-9a8fd500a175f7861b45f7b3567bea95.c"}}]);