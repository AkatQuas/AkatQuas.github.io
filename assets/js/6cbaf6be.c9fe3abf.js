"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2942],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>y});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),p=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=p(e.components);return r.createElement(s.Provider,{value:n},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(t),d=a,y=u["".concat(s,".").concat(d)]||u[d]||m[d]||o;return t?r.createElement(y,i(i({ref:n},c),{},{components:t})):r.createElement(y,i({ref:n},c))}));function y(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[u]="string"==typeof e?e:a,i[1]=l;for(var p=2;p<o;p++)i[p]=t[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},97553:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var r=t(87462),a=(t(67294),t(3905));const o={title:"TypeScript handbook",categories:["frontend","typescript"],tags:["typescript"]},i=void 0,l={permalink:"/blog/2021/03/27/ts-handbook",source:"@site/blog/2021-03-27-ts-handbook.md",title:"TypeScript handbook",description:"A quick cheat sheet for TypeScript.",date:"2021-03-27T00:00:00.000Z",formattedDate:"March 27, 2021",tags:[{label:"typescript",permalink:"/blog/tags/typescript"}],readingTime:31.54,hasTruncateMarker:!0,authors:[],frontMatter:{title:"TypeScript handbook",categories:["frontend","typescript"],tags:["typescript"]},prevItem:{title:"Micro Frontends",permalink:"/blog/2021/04/11/micro-frontend"},nextItem:{title:"Distributed Tracing",permalink:"/blog/2021/03/21/distributed-tracing"}},s={authorsImageUrls:[]},p=[{value:"Useful References",id:"useful-references",level:2},{value:"Basic Types",id:"basic-types",level:2},{value:"Boolean",id:"boolean",level:3},{value:"Number",id:"number",level:3},{value:"String",id:"string",level:3},{value:"Array",id:"array",level:3},{value:"Enum",id:"enum",level:3},{value:"Unknown",id:"unknown",level:3},{value:"Any",id:"any",level:3},{value:"Void",id:"void",level:3},{value:"Null and Undefined",id:"null-and-undefined",level:3},{value:"Never",id:"never",level:3},{value:"Object",id:"object",level:3},{value:"Type Assertions",id:"type-assertions",level:3},{value:"Interfaces",id:"interfaces",level:2},{value:"Optional Properties",id:"optional-properties",level:3},{value:"Readonly properties",id:"readonly-properties",level:3},{value:"Excess Property Checks",id:"excess-property-checks",level:3},{value:"Function Types",id:"function-types",level:3},{value:"Indexable Types",id:"indexable-types",level:3},{value:"Conditional Types",id:"conditional-types",level:3},{value:"Distributive Conditional Types",id:"distributive-conditional-types",level:3},{value:"Class Types",id:"class-types",level:3},{value:"Extending Interfaces",id:"extending-interfaces",level:3},{value:"Hybrid Types",id:"hybrid-types",level:3},{value:"Interfaces Extending Classes",id:"interfaces-extending-classes",level:3},{value:"Literal Types",id:"literal-types",level:3},{value:"Functions",id:"functions",level:2},{value:"Function Types",id:"function-types-1",level:3},{value:"Optional and Default Parameters",id:"optional-and-default-parameters",level:3},{value:"Rest Parameters",id:"rest-parameters",level:3},{value:"this parameters",id:"this-parameters",level:3},{value:"Function Overloads",id:"function-overloads",level:3},{value:"Unions and Intersection Types",id:"unions-and-intersection-types",level:2},{value:"Discriminating Unions",id:"discriminating-unions",level:3},{value:"Intersection Types",id:"intersection-types",level:3},{value:"Classes",id:"classes",level:2},{value:"ECMAScript Private Fields",id:"ecmascript-private-fields",level:3},{value:"Accessors",id:"accessors",level:3},{value:"Abstract Classes",id:"abstract-classes",level:3},{value:"Generics",id:"generics",level:2},{value:"Utility Types",id:"utility-types",level:2},{value:"Decorators",id:"decorators",level:2},{value:"Decorator Evaluation",id:"decorator-evaluation",level:3},{value:"Class Decorators",id:"class-decorators",level:3},{value:"Method Decorators",id:"method-decorators",level:3},{value:"Accessor Decorators",id:"accessor-decorators",level:3},{value:"Property Decorator",id:"property-decorator",level:3},{value:"Parameter Decorators",id:"parameter-decorators",level:3},{value:"Declaration",id:"declaration",level:2},{value:"Declaration Merging",id:"declaration-merging",level:3},{value:"Global Declaration Augmentation",id:"global-declaration-augmentation",level:3},{value:"Declaration Files and Reference",id:"declaration-files-and-reference",level:3},{value:"TSConfig",id:"tsconfig",level:2}],c={toc:p};function u(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A quick cheat sheet for TypeScript."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#basic-types"},"Basic Types")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#interfaces"},"Interfaces")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#functions"},"Functions")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#unions-and-intersection-types"},"Unions and Intersection Types")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#classes"},"Classes")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#generics"},"Generics")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#utility-types"},"Utility Types")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#decorators"},"Decorators")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#declaration"},"Declaration")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#tsconfig"},"TSConfig"))),(0,a.kt)("h2",{id:"useful-references"},"Useful References"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/intro.html"},"TypeScript Handbook")),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://basarat.gitbook.io/typescript/"},"TypeScript Deep Dive")),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/typescript-cheatsheets/react"},"React+TypeScript Cheatsheets")),(0,a.kt)("h2",{id:"basic-types"},"Basic Types"),(0,a.kt)("p",null,"Simple units of data such as numbers, strings, booleans, structures."),(0,a.kt)("h3",{id:"boolean"},"Boolean"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"let isDone: boolean = false;\n")),(0,a.kt)("h3",{id:"number"},"Number"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"let decimal: number = 6;\nlet deci_mal: number = 100_000;\nlet hex: number = 0xf00d;\nlet binary: number = 0b1010;\nlet octal: number = 0o744;\nlet big: bigint = 100n;\n")),(0,a.kt)("h3",{id:"string"},"String"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"let color: string = 'blue';\ncolor = 'red';\n// and template strings\nlet fullName: string = `Bob Bobbington`;\nlet age: number = 37;\nlet sentence: string = `Hello, my name is ${fullName}. I'll be ${\n  age + 1\n} years old next month.`;\n// ^ let sentence: string =\n//    'Hello, my name is ' +\n//    fullName +\n//    '.\\n\\n' +\n//    \"I'll be \" +\n//     (age + 1) +\n//    ' years old next month.';\n")),(0,a.kt)("h3",{id:"array"},"Array"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"let list: number[] = [1, 2, 3];\n// generic array type\nlet list: Array<number> = [1, 2, 3];\n\n/_ Array as Tuple _/;\n// Declare a tuple type\nlet x: [string, number] = ['hello', 10];\nx[2] = 'world'; // error, no element at index 2\n")),(0,a.kt)("h3",{id:"enum"},"Enum"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"enum Color {\n  Red /* = 0, inferred */,\n  Color /* = 1, inferred */,\n  Blue /* = 2, inferred */,\n}\nlet c: Color = Color.Green;\n\nenum Color {\n  Red = 1,\n  Green /* = 2, inferred */,\n  Blue /* = 3, inferred */,\n}\nlet c: Color = Color.Green;\n\nenum Color {\n  Red = 1,\n  Green = 2,\n  Blue = 4,\n}\nlet c: Color = Color.Green;\n\nenum Color {\n  Red = 1,\n  Green /* = 2, inferred */,\n  Blue /* = 3, inferred */,\n}\nlet colorName: string = Color[2];\n\n// Displays 'Green'\nconsole.log(colorName);\n\n// string enums\nenum Direction {\n  Up = 'UP',\n  Down = 'DOWN',\n  Left = 'LEFT',\n  Right = 'RIGHT',\n}\n\n// Technically enums can be mixed with string and numeric members,\n// but it\u2019s not clear why you would ever want to do so.\n// OK but why.\nenum BooleanLikeHeterogeneousEnum {\n  No = 0,\n  Yes = 'YES',\n}\n\n// reverse mappings\nenum Enum {\n  A,\n}\n\nlet a = Enum.A;\nlet nameOfA = Enum[a]; // \"A\"\n")),(0,a.kt)("h3",{id:"unknown"},"Unknown"),(0,a.kt)("p",null,"This variable could be anything."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"let notSure: unknown = 4;\nnotSure = 'maybe a string instead';\n\n// OK, definitely a boolean\nnotSure = false;\n")),(0,a.kt)("h3",{id:"any"},"Any"),(0,a.kt)("p",null,"We might want to opt-out of type checking."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"declare function getValue(key: string): any;\n// OK, return value of 'getValue' is not checked\nconst str: string = getValue('myString');\n\nlet looselyTyped: any = {};\nlet d = looselyTyped.a.b.c.d;\n//  ^ = let d: any, type inference is propagated\n")),(0,a.kt)("h3",{id:"void"},"Void"),(0,a.kt)("p",null,"The absence of having any type at all."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function warnUser(): void {\n  console.log('This is my warning message');\n}\n")),(0,a.kt)("p",null,"You would get and type error if you assign ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," to a void variable (only if ",(0,a.kt)("inlineCode",{parentName:"p"},"--strictNullChecks")," is not specified)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"let unusable: void = undefined;\n// OK if `--strictNullChecks` is not given\nunusable = null;\n")),(0,a.kt)("h3",{id:"null-and-undefined"},"Null and Undefined"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// Not much else we can assign to these variables!\nlet u: undefined = undefined;\nlet n: null = null;\n")),(0,a.kt)("h3",{id:"never"},"Never"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"never")," type represents the type of values that never occur. For instance, ",(0,a.kt)("inlineCode",{parentName:"p"},"never")," is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// Function returning never must not have a reachable end point\nfunction error(message: string): never {\n  throw new Error(message);\n}\n\n// Inferred return type is never\nfunction fail() {\n  return error('Something failed');\n}\n\n// Function returning never must not have a reachable end point\nfunction infiniteLoop(): never {\n  while (true) {}\n}\n")),(0,a.kt)("h3",{id:"object"},"Object"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"object")," is a type that represents the non-primitive type, i.e. anything that is not ",(0,a.kt)("inlineCode",{parentName:"p"},"number"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"boolean"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"bigint"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"symbol"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"null"),", or ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined"),"."),(0,a.kt)("p",null,"Generally, use ",(0,a.kt)("inlineCode",{parentName:"p"},"Type")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"Interface")," rather than ",(0,a.kt)("inlineCode",{parentName:"p"},"object"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"declare function create(o: object | null): void;\n\n// OK\ncreate({ prop: 0 });\ncreate(null);\n\ncreate(undefined); // Remember, undefined is not a subtype of null\n// Argument of type 'undefined' is not assignable to parameter of type 'object | null'.\n\ncreate(42);\n// Argument of type '42' is not assignable to parameter of type 'object | null'.\n\ncreate('string');\n// Argument of type '\"string\"' is not assignable to parameter of type 'object | null'.\n\ncreate(false);\n// Argument of type 'false' is not assignable to parameter of type 'object | null'.\n")),(0,a.kt)("h3",{id:"type-assertions"},"Type Assertions"),(0,a.kt)("p",null,"Type assertions are a way to tell the compiler ",(0,a.kt)("em",{parentName:"p"},"trust me, I know what I\u2019m doing"),"."),(0,a.kt)("p",null,"A type assertion is like a type cast in other languages, but it performs no special checking or restructuring of data."),(0,a.kt)("p",null,"It has no runtime impact and is used purely by the compiler."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// as syntax\nlet someValue: unknown = 'this is a string';\nlet strLength: number = (someValue as string).length;\n\n// angle-bracket syntax\nlet someValue: unknown = 'this is a string';\nlet strLength: number = (<string>someValue).length;\n")),(0,a.kt)("h2",{id:"interfaces"},"Interfaces"),(0,a.kt)("p",null,"This is sometimes called ",(0,a.kt)("em",{parentName:"p"},"duck typing")," or ",(0,a.kt)("em",{parentName:"p"},"structural subtyping"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function printLabel(labeledObj: { label: string }) {\n  console.log(labeledObj.label);\n}\n\n// more properties is fine\nlet myObj = { size: 10, label: 'Size 10 Object' };\nprintLabel(myObj);\n\n// --- equivalent\n\ninterface LabeledValue {\n  label: string;\n}\n\nfunction printLabel(labeledObj: LabeledValue) {\n  console.log(labeledObj.label);\n}\n\nlet myObj = { size: 10, label: 'Size 10 Object' };\nprintLabel(myObj);\n")),(0,a.kt)("h3",{id:"optional-properties"},"Optional Properties"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface SquareConfig {\n  color?: string;\n  width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n  let newSquare = { color: 'white', area: 100 };\n  if (config.color) {\n    newSquare.color = config.color;\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  return newSquare;\n}\n\nlet mySquare = createSquare({ color: 'black' });\n")),(0,a.kt)("h3",{id:"readonly-properties"},"Readonly properties"),(0,a.kt)("p",null,"Some properties should only be modifiable when an object is first created."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Variables use const whereas properties use readonly.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface Point {\n  readonly x: number;\n  readonly y: number;\n}\n\nlet p1: Point = { x: 10, y: 20 };\np1.x = 5; // error!\n\nlet a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\nro[0] = 12; // error!\nro.push(5); // error!\na = ro; // error!\n\na = ro as number[]; // OK\n")),(0,a.kt)("h3",{id:"excess-property-checks"},"Excess Property Checks"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface SquareConfig {\n  color?: string;\n  width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n  return {\n    color: config.color || 'red',\n    area: config.width ? config.width * config.width : 20,\n  };\n}\n\nlet mySquare = createSquare({ colour: 'red', width: 100 });\n// Error, compiler think it is a potential bug\n\nlet mySquare = createSquare({\n  colour: 'red',\n  width: 100,\n} as SquareConfig);\n// OK\n\n// --- better\n\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n  [propName: string]: any;\n}\n\nlet mySquare = createSquare({ colour: 'red', width: 100 });\n// now is OK, common property `width`\n\nlet mySquare = createSquare({ colour: 'red' });\n// Error, no common properties\n")),(0,a.kt)("h3",{id:"function-types"},"Function Types"),(0,a.kt)("p",null,"To describe a function type with an interface, we give the interface a call signature. This is like a function declaration with only the parameter list and return type given."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface SearchFunc {\n  (source: string, subString: string): boolean;\n}\n\nlet mySearch: SearchFunc;\nmySearch = function (source: string, subString: string) {\n  let result = source.search(subString);\n  return result > -1;\n};\n\n// using different parameter name\n// types are inferred\nmySearch = function (src, sub) {\n  let result = src.search(sub);\n  return result > -1;\n};\n")),(0,a.kt)("h3",{id:"indexable-types"},"Indexable Types"),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"index signature"),", use that type to index into the object."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface StringArray {\n  [index: number]: string;\n}\n\nlet myArray: StringArray;\nmyArray = ['Bob', 'Frend'];\n\nlet myStr: string = myArray[0];\n")),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"indexed access type")," to look up a specific property on another type."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"type Person = { age: number; name: string; alive: boolean };\n\ntype Age = Person['age'];\n//   ^ = type Age = number\n\ntype I1 = Person['age' | 'name'];\n//   ^ = type I1 = string | number\n\ntype I2 = Person[keyof Person];\n//   ^ = type I2 = string | number | boolean\n\ntype AliveOrName = 'alive' | 'name';\ntype I3 = Person[AliveOrName];\n//   ^ = type I3 = string | boolean\n\nconst MyArray = [\n  { name: 'Alice', age: 15 },\n  { name: 'Bob', age: 23 },\n  { name: 'Eve', age: 38 },\n];\n\ntype Person = typeof MyArray[number];\n//   ^ = type Person = {\n//       name: string;\n//       age: number;\n//   }\ntype Age = typeof MyArray[number]['age'];\n//   ^ = type Age = number\n// Or\ntype Age2 = Person['age'];\n//   ^ = type Age2 = number\n")),(0,a.kt)("h3",{id:"conditional-types"},"Conditional Types"),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Conditional types")," help describe the relation between the types of inputs and outputs."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface Animal {\n  live(): void;\n}\ninterface Dog extends Animal {\n  woof(): void;\n}\n\ntype Example1 = Dog extends Animal ? number : string;\n//   ^ = type Example1 = number\n\ntype Example2 = RegExp extends Animal ? number : string;\n//   ^ = type Example2 = string\n\ntype NumberOrString<T extends number | string> = T extends number\n  ? NumberType\n  : StringType;\n\ntype MessageOf<T> = T extends { message: unknown } ? T['message'] : never;\n\ntype Flatten<Type> = Type extends Array<infer Item> ? Item : Type;\n")),(0,a.kt)("h3",{id:"distributive-conditional-types"},"Distributive Conditional Types"),(0,a.kt)("p",null,"When conditional types act on a generic type, they become distributive when given a union type."),(0,a.kt)("p",null,"Typically, distributivity is the desired behavior. To avoid that behavior, you can surround each side of the extends keyword with square brackets."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"type ToArray<Type> = Type extends any ? Type[] : never;\ntype StrArrOrNumArr = ToArray<string | number>;\n//   ^ = type StrArrOrNumArr = string[] | number[]\n//   ^ !! not <string | number>[]\n\ntype ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;\n// 'StrOrNumArr' is no longer a union.\ntype StrOrNumArr = ToArrayNonDist<string | number>;\n//   ^ = type StrOrNumArr = (string | number)[]\n//   ^ !! not string[] | number[]\n")),(0,a.kt)("h3",{id:"class-types"},"Class Types"),(0,a.kt)("p",null,"Explicitly enforce a class meets (",(0,a.kt)("em",{parentName:"p"},"implements"),") a particular contract (",(0,a.kt)("em",{parentName:"p"},"interface"),")."),(0,a.kt)("p",null,"Interfaces describe the public side of the class, rather than both the public and private side."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface ClockInterface {\n  currentTime: Date;\n  setTime(d: Date): void;\n}\n\nclass Clock implements ClockInterface {\n  currentTime: Date = new Date();\n  setTime(d: Date) {\n    this.currentTime = d;\n  }\n  constructor(h: number, m: number) {}\n}\n")),(0,a.kt)("p",null,"When a class implements an interface, only the instance side of the class is checked. Since the constructor sits in the static side, it is not included in this check."),(0,a.kt)("p",null,"See the following example."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface ClockConstructor {\n  new (hour: number, minute: number);\n}\n\nclass Clock implements ClockConstructor {\n  // Error\n  // Class 'Clock' incorrectly implements interface 'ClockConstructor'.\n  // Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'.\n  currentTime: Date;\n  constructor(h: number, m: number) {}\n}\n\n// --- fix it\n\n// constructor interface\ninterface ClockConstructor {\n  new (hour: number, minute: number): ClockInterface;\n}\n\n// class interface\ninterface ClockInterface {\n  tick(): void;\n}\n\n// factory function\nfunction createClock(\n  ctor: ClockConstructor,\n  hour: number,\n  minute: number\n): ClockInterface {\n  return new ctor(hour, minute);\n}\n\nclass DigitalClock implements ClockInterface {\n  constructor(h: number, m: number) {}\n  tick() {\n    console.log('beep beep');\n  }\n}\n\nclass AnalogClock implements ClockInterface {\n  constructor(h: number, m: number) {}\n  tick() {\n    console.log('tick tock');\n  }\n}\n\nlet digital = createClock(DigitalClock, 12, 17);\nlet analog = createClock(AnalogClock, 7, 32);\n\n// ---\n// Another simple way is to use class expressions:\n\ninterface ClockConstructor {\n  new (hour: number, minute: number): ClockInterface;\n}\n\ninterface ClockInterface {\n  tick(): void;\n}\n\n// class expressions\nconst Clock: ClockConstructor = class Clock implements ClockInterface {\n  constructor(h: number, m: number) {}\n  tick() {\n    console.log('beep beep');\n  }\n};\n\nlet clock = new Clock(12, 17);\nclock.tick();\n")),(0,a.kt)("h3",{id:"extending-interfaces"},"Extending Interfaces"),(0,a.kt)("p",null,"You can copy the members of one interface into another."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface Shape {\n  color: string;\n}\n\ninterface PenStroke {\n  penWidth: number;\n}\n\ninterface Square extends Shape, PenStroke {\n  sideLength: number;\n}\n\nlet square = {} as Square;\nsquare.color = 'blue';\nsquare.sideLength = 10;\nsquare.penWidth = 5.0;\n")),(0,a.kt)("h3",{id:"hybrid-types"},"Hybrid Types"),(0,a.kt)("p",null,"When interacting with 3rd-party JavaScript, you may need to use patterns like the following to fully describe the shape of the type."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface Counter {\n  (start: number): string;\n  interval: number;\n  reset(): void;\n}\n\nfunction getCounter(): Counter {\n  let counter = function (start: number) {} as Counter;\n  counter.interval = 1;\n  counter.reset = function () {};\n  return counter;\n}\n\nlet c = getCounter();\nc(10);\nc.reset();\nc.interval = 5.0;\n")),(0,a.kt)("h3",{id:"interfaces-extending-classes"},"Interfaces Extending Classes"),(0,a.kt)("p",null,"When an interface type extends a class type it inherits the members of the class but not their implementations."),(0,a.kt)("p",null,"Interfaces inherit even the private and protected members of a base class. This means that when you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"class Control {\n  private state: number;\n}\n\ninterface SelectableControl extends Control {\n  select(): void;\n}\n\nclass Button extends Control implements SelectableControl {\n  select() {\n    this.state = 3;\n    // Error, Property 'state' is private and only accessible within class 'Control'.\n  }\n}\n\nclass TextBox extends Control {\n  select() {\n    this.state = 3;\n    // Error, Property 'state' is private and only accessible within class 'Control'.\n  }\n}\n\nclass ImageControl implements SelectableControl {\n  // Class 'ImageControl' incorrectly implements interface 'SelectableControl'.\n  // Types have separate declarations of a private property 'state'.\n  // Class 'ImageControl' cannot implement SelectableControl.\n  private state: string | any;\n  select() {}\n}\n")),(0,a.kt)("h3",{id:"literal-types"},"Literal Types"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"type Easing = 'ease-in' | 'ease-out' | 'ease-in-out';\n\nfunction rollDice(): 1 | 2 | 3 | 4 | 5 | 6 {\n  return (Math.floor(Math.random() * 6) + 1) as 1 | 2 | 3 | 4 | 5 | 6;\n}\n\ninterface MapConfig {\n  lng: number;\n  lat: number;\n  tileSize: 8 | 16 | 32;\n}\n\ninterface ValidationSuccess {\n  isValid: true;\n  reason: null;\n}\n\ninterface ValidationFailure {\n  isValid: false;\n  reason: string;\n}\n\ntype ValidationResult = ValidationSuccess | ValidationFailure;\n")),(0,a.kt)("h2",{id:"functions"},"Functions"),(0,a.kt)("h3",{id:"function-types-1"},"Function Types"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// Named function\nfunction add(x: number, y: number): number {\n  return x + y;\n}\n\n// Anonymous function\nlet myAdd = function (x: number, y: number): number {\n  return x + y;\n};\n\nlet myAdd: (x: number, y: number) => number = function (\n  x: number,\n  y: number\n): number {\n  return x + y;\n};\n\nlet myAdd: (baseValue: number, increment: number) => number = function (\n  x: number,\n  y: number\n): number {\n  return x + y;\n};\n\n// the full function type\nlet myAdd: (baseValue: number, increment: number) => number = function (x, y) {\n  return x + y;\n};\n\ntype DescribableFunction = {\n  description: string;\n  (someArg: number): boolean;\n};\n\nfunction doSomething(fn: DescribableFunction) {\n  console.log(fn.description + ' returned ' + fn(6));\n}\n\nfunction map<Input, Output>(\n  arr: Input[],\n  func: (arg: Input) => Output\n): Output[] {\n  return arr.map(func);\n}\nfunction combine<T>(arr1: T[], arr2: T[]): T[] {\n  return arr1.concat(arr2);\n}\n")),(0,a.kt)("h3",{id:"optional-and-default-parameters"},"Optional and Default Parameters"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function buildName(firstName: string, lastName?: string) {\n  if (lastName) {\n    return firstName + ' ' + lastName;\n  } else {\n    return firstName;\n  }\n}\n\nfunction buildName(firstName: string, lastName = 'Smith') {\n  return firstName + ' ' + lastName;\n}\n")),(0,a.kt)("h3",{id:"rest-parameters"},"Rest Parameters"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function buildName(firstName: string, ...restOfName: string[]) {\n  return firstName + ' ' + restOfName.join(' ');\n}\n\n// employeeName will be \"Joseph Samuel Lucas MacKinzie\"\nlet employeeName = buildName('Joseph', 'Samuel', 'Lucas', 'MacKinzie');\n\nlet buildNameFun: (fname: string, ...rest: string[]) => string = buildName;\n")),(0,a.kt)("h3",{id:"this-parameters"},"this parameters"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface Card {\n  suit: string;\n  card: number;\n}\n\ninterface Deck {\n  suits: string[];\n  cards: number[];\n  createCardPicker(this: Deck): () => Card;\n}\n\nlet deck: Deck = {\n  suits: ['hearts', 'spades', 'clubs', 'diamonds'],\n  cards: Array(52),\n  // NOTE: The function now explicitly specifies that its callee must be of type Deck\n  createCardPicker: function (this: Deck) {\n    return () => {\n      let pickedCard = Math.floor(Math.random() * 52);\n      let pickedSuit = Math.floor(pickedCard / 13);\n\n      return { suit: this.suits[pickedSuit], card: pickedCard % 13 };\n    };\n  },\n};\n\nlet cardPicker = deck.createCardPicker();\nlet pickedCard = cardPicker();\n\nalert('card: ' + pickedCard.card + ' of ' + pickedCard.suit);\n")),(0,a.kt)("h3",{id:"function-overloads"},"Function Overloads"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface pickCardFn {\n  (x: { suit: string; card: number }[]): number;\n  (x: number): { suit: string; card: number };\n}\n\nlet suits = ['hearts', 'spades', 'clubs', 'diamonds'];\n\nfunction pickCard(x: { suit: string; card: number }[]): number;\nfunction pickCard(x: number): { suit: string; card: number };\nfunction pickCard(x: any): any {\n  // Check to see if we're working with an object/array\n  // if so, they gave us the deck and we'll pick the card\n  if (typeof x == 'object') {\n    let pickedCard = Math.floor(Math.random() * x.length);\n    return pickedCard;\n  }\n  // Otherwise just let them pick the card\n  else if (typeof x == 'number') {\n    let pickedSuit = Math.floor(x / 13);\n    return { suit: suits[pickedSuit], card: x % 13 };\n  }\n}\n")),(0,a.kt)("h2",{id:"unions-and-intersection-types"},"Unions and Intersection Types"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * Takes a string and adds \"padding\" to the left.\n * If 'padding' is a string, then 'padding' is appended to the left side.\n * If 'padding' is a number, then that number of spaces is added to the left side.\n */\nfunction padLeft(value: string, padding: string | number) {\n  // ...\n}\n")),(0,a.kt)("h3",{id:"discriminating-unions"},"Discriminating Unions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"type NetworkLoadingState = {\n  state: 'loading';\n};\n\ntype NetworkFailedState = {\n  state: 'failed';\n  code: number;\n};\n\ntype NetworkSuccessState = {\n  state: 'success';\n  response: {\n    title: string;\n    duration: number;\n    summary: string;\n  };\n};\n\ntype NetworkFromCachedState = {\n  state: 'from_cache';\n  id: string;\n  response: NetworkSuccessState['response'];\n};\n\n// Create a type which represents only one of the above types\n// but you aren't sure which it is yet.\ntype NetworkState =\n  | NetworkLoadingState\n  | NetworkFailedState\n  | NetworkSuccessState;\n\nfunction logger(state: NetworkState): string {\n  // Right now TypeScript does not know which of the three\n  // potential types state could be.\n\n  // Trying to access a property which isn't shared\n  // across all types will raise an error\n  state.code;\n  // Error\n  // Property 'code' does not exist on type 'NetworkState'.\n  // Property 'code' does not exist on type 'NetworkLoadingState'.\n\n  // By switching on state, TypeScript can narrow the union\n  // down in code flow analysis\n  switch (state.state) {\n    case 'loading':\n      return 'Downloading...';\n    case 'failed':\n      // The type must be NetworkFailedState here,\n      // so accessing the `code` field is safe\n      return `Error ${state.code} downloading`;\n    case 'success':\n      return `Downloaded ${state.response.title} - ${state.response.summary}`;\n  }\n}\n")),(0,a.kt)("h3",{id:"intersection-types"},"Intersection Types"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"Person & Serializable & Loggable")," is a type which is all of ",(0,a.kt)("inlineCode",{parentName:"p"},"Person")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Serializable")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Loggable"),". That means an object of this type will have all members of all three types.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface ErrorHandling {\n  success: boolean;\n  error?: { message: string };\n}\n\ninterface ArtworksData {\n  artworks: { title: string }[];\n}\n\ninterface ArtistsData {\n  artists: { name: string }[];\n}\n\n// These interfaces are composed to have\n// consistent error handling, and their own data.\ntype ArtworksResponse = ArtworksData & ErrorHandling;\ntype ArtistsResponse = ArtistsData & ErrorHandling;\n\nconst handleArtistsResponse = (response: ArtistsResponse) => {\n  if (response.error) {\n    console.error(response.error.message);\n    return;\n  }\n\n  console.log(response.artists);\n};\n")),(0,a.kt)("h2",{id:"classes"},"Classes"),(0,a.kt)("h3",{id:"ecmascript-private-fields"},"ECMAScript Private Fields"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"class Animal {\n  #name: string;\n  constructor(theName: string) {\n    this.#name = theName;\n  }\n}\n\nnew Animal('Cat').#name;\n// Error\n// Property '#name' is not accessible outside class 'Animal' because it has a private identifier.\n")),(0,a.kt)("h3",{id:"accessors"},"Accessors"),(0,a.kt)("p",null,"TypeScript supports ",(0,a.kt)("em",{parentName:"p"},"getters/setters")," as a way of intercepting accesses to a member of an object. This gives you a way of having finer-grained control over how a member is accessed on each object."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const fullNameMaxLength = 10;\n\nclass Employee {\n  private _fullName: string = '';\n\n  get fullName(): string {\n    return this._fullName;\n  }\n\n  set fullName(newName: string) {\n    if (newName && newName.length > fullNameMaxLength) {\n      throw new Error('fullName has a max length of ' + fullNameMaxLength);\n    }\n\n    this._fullName = newName;\n  }\n}\n\nlet employee = new Employee();\nemployee.fullName = 'Bob Smith';\n\nif (employee.fullName) {\n  console.log(employee.fullName);\n}\n")),(0,a.kt)("h3",{id:"abstract-classes"},"Abstract Classes"),(0,a.kt)("p",null,"Abstract classes are base classes from which other classes may be derived. They may not be instantiated directly."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"abstract class Animal {\n  abstract makeSound(): void;\n\n  move(): void {\n    console.log('roaming the earth...');\n  }\n}\n\n// using extends to derive/inherit , not implements\nclass Dog extends Animal {\n  makeSound() {\n    super.makeSound();\n    // Error, Abstract method 'makeSound' in class 'Animal' cannot be accessed via super expression.\n  }\n  move() {\n    super.move();\n    // OK\n  }\n}\nlet dog = new Dog();\ndog.move();\n")),(0,a.kt)("h2",{id:"generics"},"Generics"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function identity<T>(arg: T): T {\n  return arg;\n}\n\nlet myIdentity: <T>(arg: T) => T = identity;\nlet myIdentity: <U>(arg: U) => U = identity;\n\nlet myIdentity: { <T>(arg: T): T } = identity;\ninterface GenericIdentityFn {\n  <T>(arg: T): T;\n}\nlet myIdentity: GenericIdentityFn = identity;\n\nfunction loggingIdentity<T>(arg: T[]): T[] {\n  console.log(arg.length);\n  return arg;\n}\n\nclass GenericNumber<T> {\n  zeroValue: T;\n  add: (x: T, y: T) => T;\n}\n\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function (x, y) {\n  return x + y;\n};\n\n/* Generic constraints */\ninterface Lengthwise {\n  length: number;\n}\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length); // Now we know it has a .length property, so no more error\n  return arg;\n}\n\n/* Type parameters in generic constraints */\nfunction getProperty<T, K extends keyof T>(obj: T, key: K) {\n  return obj[key];\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 };\n\ngetProperty(x, 'a');\n")),(0,a.kt)("h2",{id:"utility-types"},"Utility Types"),(0,a.kt)("p",null,"TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"keyof Type")),": takes an object type and produces a string or numeric literal union of its keys."),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"type Keys = keyof Type"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'type Point = { x: number; y: number };\ntype P = keyof Point;\n//   ^ = type P = "x" | "y"\n'))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"typeof Type")),": an operator to use in a type context to refer to the type of a variable or property."),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"type TypeB = typeof Type"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"let s = 'hello';\nlet n: typeof s;\n//  ^ = let n: string;\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"Partial<Type>")),": a type represents all subset of a given type"),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"type Partial<T> = { [P in keyof T]?: T[P] | undefined; }"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface Todo {\n  title: string;\n  description: string;\n}\n\nfunction updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {\n  return { ...todo, ...fieldsToUpdate };\n}\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"Required<Type>")),": make all properties required"),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"type Required<T> = { [P in keyof T]-?: T[P]; }"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface Props {\n  a?: number;\n  b?: string;\n}\n\nconst obj: Required<Props> = { a: 5, b: '3' };\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"Readonly<Type>")),": make all properties of Type set to readonly"),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"type Readonly<T> = { readonly [P in keyof T]: T[P]; }"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface Todo {\n  title: string;\n}\nconst todo: Readonly<Todo> = {\n  title: 'Delete inactive users',\n};\n\ntodo.title = 'Hello';\n// Error, title is read-only\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"Record<Keys, Type>")),": construct an object type whose property keys are ",(0,a.kt)("inlineCode",{parentName:"p"},"Keys"),", and whose property values are ",(0,a.kt)("inlineCode",{parentName:"p"},"Type"),"."),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"type Record<K extends string | number | symbol, T> = { [P in K]: T; }"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface PageInfo {\n  title: string;\n}\n\ntype Page = 'home' | 'about' | 'contact';\n\nconst nav: Record<Page, PageInfo> = {\n  about: { title: 'about' },\n  contact: { title: 'contact' },\n  home: { title: 'home' },\n};\n\nnav.about;\n// ^ = const nav: Record\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"Pick<Type, Keys>")),": construct a type by picking the set of properties ",(0,a.kt)("inlineCode",{parentName:"p"},"Keys")," from ",(0,a.kt)("inlineCode",{parentName:"p"},"Type"),"."),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"type Pick<T, K extends keyof T> = { [P in K]: T[P]; }"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface Todo {\n  title: string;\n  description: string;\n  completed: boolean;\n}\n\ntype TodoPreview = Pick<Todo, 'title' | 'completed'>;\n\nconst todo: TodoPreview = {\n  title: 'Clean room',\n  completed: false,\n};\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"Omit<Type, Keys>")),": constructs a type by picking all properties from ",(0,a.kt)("inlineCode",{parentName:"p"},"Type")," and then removing ",(0,a.kt)("inlineCode",{parentName:"p"},"Keys"),"."),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"type Omit<T, K extends string | number | symbol> = { [P in Exclude<keyof T, K>]: T[P]; }"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface Todo {\n  title: string;\n  description: string;\n  completed: boolean;\n}\n\ntype TodoPreview = Omit<Todo, 'description'>;\n\nconst todo: TodoPreview = {\n  title: 'Clean room',\n  completed: false,\n};\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"Exclude<Type, ExcludedUnion>")),": construct a type by excluding from ",(0,a.kt)("inlineCode",{parentName:"p"},"Type")," all union members that are assignable to ExcludedUnion."),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"type Exclude<T, U> = T extends U ? never : T"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"type T0 = Exclude<'a' | 'b' | 'c', 'a'>;\n//    ^ = type T0 = \"b\" | \"c\"\ntype T1 = Exclude<'a' | 'b' | 'c', 'a' | 'b'>;\n//    ^ = type T1 = \"c\"\ntype T2 = Exclude<string | number | (() => void), Function>;\n//    ^ = type T2 = string | number\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"Extract<Type, Union>")),": constructs a type by extracting from ",(0,a.kt)("inlineCode",{parentName:"p"},"Type")," all union members that are assignable to ",(0,a.kt)("inlineCode",{parentName:"p"},"Union"),"."),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"type Extract<T, U> = T extends U ? T : never"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"type T0 = Extract<'a' | 'b' | 'c', 'a' | 'f'>;\n//    ^ = type T0 = \"a\"\ntype T1 = Extract<string | number | (() => void), Function>;\n//    ^ = type T1 = () => void\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"NonNullable<Type>")),": constructs a type by excluding ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined")," from ",(0,a.kt)("inlineCode",{parentName:"p"},"Type"),"."),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"type NonNullable<T> = T extends null | undefined ? never : T"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"type T0 = NonNullable<string | number | undefined>;\n//    ^ = type T0 = string | number\ntype T1 = NonNullable<string[] | null | undefined>;\n//    ^ = type T1 = string[]\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"Parameters<Type>")),": constructs a tuple type from the types used in the parameters of a function type ",(0,a.kt)("inlineCode",{parentName:"p"},"Type"),"."),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"declare function f1(arg: { a: number; b: string }): void;\n\ntype T0 = Parameters<() => string>;\n//    ^ = type T0 = []\ntype T1 = Parameters<(s: string) => void>;\n//    ^ = type T1 = [s: string]\ntype T2 = Parameters<<T>(arg: T) => T>;\n//    ^ = type T2 = [arg: unknown]\ntype T3 = Parameters<typeof f1>;\n//    ^ = type T3 = [arg: {\n//        a: number;\n//        b: string;\n//    }]\ntype T4 = Parameters<any>;\n//    ^ = type T4 = unknown[]\ntype T5 = Parameters<never>;\n//    ^ = type T5 = never\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"ConstructorParameters<Type>")),": constructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the type never if ",(0,a.kt)("inlineCode",{parentName:"p"},"Type")," is not a function)."),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"type ConstructorParameters<T extends new (...args: any) => any> = T extends new (...args: infer P) => any ? P : never"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"type T0 = ConstructorParameters<ErrorConstructor>;\n//    ^ = type T0 = [message?: string]\ntype T1 = ConstructorParameters<FunctionConstructor>;\n//    ^ = type T1 = string[]\ntype T2 = ConstructorParameters<RegExpConstructor>;\n//    ^ = type T2 = [pattern: string | RegExp, flags?: string]\ntype T3 = ConstructorParameters<any>;\n//    ^ = type T3 = unknown[]\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"ReturnType<Type>")),": constructs a type consisting of the return type of function ",(0,a.kt)("inlineCode",{parentName:"p"},"Type"),"."),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"declare function f1(): { a: number; b: string };\n\ntype T0 = ReturnType<() => string>;\n//    ^ = type T0 = string\ntype T1 = ReturnType<(s: string) => void>;\n//    ^ = type T1 = void\ntype T2 = ReturnType<<T>() => T>;\n//    ^ = type T2 = unknown\ntype T3 = ReturnType<<T extends U, U extends number[]>() => T>;\n//    ^ = type T3 = number[]\ntype T4 = ReturnType<typeof f1>;\n//    ^ = type T4 = {\n//        a: number;\n//        b: string;\n//    }\ntype T5 = ReturnType<any>;\n//    ^ = type T5 = any\ntype T6 = ReturnType<never>;\n//    ^ = type T6 = never\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"InstanceType<Type>")),": constructs a type consisting of the instance type of a constructor function in ",(0,a.kt)("inlineCode",{parentName:"p"},"Type"),"."),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"type InstanceType<T extends new (...args: any) => any> = T extends new (...args: any) => infer R ? R : any"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"class C {\n  x = 0;\n  y = 0;\n}\n\ntype T0 = InstanceType<typeof C>;\n//    ^ = type T0 = C\ntype T1 = InstanceType<any>;\n//    ^ = type T1 = any\ntype T2 = InstanceType<never>;\n//    ^ = type T2 = never\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"ThisParameterType<Type>")),": extracts the type of the ",(0,a.kt)("em",{parentName:"p"},"this")," parameter for a function type, or unknown if the function type has no ",(0,a.kt)("em",{parentName:"p"},"this")," parameter."),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"type ThisParameterType<T> = T extends (this: infer U, ...args: any[]) => any ? U : unknown"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function toHex(this: Number) {\n  return this.toString(16);\n}\n\nfunction numberToString(n: ThisParameterType<typeof toHex>) {\n  return toHex.apply(n);\n}\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"OmitThisParameter<Type>")),": removes the ",(0,a.kt)("em",{parentName:"p"},"this")," parameter from ",(0,a.kt)("inlineCode",{parentName:"p"},"Type"),". If ",(0,a.kt)("inlineCode",{parentName:"p"},"Type")," has no explicitly declared ",(0,a.kt)("em",{parentName:"p"},"this")," parameter, the result is simply ",(0,a.kt)("inlineCode",{parentName:"p"},"Type"),". Otherwise, a new function type with no ",(0,a.kt)("em",{parentName:"p"},"this")," parameter is created from ",(0,a.kt)("inlineCode",{parentName:"p"},"Type"),". Generics are erased and only the last overload signature is propagated into the new function type."),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"type OmitThisParameter<T> = unknown extends ThisParameterType<T> ? T : T extends (...args: infer A) => infer R ? (...args: A) => R : T"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function toHex(this: Number) {\n  return this.toString(16);\n}\n\nconst fiveToHex: OmitThisParameter<typeof toHex> = toHex.bind(5);\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"ThisType<Type>")),": serves as a marker for a contextual ",(0,a.kt)("em",{parentName:"p"},"this")," type. This utility does not return a transformed type."),(0,a.kt)("blockquote",{parentName:"li"},(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("inlineCode",{parentName:"p"},"interface ThisType<T>"))),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"type ObjectDescriptor<D, M> = {\n  data?: D;\n  methods?: M & ThisType<D & M>; // Type of 'this' in methods is D & M\n};\n\nfunction makeObject<D, M>(desc: ObjectDescriptor<D, M>): D & M {\n  let data: object = desc.data || {};\n  let methods: object = desc.methods || {};\n  return { ...data, ...methods } as D & M;\n}\n\nlet obj = makeObject({\n  data: { x: 0, y: 0 },\n  methods: {\n    moveBy(dx: number, dy: number) {\n      this.x += dx; // Strongly typed this\n      this.y += dy; // Strongly typed this\n    },\n  },\n});\n")),(0,a.kt)("span",null))),(0,a.kt)("p",null,"Be smart to use these types."),(0,a.kt)("h2",{id:"decorators"},"Decorators"),(0,a.kt)("h3",{id:"decorator-evaluation"},"Decorator Evaluation"),(0,a.kt)("p",null,"There is a well-defined order to how decorators applied to various declarations inside of a class are applied:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"Parameter Decorators"),", followed by ",(0,a.kt)("em",{parentName:"li"},"Method"),", ",(0,a.kt)("em",{parentName:"li"},"Accessor"),", or ",(0,a.kt)("em",{parentName:"li"},"Property Decorators")," are applied for each instance member."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"Parameter Decorators"),", followed by ",(0,a.kt)("em",{parentName:"li"},"Method"),", ",(0,a.kt)("em",{parentName:"li"},"Accessor"),", or ",(0,a.kt)("em",{parentName:"li"},"Property Decorators")," are applied for each static member."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"Parameter Decorators")," are applied for the constructor."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"Class Decorators")," are applied for the class.")),(0,a.kt)("h3",{id:"class-decorators"},"Class Decorators"),(0,a.kt)("p",null,"The class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition."),(0,a.kt)("p",null,"A class decorator ",(0,a.kt)("em",{parentName:"p"},"cannot")," be used in a declaration file, nor in any other ambient context (such as on a ",(0,a.kt)("inlineCode",{parentName:"p"},"declare")," class)."),(0,a.kt)("p",null,"The expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function classDecorator<T extends { new (...args: any[]): {} }>(ctor: T) {\n  return class extends ctor {\n    newProperty = 'new property';\n    hello = 'override hello';\n  };\n}\n\n@classDecorator\nclass Greeter {\n  property = 'property';\n  hello: string;\n  constructor(m: string) {\n    this.hello = m;\n  }\n}\n")),(0,a.kt)("h3",{id:"method-decorators"},"Method Decorators"),(0,a.kt)("p",null,"The decorator is applied to the Property Descriptor for the method, and can be used to observe, modify, or replace a method definition."),(0,a.kt)("p",null,"A method decorator ",(0,a.kt)("em",{parentName:"p"},"cannot")," be used in a declaration file, on an overload, nor in any other ambient context (such as in a ",(0,a.kt)("inlineCode",{parentName:"p"},"declare")," class)."),(0,a.kt)("p",null,"The expression for the method decorator will be called as a function at runtime, with the following three arguments:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Either the constructor function of the class for a static member, or the prototype of the class for an instance member."),(0,a.kt)("li",{parentName:"ol"},"The name of the member."),(0,a.kt)("li",{parentName:"ol"},"The Property Descriptor for the member.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function enumerable(value: boolean) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    descriptor.enumerable = value;\n  };\n}\n\nclass Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  @enumerable(false)\n  greet() {\n    return 'Hello, ' + this.greeting;\n  }\n}\n")),(0,a.kt)("h3",{id:"accessor-decorators"},"Accessor Decorators"),(0,a.kt)("p",null,"The accessor decorator is applied to the Property Descriptor for the accessor and can be used to observe, modify, or replace an accessor\u2019s definitions."),(0,a.kt)("p",null,"An accessor decorator ",(0,a.kt)("em",{parentName:"p"},"cannot")," be used in a declaration file, nor in any other ambient context (such as in a ",(0,a.kt)("inlineCode",{parentName:"p"},"declare")," class)."),(0,a.kt)("p",null,"The expression for the accessor decorator will be called as a function at runtime, with the following three arguments:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Either the constructor function of the class for a static member, or the prototype of the class for an instance member."),(0,a.kt)("li",{parentName:"ol"},"The name of the member."),(0,a.kt)("li",{parentName:"ol"},"The Property Descriptor for the member.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function configurable(value: boolean) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    descriptor.configurable = value;\n  };\n}\n\nclass Point {\n  private _x: number;\n  private _y: number;\n  constructor(x: number, y: number) {\n    this._x = x;\n    this._y = y;\n  }\n\n  @configurable(false)\n  get x() {\n    return this._x;\n  }\n\n  @configurable(false)\n  get y() {\n    return this._y;\n  }\n}\n")),(0,a.kt)("h3",{id:"property-decorator"},"Property Decorator"),(0,a.kt)("p",null,"A property decorator ",(0,a.kt)("em",{parentName:"p"},"cannot")," be used in a declaration file, nor in any other ambient context (such as in a ",(0,a.kt)("inlineCode",{parentName:"p"},"declare")," class)."),(0,a.kt)("p",null,"The expression for the property decorator will be called as a function at runtime, with the following two arguments:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Either the constructor function of the class for a static member, or the prototype of the class for an instance member."),(0,a.kt)("li",{parentName:"ol"},"The name of the member.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import 'reflect-metadata';\n\nconst formatMetadataKey = Symbol('format');\n\nfunction format(formatString: string) {\n  return Reflect.metadata(formatMetadataKey, formatString);\n}\n\nfunction getFormat(target: any, propertyKey: string) {\n  return Reflect.getMetadata(formatMetadataKey, target, propertyKey);\n}\n\nclass Greeter {\n  @format('Hello, %s')\n  greeting: string;\n\n  constructor(message: string) {\n    this.greeting = message;\n  }\n  greet() {\n    let formatString = getFormat(this, 'greeting');\n    return formatString.replace('%s', this.greeting);\n  }\n}\n")),(0,a.kt)("h3",{id:"parameter-decorators"},"Parameter Decorators"),(0,a.kt)("p",null,"The parameter decorator is applied to the function for a class constructor or method declaration."),(0,a.kt)("p",null,"A parameter decorator ",(0,a.kt)("em",{parentName:"p"},"cannot")," be used in a declaration file, an overload, nor in any other ambient context (such as in a ",(0,a.kt)("inlineCode",{parentName:"p"},"declare")," class)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import 'reflect-metadata';\n\nconst requiredMetadataKey = Symbol('required');\n\nfunction required(\n  target: Object,\n  propertyKey: string | symbol,\n  parameterIndex: number\n) {\n  let existingRequiredParameters: number[] =\n    Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];\n  existingRequiredParameters.push(parameterIndex);\n  Reflect.defineMetadata(\n    requiredMetadataKey,\n    existingRequiredParameters,\n    target,\n    propertyKey\n  );\n}\n\nfunction validate(\n  target: any,\n  propertyName: string,\n  descriptor: TypedPropertyDescriptor<Function>\n) {\n  let method = descriptor.value;\n  descriptor.value = function () {\n    let requiredParameters: number[] = Reflect.getOwnMetadata(\n      requiredMetadataKey,\n      target,\n      propertyName\n    );\n    if (requiredParameters) {\n      for (let parameterIndex of requiredParameters) {\n        if (\n          parameterIndex >= arguments.length ||\n          arguments[parameterIndex] === undefined\n        ) {\n          throw new Error('Missing required argument.');\n        }\n      }\n    }\n\n    return method.apply(this, arguments);\n  };\n}\n\nclass Greeter {\n  greeting: string;\n\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  @validate\n  greet(@required name: string) {\n    return 'Hello ' + name + ', ' + this.greeting;\n  }\n}\n")),(0,a.kt)("h2",{id:"declaration"},"Declaration"),(0,a.kt)("h3",{id:"declaration-merging"},"Declaration Merging"),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"declaration merging")," means that the compiler merges two separate declarations declared with the same name into a single definition. This merged definition has the features of both of the original declarations. Any number of declarations can be merged; it\u2019s not limited to just two declarations."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"interface Box {\n  height: number;\n  width: number;\n}\n\ninterface Box {\n  scale: number;\n}\n\n// -> interface Box {\n//      height: number;\n//      width: number;\n//      scale: number;\n//    }\n\ninterface Cloner {\n  clone(animal: Animal): Animal;\n}\n\ninterface Cloner {\n  clone(animal: Sheep): Sheep;\n}\n\ninterface Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n}\n\n// overload\n// -> interface Cloner {\n//      clone(animal: Dog): Dog;\n//      clone(animal: Cat): Cat;\n//      clone(animal: Sheep): Sheep;\n//      clone(animal: Animal): Animal;\n//    }\n\nnamespace Animals {\n  export class Zebra {}\n}\n\nnamespace Animals {\n  export interface Legged {\n    numberOfLegs: number;\n  }\n  export class Dog {}\n}\n\n// merged namespace\n//    namespace Animals {\n//      export interface Legged {\n//        numberOfLegs: number;\n//      }\n//\n//      export class Zebra {}\n//      export class Dog {}\n//    }\n")),(0,a.kt)("h3",{id:"global-declaration-augmentation"},"Global Declaration Augmentation"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// observable.ts\nexport class Observable<T> {\n  // ... still no implementation ...\n}\n\ndeclare global {\n  interface Array<T> {\n    toObservable(): Observable<T>;\n  }\n}\n\nArray.prototype.toObservable = function () {\n  // ...\n};\n")),(0,a.kt)("h3",{id:"declaration-files-and-reference"},"Declaration Files and Reference"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Objects with Properties")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// Declaration\ndeclare namespace myLib {\n  function makeGreeting(s: string): string;\n  let numberOfGreetings: number;\n}\n\n// Code\nlet result = myLib.makeGreeting('Hello, world');\nconsole.log('The computed greeting is: ' + result);\n\nlet count = myLib.numberOfGreetings;\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Overloaded Functions")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// Declaration\ndeclare function getWidget(n: number): Widget;\ndeclare function getWidget(s: string): Widget[];\n\n// Code\nlet x: Widget = getWidget(42);\nlet arr: Widget[] = getWidget('poper');\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Reusable Types")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// Declaration\ninterface GreetingSettings {\n  greeting: string;\n  duration?: number;\n  color?: string;\n}\n\ndeclare function greet(setting: GreetingSettings): void;\n\n// Code\ngreet({\n  greeting: 'hello world',\n  duration: 4000,\n});\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Reusable Types (Type Aliases)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// Declaration\ntype GreetingLike = string | (() => string) | MyGreeter;\n\ndeclare function greet(g: GreetingLike): void;\n\n// Code\nfunction getGreeting() {\n  return 'howdy';\n}\n\nclass MyGreeter extends Greeter {}\n\ngreet('hello');\ngreet(getGreeting);\ngreet(new MyGreeter());\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Organizing Types")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// Declaration\ndeclare namespace GreetingLib {\n  interface LogOptions {\n    verbose?: boolean;\n  }\n\n  interface AlertOptions {\n    modal: boolean;\n    title?: string;\n    color?: string;\n  }\n}\n\n// Code\nconst g = new Greeter('Hello');\ng.log({ verbose: true });\ng.alert({ modal: false, title: 'Current Greeting' });\n\ndeclare namespace GreetingLib.Options {\n  // Refer to via GreetingLib.Options.Log\n  interface Log {\n    verbose?: boolean;\n  }\n  // Refer to via GreetingLib.Options.Alert\n  interface Alert {\n    modal: boolean;\n    title?: string;\n    color?: string;\n  }\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Classes")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// Declaration\ndeclare class Greeter {\n  constructor(greeting: string);\n\n  greeting: string;\n  showGreeting(): void;\n}\n\n// Code\nconst myGreeter = new Greeter('Hello, 42');\nmyGreeter.greeting = 'howdy';\nmyGreeter.showGreeting();\n\nclass SpecialGreeter extends Greeter {\n  constructor() {\n    super('Very special 42');\n  }\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Global Variables and Functions")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// Declaration\ndeclare var foo: number;\ndeclare function greet(greeting: string): void;\n\n// Code\nconsole.log(`Half the number of foo is ${foo / 2}`);\ngreet('hello, 42');\n")),(0,a.kt)("h2",{id:"tsconfig"},"TSConfig"),(0,a.kt)("p",null,"There are some ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/tsconfig/bases/"},"base ",(0,a.kt)("inlineCode",{parentName:"a"},"tsconfig.json"))," files which the project could extend."),(0,a.kt)("p",null,"See the full list of supported ",(0,a.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/tsconfig"},"Compiler Options"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "extends": "@tsconfig/node12/tsconfig.json",\n  "compilerOptions": {\n    "preserveConstEnums": true\n  },\n  "include": ["src/**/*"],\n  "exclude": ["node_modules", "**/*.spec.ts"]\n}\n')))}u.isMDXComponent=!0}}]);