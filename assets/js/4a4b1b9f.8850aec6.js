"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4148],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var o=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=o.createContext({}),c=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return o.createElement(l.Provider,{value:n},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(t),d=r,h=m["".concat(l,".").concat(d)]||m[d]||u[d]||a;return t?o.createElement(h,i(i({ref:n},p),{},{components:t})):o.createElement(h,i({ref:n},p))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,i=new Array(a);i[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[m]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<a;c++)i[c]=t[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},54326:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var o=t(87462),r=(t(67294),t(3905));const a={title:"Docker Compose",sidebar_position:5},i=void 0,s={unversionedId:"docker/docker-compose",id:"docker/docker-compose",title:"Docker Compose",description:"Modern cloud-native apps are made of multiple smaller services that interact to form a useful app. We call this pattern microservices. A simple example might be an app with the following seven services:",source:"@site/docs/docker/docker-compose.md",sourceDirName:"docker",slug:"/docker/docker-compose",permalink:"/docs/docker/docker-compose",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Docker Compose",sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Docker Networking",permalink:"/docs/docker/networking"},next:{title:"Health checks",permalink:"/docs/docker/health-checks"}},l={},c=[{value:"Docker Compose",id:"docker-compose",level:2},{value:"Howe Docker plugs containers together",id:"howe-docker-plugs-containers-together",level:3},{value:"Understanding the problem Docker Compose solves",id:"understanding-the-problem-docker-compose-solves",level:3},{value:"Docker Compose in Multiple Environments",id:"docker-compose-in-multiple-environments",level:2},{value:"Using Docker Compose override files",id:"using-docker-compose-override-files",level:3},{value:"Injecting configuration with environment variables and secrets",id:"injecting-configuration-with-environment-variables-and-secrets",level:3},{value:"The configuration workflow with Docker",id:"the-configuration-workflow-with-docker",level:3},{value:"References",id:"references",level:3}],p={toc:c};function m(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,o.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Modern cloud-native apps are made of multiple smaller services that interact to form a useful app. We call this pattern ",(0,r.kt)("em",{parentName:"p"},"microservices"),". A simple example might be an app with the following seven services:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Web front-end"),(0,r.kt)("li",{parentName:"ul"},"Ordering"),(0,r.kt)("li",{parentName:"ul"},"Catalog"),(0,r.kt)("li",{parentName:"ul"},"Back-end database"),(0,r.kt)("li",{parentName:"ul"},"Logging"),(0,r.kt)("li",{parentName:"ul"},"Authentication"),(0,r.kt)("li",{parentName:"ul"},"Authorization")),(0,r.kt)("p",null,"Get all of these working together, and you have a useful application."),(0,r.kt)("h2",{id:"docker-compose"},"Docker Compose"),(0,r.kt)("p",null,"Each component runs in its own lightweight container, and Docker plugs them together using standard network protocols."),(0,r.kt)("p",null,"Compose is a file format for describing distributed Docker apps, and it's a tool for managing them."),(0,r.kt)("p",null,"Dockerfile is a script for packaging only an application."),(0,r.kt)("p",null,"The Docker Compose file describes the desired state of your app -- what it should look like when everything\u2019s running."),(0,r.kt)("p",null,"It\u2019s a simple file format where you place all the options you would put in your ",(0,r.kt)("inlineCode",{parentName:"p"},"docker container run")," commands into the Compose file. Then you use the Docker Compose tool to run the app. It works out what Docker resources it needs, which could be containers, networks, or volumes -- and it sends requests to the Docker API to create them."),(0,r.kt)("p",null,"Docker Compose uses YAML."),(0,r.kt)("p",null,"Docker Compose is a client-side tool. It\u2019s a command line that sends instructions to the Docker API based on the contents of the Compose file. Docker itself just runs containers; it isn't aware that how many containers to represent a single application. Only Compose knows that, and Compose only knows the structure of your application by looking at the Docker Compose YAML file, so you need to have that file always available to manage your app."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"docker-compose up\ndocker-compose down\n\ndocker-compose start\ndocker-compose stop\n\ndocker-compose rm\n\ndocker-compose restart\n\ndocker-compose ps\ndocker-compose top\n")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"An example docker compose file for running single container"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"version")," is the version of the Docker Compose format used in this file. The feature set has evolved over many releases, so the version here identifies which releases this definition works with.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"services")," lists all the components that make up the application. Docker Compose uses the idea of services instead of actual containers, because a service could be run at scale with several containers from the same image.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"networks")," lists all the Docker networks that the service containers can plug into. By default, Compose will create bridge networks. These are single-host networks that can only connect containers on the same Docker host. However, you can use the driver property to specify different network types.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"volumes")," tells Docker to create new volumes."))),(0,r.kt)("p",null,"The volumes won't be deleted after the ",(0,r.kt)("inlineCode",{parentName:"p"},"docker-compose down"),". Volumes are intended to be long-term persistent data stores. As such, their lifecycle is entirely decoupled from the applications they serve. Running a docker volume ls will show that the volume is still present on the system. If you\u2019d written any data to the volume, that data would still exist."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"version: '3.7'\n\nservices:\n  # equivalent docker command \u2b07\ufe0f\n  # docker container run- p 8020:80 --name todo-web --network nat todo-list\n  todo-web: # a service calle `todo-web`\n    image: todo-list # run container from image `todo-list`\n    ports:\n      - '8020:80' # publish host port to container port\n    networks:\n      - app-net # plug into the `app-net` network inside the compose file\n\nnetworks:\n  app-net:\n    external:\n      name: nat\n")),(0,r.kt)("p",null,"The service name becomes the container name and the DNS name of the container, which other containers can use to connect on the Docker network. The network name in the service is ",(0,r.kt)("inlineCode",{parentName:"p"},"app-net"),", but under the networks section that network is specified as mapping to an external network called ",(0,r.kt)("inlineCode",{parentName:"p"},"nat"),". The external option means Compose expects the nat network to already exist, and it won't try to create it."),(0,r.kt)("p",null,"To start compose"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"docker network create nat\n\ncd path/to/directory/with/docker-compose.yaml\n\ndocker-compose up\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"An example to run multi-container application with compose"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"version: '3.7'\n\nservices:\n  accesslog:\n    image: access-log\n    networks:\n      - app-net\n\n  api:\n    build: . # build a new image using Dockerfile in the current directory (.)\n    command: node server.js # run this command as the main process, override CMD in Dockerfile\n    restart: unless-stopped\n    environment:\n      - VERSION=1.1.2\n    volumes:\n      # bind mount directory\n      - type: bind\n        source: /data/assets\n        target: /app/assets\n    ports:\n      - '80' # publish port 80 on the container to a random port on the host\n    networks:\n      - app-net\n\n  server:\n    image: front-server\n    restart: on-failure\n    ports:\n      # publish port: 8010 on the host to port 80 on the container\n      - target: 80\n        published: 8010\n    depends_on: # dependency on the other services\n      - accesslog\n      - api\n    volumes:\n      - type: volume\n        source: assets\n        target: /container/directory\n    networks:\n      - app-net\n\nnetworks:\n  app-net:\n    external:\n      name: nat\n  over-net:\n    driver: overlay\n    attachable: true\n\nvolumes:\n  assets:\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"docker-compose up --detach\n\n# some time elapse\n# scale the api service to a scale of 3\ndocker-compose up -d --scale api=3\n"))),(0,r.kt)("h3",{id:"howe-docker-plugs-containers-together"},"Howe Docker plugs containers together"),(0,r.kt)("p",null,"All the components in a distributed application run in Docker containers with Compose, but how do they communicate with each other?"),(0,r.kt)("p",null,"A container is a virtualized environment with its own network space. Each container has a virtual IP address assigned by Docker, and containers plugged into the same Docker network can reach each other using their IP addresses. But containers get replaced during the application life cycle, and new containers will have new IP addresses, so Docker also supports service discovery with DNS."),(0,r.kt)("p",null,"Docker has its own DNS service built in. Apps running in containers make domain lookups when they try to access other components. The DNS service in Docker performs that lookup -- if the domain name is actually a container name, Docker returns the container\u2019s IP address, and the consumer can work directly across the Docker network. If the domain name isn't a container, Docker passes the request on to the host where Docker is running, so it will make a standard DNS lookup to find an IP address on host\u2019s network or the public internet."),(0,r.kt)("p",null,"Containers plugged into the same Docker network will get IP addresses in the same network range, and they connect over that network. Using DNS means that when your containers get replaced and the IP address changes, your app still works because the DNS service in Docker will always return the current container\u2019s IP address from the domain lookup."),(0,r.kt)("p",null,"DNS servers can return multiple IP address for a domain name. Docker Compose uses this mechanism for simple load-balancing, returning all the container IP addresses for a service. To try to provide load-balancing across all the containers, the Docker DNS returns the list in a different order each time."),(0,r.kt)("p",null,"Plugging app configuration into the Compose file lets you use the same Docker images in different ways and be explicit about the settings for each environment. You can have separate Compose files for your development and test environments, publishing different ports and triggering different features of the app."),(0,r.kt)("h3",{id:"understanding-the-problem-docker-compose-solves"},"Understanding the problem Docker Compose solves"),(0,r.kt)("p",null,"Docker Compose is a very neat way of describing the setup for complex distributed apps in a small, clear file format."),(0,r.kt)("p",null,"Compose lets you define your application and apply the definition to a single machine running Docker. It compares the live Docker resources on that machine with the resources described in the Compose file, and it will send requests to the Docker API to replace resources that have been updated and create new resources where they are needed."),(0,r.kt)("p",null,"It is not a full container platform like Docker Swarm or Kubernetes\u2014it does not continually run to make sure your application keeps its desired state. If containers fail or if you remove them manually, Docker Compose will not restart or replace them until you explicitly run docker-compose up again."),(0,r.kt)("h2",{id:"docker-compose-in-multiple-environments"},"Docker Compose in Multiple Environments"),(0,r.kt)("p",null,"Docker Compose is a tool for running multi-container applications on a single Docker Engine."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Under the same project (environment), Docker Compose won't start any new instance of the application if it thinks you\u2019re asking it to run an application that is already running.")),(0,r.kt)("p",null,"Docker Compose uses the concept of a ",(0,r.kt)("em",{parentName:"p"},"project")," to identify that various resources are part of the same application, and it uses the name of the directory that contains the Compose file as the default project name."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"-p")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"--project-name")," to specify different project.")),(0,r.kt)("p",null,"Compose prefixes the project name when it creates resources, and for containers it also adds a numeric counter as a suffix."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"So if your compose file is in a folder called ",(0,r.kt)("inlineCode",{parentName:"p"},"app1"),", and it defines one service called ",(0,r.kt)("inlineCode",{parentName:"p"},"web")," and one volume called ",(0,r.kt)("inlineCode",{parentName:"p"},"disk"),", Compose will deploy it by creating a volume called ",(0,r.kt)("inlineCode",{parentName:"p"},"app1_disk")," and a container called ",(0,r.kt)("inlineCode",{parentName:"p"},"app1_web_1"),". The counter at the end of the container name supports scale, so if you scale that up to two instances of the web service, the new container will be called ",(0,r.kt)("inlineCode",{parentName:"p"},"app1_web_2"),".")),(0,r.kt)("h3",{id:"using-docker-compose-override-files"},"Using Docker Compose override files"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://docs.docker.com/compose/reference/overview/#use--f-to-specify-name-and-path-of-one-or-more-compose-files"},"official reference")),(0,r.kt)("p",null,"Teams hit the problem of trying to run different app configurations with Docker Compose and often end up with many Compose files -- one for each environment."),(0,r.kt)("p",null,"However, Docker Compose lets you merge multiple files together, with properties from later files overriding those from earlier in the merge."),(0,r.kt)("p",null,"Docker Compose merges files together when you specify multiple file paths in docker-compose commands. The config command is very useful here\u2014it validates the contents of the input files, and if the input is valid, it writes out the final output. You can use that to see what will happen when you apply an override file."),(0,r.kt)("p",null,"If you up the application with multiple compose files, you need to use all the same options when you tear down it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# start the application\ndocker-compose -f ./docker-compose.yml -f ./docker-compose-dev.yml -p dev up\n\n# tear down\ndocker-compose -f ./docker-compose.yml -f ./docker-compose-dev.yml -p dev down\n")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"An example to illustrate how to use overrides to structure an easily maintainable set of Compose files."),(0,r.kt)("p",null,"In the override file you just specify the properties you care about, but you need to preserve the structure of the main Compose file so that Docker Compose can link the definitions together."),(0,r.kt)("p",null,"The other override files follow the same pattern. Each environment uses different ports for the web application and the API so you can run them all on a single machine."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# validate and inspect the compose.yml files\ndocker-compose -f ./docker-compose.yml -f ./docker-compose-dev.yml config\ndocker-compose -f ./docker-compose.yml -f ./docker-compose-test.yml config\ndocker-compose -f ./docker-compose.yml -f ./docker-compose-uat.yml config\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"# docker-compose.yml\n# Only services and basic settings\nversion: '3.7'\n\nservices:\n  api:\n    image: api:v3\n    networks:\n      - app-net\n\n  web:\n    image: web:v3\n    environment:\n      - ServerApi__Url=http://api/api\n    networks:\n      - app-net\n\nnetworks:\n  app-net:\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"# docker-compose-dev.yml\n# Settings (services/network) for development\nversion: '3.7'\n\nservices:\n  api:\n    ports:\n      - '8087:80'\n    healthcheck:\n      disable: true\n\n  web:\n    entrypoint:\n      - node\n      - static-web.js\n    ports:\n      - '8088:80'\n\nnetworks:\n  app-net:\n    name: dev\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"# docker-compose-test.yml\n# Settings (services/network) for test\nversion: '3.7'\n\nservices:\n  api:\n    image: api:v3-fix # using different version\n    healthcheck:\n      interval: 20s\n      start_period: 15s\n      retries: 4\n\n  web:\n    ports:\n      - '8080:80'\n    restart: on-failure\n    healthcheck:\n      test: ['CMD', 'node', 'health-check.js']\n      interval: 20s\n      timeout: 10s\n      retries: 4\n      start_period: 10s\n\nnetworks:\n  app-net:\n    name: test\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"# docker-compose-uat.yml\n# Settings for User-Acceptance-Test environment\nversion: '3.7'\n\nservices:\n  api:\n    healthcheck:\n      interval: 10s\n      retries: 2\n    restart: always\n    ports:\n      - '8090:80'\n\n  web:\n    restart: always\n    ports:\n      - '80:80'\n    healthcheck:\n      interval: 10s\n      retries: 2\n\nnetworks:\n  app-net:\n    name: uat\n"))),(0,r.kt)("h3",{id:"injecting-configuration-with-environment-variables-and-secrets"},"Injecting configuration with environment variables and secrets"),(0,r.kt)("p",null,"Most applications can read configuration settings from environment variables or files, and Compose has good support for both those approaches."),(0,r.kt)("p",null,"This secret is specified as coming from the source ",(0,r.kt)("inlineCode",{parentName:"p"},"db-connection"),", which means there needs to be a secret with that name defined in the Compose file."),(0,r.kt)("p",null,"Secrets are a useful way of injecting configuration -- they have support in Docker Compose, Docker Swarm, and Kubernetes."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"version: '3.7'\n\nservices:\n  web:\n    image: web:v1\n    ports:\n      - '${HOST_WEB_PORT:-8090}:80' # using environment variable, default would be 8090\n    environment:\n      - Database:Provider=Sqlite\n    env_file:\n      # path to a text dotenv file\n      - ./config/logging.debug.env\n\n    secrets:\n      # The source is the place where the secret\n      #   is loaded from the container runtime\n      # The target is the file path where the secret\n      #   is surfaced inside the container\n      - source: db-connection\n        target: /app/config/secrets.json\n\n  api:\n    # if the environment variable not exist, using v1 instead\n    image: api:${BUILD_VERSION:-v1}\n    secrets:\n      - source: redis-connection\n        target: /app/config/ # copy all the directory files\n\nsecrets:\n  db-connection:\n    file: ./config/secrets.json\n  redis-connection:\n    file: ./config/dev # directory with multiple config.json\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# .env file\nHOST_WEB_PORT=8877\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Keeping an environment file alongside your Compose files helps to document which sets of files represent which environment, but be aware that Docker Compose only looks for a file called ",(0,r.kt)("inlineCode",{parentName:"p"},".env"),". You can't specify a filename, so you can't easily switch between environments with multiple environment files.")),(0,r.kt)("p",null,"Useful tips:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Using the ",(0,r.kt)("inlineCode",{parentName:"p"},"environment")," property to specify environment variables is the simplest option, and it makes your application configuration easy to read from the Compose file. Those settings are in plain text, though, so you shouldn't use them for sensitive data like connection strings or API keys.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Loading configuration files with ",(0,r.kt)("inlineCode",{parentName:"p"},"secret")," properties is the most flexible option, because it\u2019s supported by all the container runtime and it can be used for sensitive data. The source of the secret could be ",(0,r.kt)("em",{parentName:"p"},"a local file when you\u2019re using Compose"),", or it could be an encrypted secret stored in a Docker Swarm or Kubernetes cluster. Whatever the source, the contents of the secret get loaded into a file in the container for the application to read.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Storing settings in a file and loading them into containers with the ",(0,r.kt)("inlineCode",{parentName:"p"},"environment_file")," property is useful when you have lots of shared settings between services. Compose reads the file locally and sets the individual values as environment properties, so you can use local environment files when you\u2019re connected to a remote Docker Engine.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The Compose environment file, ",(0,r.kt)("inlineCode",{parentName:"p"},".env"),", is useful for capturing the setup for whichever environment you want to be the default deployment target."))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("p",null,"Reducing duplication with extension fields")),(0,r.kt)("p",null,"Using extension fields to define blocks of YAML in a single place, which you can reuse throughout the Compose file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"x-labels: &logging\n  logging:\n    options:\n      max-size: '100m'\n      max-file: '10'\n\nx-labels: &labels\n  app-name: image-web\n\n# used in compose file\nversion: \"3.7\"\n\nx-labels: &logging\n  logging:\n    options:\n      max-size: '100m'\n      max-file: '10'\n\nx-labels: &labels\n  app-name: image-web\n\nservices:\n  accesslog:\n    <<: *logging\n    labels:\n      <<: *labels\n\n  prometheus:\n    image: prometheus\n    ports:\n      - \"9090:9090\"\n    environment:\n      - DOCKER_HOST=${HOST_IP}\n    networks:\n      - app-net\n    <<: *logging\n    labels:\n      <<: *labels\n\n  grafana:\n    image: grafana\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - prometheus\n    networks:\n      - app-net\n    <<: *logging\n    labels:\n      <<: *labels\n"))),(0,r.kt)("h3",{id:"the-configuration-workflow-with-docker"},"The configuration workflow with Docker"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Application composition")," :Not every environment will run the whole stack. Override files makes this work neatly, sharing common services and adding specific ones in each environment.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Container configuration"),": Properties need to change to match the requirements and capabilities of the environment. Overrides enable this, along with isolated Docker networks for each application, allowing you to run multiple environments on a single server.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Application configuration"),": The behavior of applications inside containers will change between environments. You can do this using Compose with any combination of override files, environment files, and secrets."))),(0,r.kt)("p",null,"The most important takeaway from this is that the configuration workflow uses the same Docker image in every environment."),(0,r.kt)("h3",{id:"references"},"References"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://docs.docker.com/compose/reference/overview/"},"Guidance on docker-compose CLI")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://docs.docker.com/compose/compose-file/"},"Reference and guidelines for docker compose file")))}m.isMDXComponent=!0}}]);