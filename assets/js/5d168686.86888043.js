"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5807],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>k});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),l=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):p(p({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=l(n),m=r,k=u["".concat(s,".").concat(m)]||u[m]||c[m]||i;return n?a.createElement(k,p(p({ref:t},d),{},{components:n})):a.createElement(k,p({ref:t},d))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,p=new Array(i);p[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[u]="string"==typeof e?e:r,p[1]=o;for(var l=2;l<i;l++)p[l]=n[l];return a.createElement.apply(null,p)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},82425:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>p,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var a=n(87462),r=(n(67294),n(3905));const i={title:"The AST",sidebar_position:4,tags:["interpreter"]},p=void 0,o={unversionedId:"interpreter-in-js/parser",id:"interpreter-in-js/parser",title:"The AST",description:"As mentioned, the parser will build a structure which faithfully represents the semantics of the program. An AST node is a plain JavaScript object that has a type property specifying what kind of node it is, and additional information, depending on the particular type.",source:"@site/docs/interpreter-in-js/parser.md",sourceDirName:"interpreter-in-js",slug:"/interpreter-in-js/parser",permalink:"/docs/interpreter-in-js/parser",draft:!1,tags:[{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",sidebarPosition:4,frontMatter:{title:"The AST",sidebar_position:4,tags:["interpreter"]},sidebar:"tutorialSidebar",previous:{title:"The token input stream",permalink:"/docs/interpreter-in-js/token-input-stream"},next:{title:"The Interpreter",permalink:"/docs/interpreter-in-js/interpreter"}},s={},l=[{value:"The parser",id:"the-parser",level:2}],d={toc:l};function u(e){let{components:t,...i}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"As mentioned, the parser will build a structure which faithfully represents the semantics of the program. An AST node is a plain JavaScript object that has a ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," property specifying what kind of node it is, and additional information, depending on the particular ",(0,r.kt)("inlineCode",{parentName:"p"},"type"),"."),(0,r.kt)("p",null,"In short:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"center"}),(0,r.kt)("th",{parentName:"tr",align:"left"}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"num"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},'{ type: "num", value: NUMBER }'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"str"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},'{ type: "str", value: STRING }'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"bool"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},'{ type: "bool", value: true or false }'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"var"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},'{ type: "var", value: NAME }'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"lambda"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},'{ type: "lambda", vars: [ NAME... ], body: AST }'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"call"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},'{ type: "call", func: AST, args: [ AST... ] }'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"if"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},'{ type: "if", cond: AST, then: AST, else: AST }'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"assign"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},'{ type: "assign", operator: "=", left: AST, right: AST }'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"binary"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},'{ type: "binary", operator: OPERATOR, left: AST, right: AST }'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"prog"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},'{ type: "prog", prog: [ AST... ] }'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"let"),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},'{ type: "let", vars: [ VARS... ], body: AST }'))))),(0,r.kt)("p",null,"Examples:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},'Functions ("lambda")')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'lambda (x) 10   ->  {\n   # or                 type: "lambda",\n\u03bb (x) 10                vars: [ "x" ],\n                        body: { type: "num", value: 10 }\n                    }\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},'Function calls ("call")')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'foo(a, 1)  ->   {\n                    "type": "call",\n                    "func": { "type": "var", "value": "foo" },\n                    "args": [\n                        { "type": "var", "value": "a" },\n                        { "type": "num", "value": 1 }\n                    ]\n                }\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},'Conditionals ("if")')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'if foo then bar else baz  ->   {\n                                    "type": "if",\n                                    "cond": { "type": "var", "value": "foo" },\n                                    "then": { "type": "var", "value": "bar" },\n                                    "else": { "type": "var", "value": "baz" }\n                                }\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},'Assignment ("assign)')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'a = 10  ->  {\n                "type": "assign",\n                "operator": "=",\n                "left": { "type": "var", "value" : "a" },\n                "right": { "type": "num", "value": 10 }\n            }\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},'Binary expression ("binary")')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'x + y * z  ->   {\n                    "type": "binary",\n                    "operator": "+",\n                    "left": { "type" : "var", "value": "x" },\n                    "right": {\n                        "type": "binary",\n                        "operator": "*",\n                        "left": { "type": "var", "value": "y" },\n                        "right": { "type": "var", "value": "z" }\n                    }\n                }\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},'Sequences ("prog")')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'{                   {\n  a = 5;                "type": "prog",\n  b = a * 2;    ->      "prog": [\n  a + b;                     {\n}                               "type": "assign",\n                                "operator": "=",\n                                "left": { "type": "var", "value": "a" },\n                                "right": { "type": "num", "value": 5 }\n                            },\n                            {\n                                "type": "assign",\n                                "operator": "=",\n                                "left": { "type": "var", "value": "b" },\n                                "right": {\n                                    "type": "binary",\n                                    "operator": "*",\n                                    "left": { "type": "var", "value": "a" },\n                                    "right": { "type": "num", "value": 2 }\n                                }\n                            },\n                            {\n                                "type": "binary",\n                                "operator": "+",\n                                "left": { "type": "var", "value": "a" },\n                                "right": { "type": "var", "value": "b" }\n                            }\n                        ]\n                    }\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},'Block scoped variables ("let")')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'let (a = 10, b = a * 10) {      {\n  a + b;                     ->     "type": "let",\n}                                   "vars": [\n                                        {\n                                            "name": "a",\n                                            "def": { "type": "num", "value": 10 }\n                                        },\n                                        {\n                                            "name": "b",\n                                            "def": {\n                                                "type": "binary",\n                                                "operator": "*",\n                                                "left": { "type": "var", "value": "a" },\n                                                "right": { "type": "num", "value": 10 }\n                                            }\n                                        }\n                                    ],\n                                    "body": {\n                                        "type": "binary",\n                                        "operator": "+",\n                                        "left": { "type": "var", "value": "a" },\n                                        "right": { "type": "var", "value": "b" }\n                                    }\n                                }\n')),(0,r.kt)("h2",{id:"the-parser"},"The parser"),(0,r.kt)("p",null,"The parser creates AST nodes."),(0,r.kt)("p",null,"Thanks to the work we did in the tokenizer, the parser operates on a stream of tokens instead of dealing with individual characters. It still defines many helpers to keep complexity down."),(0,r.kt)("p",null,"I'll discuss here the main functions that comprise the parser. Let's start with a high level one, the ",(0,r.kt)("inlineCode",{parentName:"p"},"lambda")," parser:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function parse_lambda() {\n  return {\n    type: 'lambda',\n    vars: delimited('(', ')', ',', parse_varname),\n    body: parse_expression(),\n  };\n}\n")),(0,r.kt)("p",null,"This function will be invoked when the ",(0,r.kt)("inlineCode",{parentName:"p"},"lambda"),' keywords has already been seen and "eaten" from the input, so all it cares for is to parse the argument names; but they\'re in parentheses and delimited by commas. Rather than placing that code in ',(0,r.kt)("inlineCode",{parentName:"p"},"parse_lambda"),", it is better to write a ",(0,r.kt)("inlineCode",{parentName:"p"},"delimited")," function that takes these arguments: the ",(0,r.kt)("inlineCode",{parentName:"p"},"start")," token, the ",(0,r.kt)("inlineCode",{parentName:"p"},"end")," token, the ",(0,r.kt)("inlineCode",{parentName:"p"},"separator"),", and a ",(0,r.kt)("em",{parentName:"p"},"function")," which parses whatever must be between those ",(0,r.kt)("em",{parentName:"p"},"start/end")," tokens. In this case, it's ",(0,r.kt)("inlineCode",{parentName:"p"},"parse_varname"),", which takes care to throw an error if it encounters anything which doesn't look like a variable. The body of the function is an expression, so we get it with ",(0,r.kt)("inlineCode",{parentName:"p"},"parse_expression"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"delimited")," is a bit lower-level:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function delimited(start, stop, separator, parser) {\n  var a = [],\n    first = true;\n  skip_punc(start);\n  while (!input.eof()) {\n    if (is_punc(stop)) break;\n    if (first) {\n      first = false;\n    } else {\n      skip_punc(separator);\n    }\n    if (is_punc(stop)) break;\n\n    a.push(parser());\n  }\n  skip_punc(stop);\n  return a;\n}\n")),(0,r.kt)("p",null,"As it can be seen, it uses more utilities: ",(0,r.kt)("inlineCode",{parentName:"p"},"is_punc")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"skip_punc"),'. The former will return true if the current token is the given punctuation sign (without "eating" it), while ',(0,r.kt)("inlineCode",{parentName:"p"},"skip_punc")," will ensure that the current token is that punctuation (throws an error otherwise) and will discard it from the input."),(0,r.kt)("p",null,"The function that parses the whole program is probably the simplest:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function parse_toplevel() {\n  var prog = [];\n  while (!input.eof()) {\n    prog.push(parse_expression());\n    if (!input.eof()) skip_punc(';');\n  }\n  return { type: 'prog', prog: prog };\n}\n")),(0,r.kt)("p",null,"Since we have no statements, we simply call ",(0,r.kt)("inlineCode",{parentName:"p"},"parse_expression()")," and read expressions until we get to the end of the input. Using ",(0,r.kt)("inlineCode",{parentName:"p"},'skip_punc(";")')," we demand semicolons between these expressions."),(0,r.kt)("p",null,"Another simple example ",(0,r.kt)("inlineCode",{parentName:"p"},"parse_if()"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function parse_if() {\n  skip_kw('if');\n  var cond = parse_expression(); // condition exp not in parenthese\n  if (!is_punc('{')) skip_kw('then');\n  var then = parse_expression();\n  var ret = { type: 'if', cond: cond, then: then };\n  if (is_kw('else')) {\n    input.next();\n    ret.else = parse_expression();\n  }\n  return ret;\n}\n")),(0,r.kt)("p",null,"It skips over the ",(0,r.kt)("inlineCode",{parentName:"p"},"if")," keyword with ",(0,r.kt)("inlineCode",{parentName:"p"},"skip_kw"),"(and this throws an error if the current token is not the given keyword), reads the condition using ",(0,r.kt)("inlineCode",{parentName:"p"},"parse_expression()"),". Next, if the consequent branch doesn't start with a ",(0,r.kt)("inlineCode",{parentName:"p"},"{")," we require the keyword ",(0,r.kt)("inlineCode",{parentName:"p"},"then")," to be present (I feel like the syntax is too scarce without it). The branches are just expressions, so again we use ",(0,r.kt)("inlineCode",{parentName:"p"},"parse_expression()")," for them. The ",(0,r.kt)("inlineCode",{parentName:"p"},"else")," branch is optional, so we need to check if the keyword is present before parsing it."),(0,r.kt)("p",null,'Having many small utilities helps a lot in keeping the code simple. We almost write the parser like we had a high level language dedicated for parsing. All these functions are "mutually recursive", e.g.: there\'s a ',(0,r.kt)("inlineCode",{parentName:"p"},"parse_atom()")," function which is the main dispatcher \u2014 based on the current token it calls other functions. One of them is ",(0,r.kt)("inlineCode",{parentName:"p"},"parse_if()")," (called when the current token is ",(0,r.kt)("inlineCode",{parentName:"p"},"if"),") and that in turn calls ",(0,r.kt)("inlineCode",{parentName:"p"},"parse_expression()"),". But ",(0,r.kt)("inlineCode",{parentName:"p"},"parse_expression()")," calls ",(0,r.kt)("inlineCode",{parentName:"p"},"parse_atom()"),". The reason why there's no infinite loop is that at each step, one function or another will advance at least one token."),(0,r.kt)("p",null,"This kind of parser is called a ",(0,r.kt)("strong",{parentName:"p"},"recursive descent parser"),", and it's probably the easiest kind to write manually."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"parse_atom()")," does the main dispatching job, depending on the current token:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function parse_atom() {\n  return maybe_call(function () {\n    if (is_punc('(')) {\n      input.next();\n      var exp = parse_expression();\n      skip_punc(')');\n      return exp;\n    }\n    if (is_punc('{')) return parse_prog();\n    if (is_kw('if')) return parse_if();\n    if (is_kw('true') || is_kw('false')) return parse_bool();\n    if (is_kw('lambda') || is_kw('\u03bb')) {\n      input.next();\n      return parse_lambda();\n    }\n    var tok = input.next();\n    if (tok.type == 'var' || tok.type == 'number' || tok.type == 'str') {\n      return tok;\n    }\n    unexpected();\n  });\n}\n")),(0,r.kt)("p",null,"If it sees an open paren, then it must be a parenthesized expression \u2014 thus, skip over paren, call ",(0,r.kt)("inlineCode",{parentName:"p"},"parse_expression()")," and expect a closing paren. If it sees some keyword, it calls the appropriate parser function. If it sees a constant or an identifier, it's just returned as is. If nothing works, ",(0,r.kt)("inlineCode",{parentName:"p"},"unexpected()")," will throw an error."),(0,r.kt)("p",null,"When an atomic expression is expected and it sees ",(0,r.kt)("inlineCode",{parentName:"p"},"{"),", it calls ",(0,r.kt)("inlineCode",{parentName:"p"},"parse_prog()")," to parse a sequence of expressions. That's defined below. It will do some minor optimization at this point \u2014 if the prog is empty, then it just returns ",(0,r.kt)("inlineCode",{parentName:"p"},"FALSE"),". If it has a single expression, it is returned instead of a ",(0,r.kt)("inlineCode",{parentName:"p"},"prog")," node. Otherwise, it returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"prog")," node containing the expressions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"var FALSE = { type: 'bool', value: false };\n\nfunction parse_prog() {\n  var prog = delimited('{', '}', ';', parse_expression);\n  if (prog.length == 0) return FALSE;\n  if (prog.length == 1) return prog[0];\n  return { type: 'prog', prog: prog };\n}\n")),(0,r.kt)("p",null,"Here's the ",(0,r.kt)("inlineCode",{parentName:"p"},"parse_expression()")," function. Contrary to ",(0,r.kt)("inlineCode",{parentName:"p"},"parse_atom()"),", this one will extend an expression as much as possible to the right using ",(0,r.kt)("inlineCode",{parentName:"p"},"maybe_binary()"),", which is explained below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function parse_expression() {\n  return maybe_call(function () {\n    return maybe_binary(parse_atom(), 0);\n  });\n}\n")),(0,r.kt)("p",null,"What are these ",(0,r.kt)("inlineCode",{parentName:"p"},"maybe_*")," functions?"),(0,r.kt)("p",null,"These functions check what follows ",(0,r.kt)("em",{parentName:"p"},"after")," an expression in order to decide whether to wrap that expression in another node, or just return it as is."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"maybe_call()")," is very simple. It receives a function that is expected to parse the current expression. If after that expression it sees a ",(0,r.kt)("inlineCode",{parentName:"p"},"(")," punctuation token, then it must be a ",(0,r.kt)("inlineCode",{parentName:"p"},"call")," node, which is what ",(0,r.kt)("inlineCode",{parentName:"p"},"parse_call()")," makes. Notice again how ",(0,r.kt)("inlineCode",{parentName:"p"},"delimited()")," comes in handy for reading the argument list."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function maybe_call(expr) {\n  expr = expr();\n  return is_punc('(') ? parse_call(expr) : expr;\n}\n\nfunction parse_call(func) {\n  return {\n    type: 'call',\n    func: func,\n    args: delimited('(', ')', ',', parse_expression),\n  };\n}\n")),(0,r.kt)("p",null,"How about ",(0,r.kt)("strong",{parentName:"p"},"Operator precedence"),"?"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"maybe_binary(left, my_prec)")," is used to compose binary expression like ",(0,r.kt)("inlineCode",{parentName:"p"},"1 + 2 * 3"),". The trick to parse them properly is to correctly define the operator precedence like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"var PRECEDENCE = {\n  '=': 1,\n  '||': 2,\n  '&&': 3,\n  '<': 7,\n  '>': 7,\n  '<=': 7,\n  '>=': 7,\n  '==': 7,\n  '!=': 7,\n  '+': 10,\n  '-': 10,\n  '*': 20,\n  '/': 20,\n  '%': 20,\n};\n")),(0,r.kt)("p",null,"This says that ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," binds tighter than ",(0,r.kt)("inlineCode",{parentName:"p"},"+"),", so an expression like ",(0,r.kt)("inlineCode",{parentName:"p"},"1 + 2 * 3")," must be read as ",(0,r.kt)("inlineCode",{parentName:"p"},"(1 + (2 * 3))")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"((1 + 2) * 3)"),", which would be the normal left-to-right order in which the parser operates."),(0,r.kt)("p",null,"The trick is to read an atomic expression (only the ",(0,r.kt)("inlineCode",{parentName:"p"},"1"),") and pass it to ",(0,r.kt)("inlineCode",{parentName:"p"},"maybe_binary()")," (the left argument), along with the current precedence (the ",(0,r.kt)("inlineCode",{parentName:"p"},"my_prec"),"). ",(0,r.kt)("inlineCode",{parentName:"p"},"maybe_binary")," will look at what follows. If it doesn't see an operator, or if it has a smaller priority, then left is returned as is."),(0,r.kt)("p",null,"If it's an operator that has a higher precedence than ours, then it wraps left in a new ",(0,r.kt)("inlineCode",{parentName:"p"},'"binary"')," node, and for the right side it repeats the trick at the new precedence level ",(0,r.kt)("inlineCode",{parentName:"p"},"(*)"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function maybe_binary(left, my_prec) {\n  var tok = is_op();\n  if (tok) {\n    var his_prec = PRECEDENCE[tok.value];\n    if (his_prec > my_prec) {\n      input.next();\n      var right = maybe_binary(parse_atom(), his_prec);\n      var binary = {\n        type: tok.value == '=' ? 'assign' : 'binary',\n        operator: tok.value,\n        left: left,\n        right: right,\n      };\n      return maybe_binary(binary, my_prec);\n    }\n  }\n  return left;\n}\n")),(0,r.kt)("p",null,"Note that before returning the binary expression we must also call ",(0,r.kt)("inlineCode",{parentName:"p"},"maybe_binary")," at the old precedence level (my_prec), in order to wrap the expression in another one, should an operator with a higher precedence follow. If all this is confusing, read the code again and again (perhaps try to execute it mentally on some input expressions) until you get it."),(0,r.kt)("p",null,"Finally, since ",(0,r.kt)("inlineCode",{parentName:"p"},"my_prec")," is initially zero, any operator will trigger the building of a ",(0,r.kt)("inlineCode",{parentName:"p"},'"binary"')," node (or ",(0,r.kt)("inlineCode",{parentName:"p"},'"assign"')," when the operator is ",(0,r.kt)("inlineCode",{parentName:"p"},"="),")."),(0,r.kt)("p",null,"The whole ",(0,r.kt)("a",{target:"_blank",href:n(33293).Z},"parse function"),"."),(0,r.kt)("p",null,"Next, we move on to the interpreter."))}u.isMDXComponent=!0},33293:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/parser-a9fb0fd8f3165fdf7e84d68d94cf74e4.js"}}]);