"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4955],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var o=a.createContext({}),p=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(o.Provider,{value:n},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(t),m=r,h=d["".concat(o,".").concat(m)]||d[m]||c[m]||l;return t?a.createElement(h,i(i({ref:n},u),{},{components:t})):a.createElement(h,i({ref:n},u))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,i=new Array(l);i[0]=m;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<l;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},98111:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>d,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var a=t(87462),r=(t(67294),t(3905));const l={title:"08 Q-Expressions",tags:["lisp","interpreter"]},i=void 0,s={unversionedId:"lisp-interpreter-in-c/q-expressions",id:"lisp-interpreter-in-c/q-expressions",title:"08 Q-Expressions",description:"document",source:"@site/docs/lisp-interpreter-in-c/08-q-expressions.md",sourceDirName:"lisp-interpreter-in-c",slug:"/lisp-interpreter-in-c/q-expressions",permalink:"/docs/lisp-interpreter-in-c/q-expressions",draft:!1,tags:[{label:"lisp",permalink:"/docs/tags/lisp"},{label:"interpreter",permalink:"/docs/tags/interpreter"}],version:"current",sidebarPosition:8,frontMatter:{title:"08 Q-Expressions",tags:["lisp","interpreter"]},sidebar:"tutorialSidebar",previous:{title:"07 S-Expressions",permalink:"/docs/lisp-interpreter-in-c/s-expressions"},next:{title:"09 Variables",permalink:"/docs/lisp-interpreter-in-c/variables"}},o={},p=[{value:"Adding Features",id:"adding-features",level:2},{value:"Quoted Expressions",id:"quoted-expressions",level:2},{value:"Reading Q-Expressions",id:"reading-q-expressions",level:2},{value:"Builtin Functions",id:"builtin-functions",level:2},{value:"First Attempt",id:"first-attempt",level:2},{value:"Macros",id:"macros",level:2},{value:"Head &amp; Tail",id:"head--tail",level:2},{value:"List &amp; Eval",id:"list--eval",level:2},{value:"Join",id:"join",level:2},{value:"Builtins Lookup",id:"builtins-lookup",level:2}],u={toc:p};function d(e){let{components:n,...l}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,l,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"http://www.buildyourownlisp.com/chapter10_q_expressions"},"document")),(0,r.kt)("p",null,"codes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{target:"_blank",href:t(41804).Z},"q-expressions"))),(0,r.kt)("h2",{id:"adding-features"},"Adding Features"),(0,r.kt)("p",null,"You'll notice that the following chapters will all follow a similar pattern. This pattern is the typical approach used to add new features to a language. It consists of a number of steps that bring a feature from start to finish. These are listed below, and are exactly what we're going to do in this chapter to introduce a new feature called a Q-Expression."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Syntax"),(0,r.kt)("td",{parentName:"tr",align:null},"Add new rule to the language grammar for this feature")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Representation"),(0,r.kt)("td",{parentName:"tr",align:null},"Add new data type variation to represent this feature")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Parsing"),(0,r.kt)("td",{parentName:"tr",align:null},"Add new functions for reading this feature from the ",(0,r.kt)("strong",{parentName:"td"},"abstract syntax tree"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Semantics"),(0,r.kt)("td",{parentName:"tr",align:null},"Add new functions for evaluating and manipulating this features")))),(0,r.kt)("h2",{id:"quoted-expressions"},"Quoted Expressions"),(0,r.kt)("p",null,"In this chapter we'll implement a new type of Lisp Value called a Q-Expression."),(0,r.kt)("p",null,"This stands for ",(0,r.kt)("strong",{parentName:"p"},"quoted expression"),", and is a type of Lisp Expression that is not evaluated by the standard Lisp mechanics. When encountered by the evaluation function Q-expressions are left exactly as they are. This makes them ideal for a number of purposes. We can use them to store and manipulate other Lisp values such as numbers, symbols, or other S-Expressions themselves."),(0,r.kt)("p",null,"After we've added Q-Expressions we are going to implement a concise set of operators to manipulate them. Like the arithmetic operators these will prove fundamental in how we think about and play with expressions."),(0,r.kt)("p",null,"The syntax for Q-Expressions is very similar to that of S-Expressions. The only difference is that instead of parenthesis ",(0,r.kt)("inlineCode",{parentName:"p"},"()")," Q-Expressions are surrounded by curly brackets ",(0,r.kt)("inlineCode",{parentName:"p"},"{}"),". We can add this to our grammar as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"mpc_parser_t* Number = mpc_new(\"number\");\nmpc_parser_t* Symbol = mpc_new(\"symbol\");\nmpc_parser_t* Sexpr = mpc_new(\"sexpr\");\nmpc_parser_t* Qexpr = mpc_new(\"qexpr\");\nmpc_parser_t* Expr = mpc_new(\"expr\");\nmpc_parser_t* Lispy = mpc_new(\"lispy\");\n\nmpca_lang(MPCA_LANG_DEFAULT,\n    \"\\\n        number: /-?[0-9]+/ ;\\\n        symbol: '+' | '-' | '*' | '/' ;\\\n        sexpr: '(' <expr>* ')' ;\\\n        qexpr: '{' <expr>* '}' ;\\\n        expr: <number> | <symbol> | <sexpr> | <qexpr> ;\\\n        lispy: /^/ <expr>* /$/ ;\\\n    \", Number, Symbol, Sexpr, Qexpr, Expr, Lispy);\n\nmpc_cleanup(6, Number, Symbol, Sexpr, Qexpr, Expr, Lispy);\n")),(0,r.kt)("h2",{id:"reading-q-expressions"},"Reading Q-Expressions"),(0,r.kt)("p",null,"Because Q-Expressions are so similar S-Expressions much of their internal behaviour is going to be the same. We're going to reuse our S-Expression data fields to represent Q-Expressions, but we still need to add a separate type to the enumeration, as well as a constructor for this variation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"enum { LVAL_ERR, LVAL_NUM, LVAL_SYM, LVAL_SEXPR, LVAL_QEXPR };\n\nlval* lval_qexpr(void) {\n    lval* v = malloc(sizeof(lval));\n    v->type = LVAL_QEXPR;\n    v->count = 0;\n    v->cell = NULL;\n    return v;\n}\n")),(0,r.kt)("p",null,"To print and delete Q-Expressions we do essentially the same thing as with S-Expressions. We can add the relevant lines to our functions for printing and deletion as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"void lval_print(lval* v) {\n    switch (v->type) {\n        case LVAL_NUM: printf(\"%li\", v->num); break;\n        case LVAL_ERR: printf(\"Error: %s\", v->err); break;\n        case LVAL_SYM: printf(\"%s\", v->sym); break;\n        case LVAL_SEXPR: lval_expr_print(v, '(', ')'); break;\n        case LVAL_QEXPR: lval_expr_print(v, '{', '}'); break;\n    }\n}\n\nvoid lval_del(lval* v) {\n    switch (v->type) {\n        case LVAL_NUM: break;\n        case LVAL_ERR: free(v->err); break;\n        case LVAL_SYM: free(v->sym); break;\n\n        /* If Qexpr or Sexpr then delete all elements inside */\n        case LVAL_QEXPR:\n        case LVAL_SEXPR:\n            for (int i = 0; i < v->count; i++) {\n                lval_del(v->cell[i]);\n            }\n            /* Also free the memory allocated to contain the pointers */\n            free(v->cell);\n        break;\n    }\n\n    free(v);\n}\n")),(0,r.kt)("p",null,"Using these simple changes we can update our reading function ",(0,r.kt)("inlineCode",{parentName:"p"},"lval_read")," to be able to read in Q-Expressions. Because we reused all the S-Expression data fields for our Q-Expression type, we can also reuse all the of the functions for S-Expressions such as ",(0,r.kt)("inlineCode",{parentName:"p"},"lval_add"),". Therefore, to read in Q-Expressions we just need to add a special case for constructing an empty Q-Expression to ",(0,r.kt)("inlineCode",{parentName:"p"},"lval_read")," just below where we detect and create empty S-Expressions from the ",(0,r.kt)("strong",{parentName:"p"},"abstract syntax tree"),". And we also need to update ",(0,r.kt)("inlineCode",{parentName:"p"},"lval_read")," to recognize the curly bracket characters when they appear."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'if (strstr(t->tag, "qexpr")) { x = lval_qexpr(); }\n\n// ...\n\n\nif (strcmp(t->children[i]->contents, "(") == 0) { continue; }\nif (strcmp(t->children[i]->contents, ")") == 0) { continue; }\nif (strcmp(t->children[i]->contents, "}") == 0) { continue; }\nif (strcmp(t->children[i]->contents, "{") == 0) { continue; }\n')),(0,r.kt)("p",null,"Because there is no special method of evaluating Q-Expressions, we don't need to edit any of the evaluation functions. Our Q-Expressions should be ready to try."),(0,r.kt)("h2",{id:"builtin-functions"},"Builtin Functions"),(0,r.kt)("p",null,"We can read in Q-Expressions but they are still useless. We need some way to manipulate them."),(0,r.kt)("p",null,"For this we can define some built-in operators to work on our list type. Choosing a concise set of these is important. If we implement a few fundamental operations then we can use these to define new operations without add extra C code. There are a few ways to pick these fundamental operators but we'll choose a set that will allow us to do everything we need."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null}))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"list")),(0,r.kt)("td",{parentName:"tr",align:null},"Takes one or more arguments and returns a new Q-Expression containing the arguments")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"head")),(0,r.kt)("td",{parentName:"tr",align:null},"Takes a Q-Expression and returns a Q-Expression with only one of the first element")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tail")),(0,r.kt)("td",{parentName:"tr",align:null},"Takes a Q-Expression and returns a Q-Expression with the first element removed")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"join")),(0,r.kt)("td",{parentName:"tr",align:null},"Takes one or more Q-Expressions and returns a Q-Expression of them conjoined together")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"eval")),(0,r.kt)("td",{parentName:"tr",align:null},"Takes a Q-Expression and evaluates it as if it were a S-Expression")))),(0,r.kt)("p",null,"Like with our mathematical operators we should add these functions as possible valid symbols. Afterward we can go about trying to define their behaviour in a similar way to ",(0,r.kt)("inlineCode",{parentName:"p"},"builtin_op"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"mpca_lang(\n    \"\\\n        number : /-?[0-9]+/ ;                                  \\\n        symbol : \\\"list\\\" | \\\"head\\\" | \\\"tail\\\"                \\\n               | \\\"join\\\" | \\\"eval\\\" | '+' | '-' | '*' | '/' ; \\\n        sexpr  : '(' <expr>* ')' ;                             \\\n        qexpr  : '{' <expr>* '}' ;                             \\\n        expr   : <number> | <symbol> | <sexpr> | <qexpr> ;     \\\n        lispy  : /^/ <expr>* /$/ ;                             \\\n    \"\n, Number, Symbol, Sexpr, Qexpr, Expr, Lispy);\n")),(0,r.kt)("h2",{id:"first-attempt"},"First Attempt"),(0,r.kt)("p",null,"Our builtin functions should have the same interface as ",(0,r.kt)("inlineCode",{parentName:"p"},"builtin_op"),". That means the arguments should be bundled into an S-Expression which the function must use and then delete. They should return a new ",(0,r.kt)("inlineCode",{parentName:"p"},"lval*")," as a result of the evaluation."),(0,r.kt)("p",null,"The actual functionality of taking the head or tail of an Q-Expression shouldn't be too hard for us. We can make use of the existing functions we've defined for S-Expressions such as ",(0,r.kt)("inlineCode",{parentName:"p"},"lval_take")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"lval_pop"),". But like ",(0,r.kt)("inlineCode",{parentName:"p"},"builtin_op")," we also need to check that the inputs we get are valid."),(0,r.kt)("p",null,"Let's take a look at ",(0,r.kt)("inlineCode",{parentName:"p"},"head")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"tail")," first. These functions have a number of conditions under which they can't act. First of all we must ensure they are only passed a single argument, and that that argument is a Q-Expression. Then we need to ensure that this Q-Expression isn't empty and actually has some elements."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"head")," function can repeatedly pop and delete the item at index ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," until there is nothing else left in the list."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"tail")," function is even more simple. It can pop and delete the item at index ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),", leaving the tail remaining. An initial attempt at these functions might look like this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"lval* builtin_head(lval* a) {\n    if (a->count != 1) {\n        lval_del(a);\n        return lval_err(\"Function 'head' passed too many arguments!\");\n    }\n\n    if (a->cell[0]->type != LVAL_QEXPR) {\n        lval_del(a);\n        return lval_err(\"Function 'head' passed incorrect types!\");\n    }\n\n    if (a->cell[0]->count == 0 ) {\n        lval_del(a);\n        return lval_err(\"Funciton 'head' passed {}!\");\n    }\n\n    lval* v = lval_take(a,0);\n    while (v->count > 1) { lval_del(lval_pop(v, 1)); }\n    return v;\n}\n\nlval* builtin_tail(lval* a) {\n    if (a->count != 1) {\n        lval_del(a);\n        return lval_err(\"Function 'head' passed too many arguments!\");\n    }\n\n    if (a->cell[0]->type != LVAL_QEXPR) {\n        lval_del(a);\n        return lval_err(\"Function 'head' passed incorrect types!\");\n    }\n\n    if (a->cell[0]->count == 0 ) {\n        lval_del(a);\n        return lval_err(\"Funciton 'head' passed {}!\");\n    }\n\n    lval* v = lval_take(a,0);\n\n    lval_del(lval_pop(v, 1));\n    return v;\n}\n")),(0,r.kt)("h2",{id:"macros"},"Macros"),(0,r.kt)("p",null,"These ",(0,r.kt)("inlineCode",{parentName:"p"},"head")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"tail")," functions do the correct thing, but the code is pretty unclear, and long. There is so much error checking that the functionality is hard to see. One method we can use to clean it up is to use a ",(0,r.kt)("strong",{parentName:"p"},"Macro"),"."),(0,r.kt)("p",null,"A Macro is a ",(0,r.kt)("strong",{parentName:"p"},"preprocessor")," statement for creating function-like-things that are evaluated before the program is compiled. It can be used for many different things, one of which is what we need to de her, clean up code."),(0,r.kt)("p",null,"We can design a macro to help with our error conditions called ",(0,r.kt)("inlineCode",{parentName:"p"},"LASSERT"),". Macros are typically given names in capitals to help distinguish them from normal C functions. This marco take in three arguments ",(0,r.kt)("inlineCode",{parentName:"p"},"args"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"cond")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"err"),". It then generates code as shown on the right-hand side, but with these variables pasted in at the locations where they are name. This pattern is a good fit for all of our error conditions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"#define LASSERT(args, cond, err) if (!(cond)) { lval_del(args); return lval_err(err); }\n")),(0,r.kt)("p",null,"We can use this to change how our above functions are written, without actually changing what code is generated by the compiler. This makes it much easier to read for the programmer, and saves a bit of typing. The rest of the error conditions for our functions should become easy to write too!"),(0,r.kt)("h2",{id:"head--tail"},"Head & Tail"),(0,r.kt)("p",null,"Using this our ",(0,r.kt)("inlineCode",{parentName:"p"},"head")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"tail")," functions are defined as follows. Notice how much clearer their real functionality is."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"lval* builtin_head(lval* a) {\n    LASSERT(a, a->count == 1, \"Function 'head' passed too many arguments!\");\n\n    LASSERT(a, a->cell[0]->type == LVAL_QEXPR, \"Function 'head' passed incorrect type!\");\n\n    LASSERT(a, a->cell[0]->count != 0, \"Function 'head' passed {}!\");\n\n    lval* v = lval_take(a, 0);\n    while (v->count > 1) { lval_del(lval_pop(v, 1)); }\n    return v;\n}\n\nlval* builtin_tail(lval* a) {\n    LASSERT(a, a->count == 1, \"Function 'head' passed too many arguments!\");\n\n    LASSERT(a, a->cell[0]->type == LVAL_QEXPR, \"Function 'head' passed incorrect type!\");\n\n    LASSERT(a, a->cell[0]->count != 0, \"Function 'head' passed {}!\");\n\n    lval* v = lval_take(a, 0);\n    lval_del(lval_pop(v, 0));\n    return v;\n}\n")),(0,r.kt)("h2",{id:"list--eval"},"List & Eval"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"list")," function is simple. It just converts the input S-Expression to a Q-Expression and returns it."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"eval")," function is similar to the converse. It takes as input some single Q-Expression, which it converts to an S-Expression, and evaluates using ",(0,r.kt)("inlineCode",{parentName:"p"},"lval_eval"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"lval* builtin_list(lval* c) {\n    a->type = LVAL_QEXPR;\n    return a;\n}\n\nlval* builtin_eval(lval* a) {\n    LASSERT(a, a->count == 1, \"Function 'eval' passed too many arguments!\");\n\n    LASSERT(a, a->cell[0]->type == LVAL_QEXPR, \" Function 'eval' passed incorrect type!\");\n\n    lval* x = lval_take(a, 0);\n    x->type = LVAL_SEXPR;\n    return lval_eval(x);\n}\n")),(0,r.kt)("h2",{id:"join"},"Join"),(0,r.kt)("p",null,"Unlike the others, it can take multiple arguments, so its structure looks somewhat more like that of ",(0,r.kt)("inlineCode",{parentName:"p"},"builtin_op"),". First we check that all arguments are Q-Expressions and then we join them together one by one. To do this we use the function ",(0,r.kt)("inlineCode",{parentName:"p"},"lval_join"),". This works by repeatedly popping each item from ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," and adding it to ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," until ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," is empty. It then deletes y and returns ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"lval* lval_join(lval* x, lval* y) {\n    while (y->count) {\n        x = lval_add(x, lval_pop(y, 0));\n    }\n    lval_del(y);\n    return x;\n}\n\nlval* builtin_join(lval* a) {\n    for (int i = 0; i < a->count; i++) {\n        LASSERT(a, a->cell[i]->type == LVAL_QEXPR, \"Function 'join' passed incorrcet type.\");\n    }\n\n    lval* x = lval_pop(a, 0);\n    while (a->count) {\n        x = lval_join(x, lval_pop(a,0));\n    }\n    lval_del(a);\n    return x;\n}\n")),(0,r.kt)("h2",{id:"builtins-lookup"},"Builtins Lookup"),(0,r.kt)("p",null,"We've now got all of our builtin functions defined. We need to make a function that can call the correct one depending on what symbol it encounters in evaluation. We can do this using ",(0,r.kt)("inlineCode",{parentName:"p"},"strcmp")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"strstr"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'lval* builtin(lval* a, char* func) {\n\n    if(strcmp("list", func) == 0) { return builtin_list(a); }\n    if(strcmp("head", func) == 0) { return builtin_head(a); }\n    if(strcmp("tail", func) == 0) { return builtin_tail(a); }\n    if(strcmp("join", func) == 0) { return builtin_join(a); }\n    if(strcmp("eval", func) == 0) { return builtin_eval(a); }\n    if(strstr("+-/*", func)) { return builtin_op(a, func); }\n    lval_del(a);\n    return lval_err("Unknown Function!");\n}\n')),(0,r.kt)("p",null,"Then we can change our evaluation line in ",(0,r.kt)("inlineCode",{parentName:"p"},"lval_eval_sexpr")," to call ",(0,r.kt)("inlineCode",{parentName:"p"},"builtin")," rather than ",(0,r.kt)("inlineCode",{parentName:"p"},"builtin_op"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"lval* result = builtin(v, f->sym);\nlval_def(f);\nreturn result;\n")))}d.isMDXComponent=!0},41804:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/files/q-expressions-61b1a7b91f8a84d35f08ab900a880cf4.c"}}]);