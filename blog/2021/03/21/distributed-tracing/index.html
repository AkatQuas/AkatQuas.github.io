<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">Distributed Tracing | AkatQuas&#x27;s blog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://akatquas.github.io/blog/2021/03/21/distributed-tracing"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Distributed Tracing | AkatQuas&#x27;s blog"><meta data-rh="true" name="description" content="Microservice provides a powerful architecture, but not without its own challenges, especially with regard to debugging and observing distributed transactions across complex networks — simply because there are no in-memory calls or stack traces to do so."><meta data-rh="true" property="og:description" content="Microservice provides a powerful architecture, but not without its own challenges, especially with regard to debugging and observing distributed transactions across complex networks — simply because there are no in-memory calls or stack traces to do so."><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2021-03-21T00:00:00.000Z"><meta data-rh="true" property="article:tag" content="opentracing,microservice"><link data-rh="true" rel="icon" href="/images/favicon.ico"><link data-rh="true" rel="canonical" href="https://akatquas.github.io/blog/2021/03/21/distributed-tracing"><link data-rh="true" rel="alternate" href="https://akatquas.github.io/blog/2021/03/21/distributed-tracing" hreflang="en"><link data-rh="true" rel="alternate" href="https://akatquas.github.io/blog/2021/03/21/distributed-tracing" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="AkatQuas&#39;s blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="AkatQuas&#39;s blog Atom Feed"><link rel="stylesheet" href="/assets/css/styles.d30c7ca7.css">
<link rel="preload" href="/assets/js/runtime~main.5d758bff.js" as="script">
<link rel="preload" href="/assets/js/main.6f4b5c91.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/images/logo.svg" alt="AkatQuas" class="themedImage_ToTc themedImage--light_HNdA"><img src="/images/logo.svg" alt="AkatQuas" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">AkatQuas 🔭</b></a><a class="navbar__item navbar__link" href="/docs/about">Topic</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://akatquas.github.io/dateless/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Dateless<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a href="https://github.com/AkatQuas/AkatQuas.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/11/23/excerpt-on-unit-test">单元测试的实践</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/06/11/design-a-cli-tool">设计一个 CLI 工具</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/05/30/architecture-design-imo">架构设计的一些哲学经验</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/05/09/electron-application-architecture">Electron 应用的理想架构设计</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/04/type-vs-interface">Type vs Interface</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">Distributed Tracing</h1><div class="container_mt6G margin-vert--md"><time datetime="2021-03-21T00:00:00.000Z" itemprop="datePublished">March 21, 2021</time> · <!-- -->25 min read</div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>Microservice provides a powerful architecture, but not without its own challenges, especially with regard to debugging and observing distributed transactions across complex networks — simply because there are no in-memory calls or stack traces to do so.</p><p>This is where distributed tracing comes into the picture. Distributed tracing provides a solution for describing and analyzing the cross-process transactions.</p><p>Distributed tracing, also called distributed request tracing, is a method used to profile and monitor applications, especially those built using a microservice architecture. Distributed tracing helps pinpoint where failures occur and what causes poor performance.</p><blockquote><p>Some content extracted from <a href="https://tracing.cloudnative101.dev/docs/index.html" target="_blank" rel="noopener noreferrer">Learning Distributed Tracing 101</a>, <a href="https://www.packtpub.com/product/mastering-distributed-tracing/9781788628464" target="_blank" rel="noopener noreferrer">Mastering Distributed Tracing</a> and <a href="https://www.oreilly.com/library/view/distributed-tracing-in/9781492056621/" target="_blank" rel="noopener noreferrer">Distributed Tracing in Practice</a>.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="traditional-monitoring-tools">Traditional monitoring tools<a class="hash-link" href="#traditional-monitoring-tools" title="Direct link to heading">​</a></h2><p>Traditional monitoring tools are designed for monolith systems, observing the health and behavior of a single application instance.</p><p>They may be able to tell us a story about that single instance, but they know almost nothing about the distributed transaction that passed through it. These tools lack the context of the request.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="metrics">Metrics<a class="hash-link" href="#metrics" title="Direct link to heading">​</a></h3><p>Metrics, or stats, are numerical measures recorded by the application, such as counters, gauges, or timers.</p><blockquote><p>Memory usage, CPU saturation, etc.</p></blockquote><p>Metrics are very cheap to collect, since numeric values can be easily aggregated to reduce the overhead of transmitting that data to the monitoring system.</p><p>They are also fairly accurate, which is why they are very useful for the actual monitoring (as the dictionary defines it) and alerting.</p><blockquote><p>However, by aggregating data, we are throwing away all the context we had about the individual transactions.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="logs">Logs<a class="hash-link" href="#logs" title="Direct link to heading">​</a></h3><p>Logging is an even more basic observability tool than metrics.</p><p>Logs struggle with microservices because each log stream only tells us about a single instance of a service.</p><p>However, when it comes to the concurrency and asynchronous programming, logs become more complex.</p><p><img loading="lazy" alt="Evolution of concurrency" src="/assets/images/evolution-of-concurrency-c6dc17ee0013291e4dbb9a3a7a3d8e87.png" width="1168" height="732" class="img_ev3q"></p><p><a href="https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf" target="_blank" rel="noopener noreferrer">Image Original Address</a> at page 4.</p><p>Observing the behavior of such a system from the logs is very difficult, unless we annotate all logs with some kind of unique id representing the request rather than the thread, a technique (something like tracing logs across threads) that actually gets us close to how distributed tracing (tracing services across networks) works.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="distributed-tracing">Distributed tracing<a class="hash-link" href="#distributed-tracing" title="Direct link to heading">​</a></h2><p>Distributed tracing takes a request-centric view. It captures the detailed execution of causally-related activities performed by the components of a distributed system as it processes a given request.</p><p>Distributed tracing works in a nutshell just like:</p><ul><li><p>Tracing infrastructure attaches contextual metadata to each request and ensures that metadata is passed around during the request execution, even when one component communicates with another over a network.</p></li><li><p>At various trace points in the code, the instrumentation records events annotated with relevant information, such as the URL of an HTTP request or an SQL statement of a database query.</p></li><li><p>Recorded events are tagged with the contextual metadata and explicit causality references to prior events.</p></li></ul><p>That deceptively simple technique allows the tracing infrastructure to <strong>reconstruct the whole path of the request</strong>, <em>through the components of a distributed system</em>, <em>as a graph of events and causal edges between them</em>, which we call a <strong>trace</strong>.</p><blockquote><p>A trace allows us to reason about how the system was processing the request.</p><p>By taking a request-centric view, tracing helps to illuminate different behaviors of the system.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="important-concepts">Important Concepts<a class="hash-link" href="#important-concepts" title="Direct link to heading">​</a></h2><p><strong>Opentrace Data model</strong></p><p><a href="https://github.com/opentracing/specification/blob/master/specification.md#the-opentracing-data-model" target="_blank" rel="noopener noreferrer">The OpenTracing Semantic Specification #data model</a></p><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic"># Causal relationships between Spans in a single Trace</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">Span A</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain">  ←←←</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">the root span</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            </span><span class="token operator" style="color:rgb(137, 221, 255)">|</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">     +------+------+</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">     </span><span class="token operator" style="color:rgb(137, 221, 255)">|</span><span class="token plain">             </span><span class="token operator" style="color:rgb(137, 221, 255)">|</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">Span B</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain">      </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">Span C</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"> ←←←</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">Span C is a </span><span class="token variable" style="color:rgb(191, 199, 213)">`</span><span class="token variable" style="color:rgb(191, 199, 213)">ChildOf</span><span class="token variable" style="color:rgb(191, 199, 213)">`</span><span class="token plain"> Span A</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">     </span><span class="token operator" style="color:rgb(137, 221, 255)">|</span><span class="token plain">             </span><span class="token operator" style="color:rgb(137, 221, 255)">|</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">Span D</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain">      +---+-------+</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">               </span><span class="token operator" style="color:rgb(137, 221, 255)">|</span><span class="token plain">           </span><span class="token operator" style="color:rgb(137, 221, 255)">|</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">           </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">Span E</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">Span F</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">&gt;&gt;</span><span class="token operator" style="color:rgb(137, 221, 255)">&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">Span G</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">&gt;&gt;</span><span class="token operator" style="color:rgb(137, 221, 255)">&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">Span H</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                       ↑</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                       ↑</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                                       ↑</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                         </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">Span G </span><span class="token variable" style="color:rgb(191, 199, 213)">`</span><span class="token variable" style="color:rgb(191, 199, 213)">FollowsFrom</span><span class="token variable" style="color:rgb(191, 199, 213)">`</span><span class="token plain"> Span F</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic"># Temporal relationships between Spans in a single Trace</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">––</span><span class="token operator" style="color:rgb(137, 221, 255)">|</span><span class="token plain">–––––––</span><span class="token operator" style="color:rgb(137, 221, 255)">|</span><span class="token plain">–––––––</span><span class="token operator" style="color:rgb(137, 221, 255)">|</span><span class="token plain">–––––––</span><span class="token operator" style="color:rgb(137, 221, 255)">|</span><span class="token plain">–––––––</span><span class="token operator" style="color:rgb(137, 221, 255)">|</span><span class="token plain">–––––––</span><span class="token operator" style="color:rgb(137, 221, 255)">|</span><span class="token plain">–––––––</span><span class="token operator" style="color:rgb(137, 221, 255)">|</span><span class="token plain">–––––––</span><span class="token operator" style="color:rgb(137, 221, 255)">|</span><span class="token plain">–</span><span class="token operator" style="color:rgb(137, 221, 255)">&gt;</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">time</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">Span A···················································</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">   </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">Span B··············································</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">Span D··········································</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">Span C········································</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">         </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">Span E·······</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain">        </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">Span F··</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">Span G··</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">Span H··</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="span">Span<a class="hash-link" href="#span" title="Direct link to heading">​</a></h3><p><a href="https://github.com/opentracing/specification/blob/master/specification.md#span" target="_blank" rel="noopener noreferrer">Specification on Span</a></p><ul><li>operation name</li><li>start timestamp and end timestamp</li><li>Tags</li><li>Logs</li><li>SpanContext<ul><li>Span ID</li><li>Trace ID</li><li>BaggageItems(key-value pairs)</li></ul></li></ul><p><strong>What is the difference between a span <em>tag</em> and a span <em>log</em>?</strong></p><ul><li>They are both annotating the span with some contextual information.</li><li>Tags typically apply to the whole span, while logs represent some events that happened during the span execution.</li><li>A log always has a timestamp that falls within the span&#x27;s start-end time interval. (The tracing system does not explicitly track causality between logged events the way it keeps tracks of causality relationships between spans, because it can be inferred from the timestamps.)</li></ul><p>The OpenTracing Specification defines semantic data conventions that prescribe certain well-known tag names and log fields for common scenarios. Instrumentation is encouraged to use those names to ensure that the data reported to the tracing system is well-defined and portable across different tracing backends.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tracer">Tracer<a class="hash-link" href="#tracer" title="Direct link to heading">​</a></h3><p><a href="https://github.com/opentracing/specification/blob/master/specification.md#tracer" target="_blank" rel="noopener noreferrer">Specification on Tracer</a></p><p>A <code>Tracer</code> is the actual implementation that will record the <code>Spans</code> and publish them somewhere.</p><p>Once a <code>Tracer</code> instance is obtained, it can be used to manually create <code>Span</code>, or pass it to existing instrumentation for frameworks and libraries.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="fundamentals">Fundamentals<a class="hash-link" href="#fundamentals" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/trace-and-execution-121371be84c1865f7722ec79d9d7454a.png" width="1402" height="736" class="img_ev3q"></p><p><a href="https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf" target="_blank" rel="noopener noreferrer">Image Original Address</a> at page 16.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="request-correlation">Request correlation<a class="hash-link" href="#request-correlation" title="Direct link to heading">​</a></h3><p>The basic concept of distributed tracing appears to be very straightforward:</p><ul><li>Instrumentation is inserted into chosen points of the program&#x27;s code (trace points) and produces profiling data when executed</li><li>The profiling data is collected in a central location, correlated to the specific execution (request), arranged in the causality order, and combined into a trace that can be visualized or further analyzed</li></ul><p>There are three most common approaches: black-box inference, domain-specific schemas, and metadata propagation.</p><p>The instrumentation trace points could annotate the data they produce with a global identifier <em>execution identifier</em> that is unique for each traced request.</p><p>Then the tracing infrastructure receiving the annotated profiling data could easily reconstruct the full execution of the request, by grouping the records by the execution identifier.</p><p>The global execution identifier needs to be passed along the execution flow. This is achieved via a process known as <em>metadata propagation</em> or <em>distributed context propagation</em>.</p><p>Metadata propagation in a distributed system consists of two parts: <em>in-process propagation</em> and <em>inter-process propagation</em>.</p><p>In-process propagation is responsible for making the metadata available to trace points inside a given program. It needs to be able to carry the context between the inbound and outbound network calls, dealing with possible thread switches or asynchronous behavior, which are common in modern applications.</p><p>Inter-process propagation is responsible for transferring metadata over network calls when components of a distributed system communicate to each other during the execution of a given request.Inter-process propagation is typically done by decorating communication frameworks with special tracing middleware that encodes metadata in the network messages, for example, in HTTP headers, Kafka records headers, and so on.</p><p>The key disadvantage of metadata propagation-based tracing is the expectation of a white-box system whose components can be modified accordingly. And, it is more scalable and provides much higher accuracy of the data compared to black-box techniques.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="anatomy-of-distributed-tracing">Anatomy of distributed tracing<a class="hash-link" href="#anatomy-of-distributed-tracing" title="Direct link to heading">​</a></h3><p>The following diagram shows a typical organization of distributed tracing systems, built around metadata propagation.</p><p><img loading="lazy" alt="Anatomy of distributed tracing" src="/assets/images/anatomy-of-distributed-tracing-394c8f99efa86fb62039a9cb258b4d04.png" width="1404" height="796" class="img_ev3q"></p><p><a href="https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf" target="_blank" rel="noopener noreferrer">Image Original Address</a> at page 17.</p><p>Special trace points at the edges of the microservice, which we can call <em>inject trace points</em> and <em>extract trace points</em>, are also responsible for encoding and decoding metadata for passing it across process boundaries.</p><p>The Tracing API is implemented by a concrete tracing library that reports the collected data to the tracing backend, usually with some in-memory batching to reduce the communications overhead.</p><p>Reporting is always done asynchronously in the background, off the critical path of the business requests. The tracing backend receives the tracing data, normalizes it to a common trace model representation, and puts it in a persistent trace storage.</p><p>Because tracing data for a single request usually arrives from many hosts, the trace storage is often organized to store individual pieces incrementally, indexed by the execution identifier. This allows for later reconstruction of the whole trace for the purpose of visualization, or additional processing through aggregations and data mining.</p><p><strong>Preserving causality</strong></p><p>Tracing systems need to capture causality that allows assembling the data captured by the trace points in the correct sequence.</p><p>Most tracing systems elect to preserve Lamport&#x27;s happens-before relation, denoted as <code>→</code> and formally defined as the least strict partial order on events, such that:</p><ul><li>If events <code>a</code> and <code>b</code> occur in the same process, then <code>a → b</code> if the occurrence of event <code>a</code> preceded the occurrence of event <code>b</code></li><li>If event <code>a</code> is the sending of a message and event <code>b</code> is the reception of the message sent in event <code>a</code>, then <code>a → b</code></li></ul><p>Most of today&#x27;s industrial-grade tracing infrastructures use <strong>dynamic metadata</strong>, which can be fixed-width or variable-width.</p><p>Most tracing systems use <strong>fixed-width dynamic metadata</strong>, where, in addition to the execution identifier, they record a unique ID (for example, a random 64-bit value) of the event captured by the trace point. When the next trace point is executed, it stores the inbound event ID as part of its tracing data, and replaces it with its own ID.</p><p><img loading="lazy" alt="Causality using id or trace segment" src="/assets/images/causality-with-dynamic-fixed-width-metadata-4fa07ec1664134089a4124d95018a56a.png" width="1340" height="890" class="img_ev3q"></p><p><a href="https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf" target="_blank" rel="noopener noreferrer">Image Original Address</a> at page 18.</p><p><strong>Propagating Context</strong></p><p>In order to create traces, we will need some way to communicate certain details about our spans to other services or other parts of our process. The mechanism by which we communicate these details to other services is generally known as <em>context propagation</em>.</p><ul><li>Interprocess propagation</li></ul><p>In distributed RPCs, it’s popular to send the trace context between services in an HTTP header, and have the child service create a span with a defined parent-child relationship.</p><p>We’re <em>injecting</em> the span context into the transport, and <em>extracting</em> it back out.</p><blockquote><p>These inject and extract operations happen at the edge of the service in code—you’d generally want to use some sort of middleware in the HTTP service that would automatically perform these operations when a new request is created or received.</p></blockquote><ul><li>Intraprocess propagation</li></ul><p>We can create parent-child relations between spans using a span context. An easy way to do it through a mechanism known as a <em>scope manager</em>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="trace-models">Trace models<a class="hash-link" href="#trace-models" title="Direct link to heading">​</a></h3><p>The purpose of the <em>Collection/Normalization</em> component is to receive tracing data from the trace points in the applications and convert it to some normalized <em>trace model</em>, before saving it in the trace storage.</p><p><strong>Event model</strong></p><p>The following diagram illustrates an event graph observed from the execution of an RPC request/response by a client-server application. It includes events collected at different layers of the stack, from application-level events (for example, &quot;client send&quot; and &quot;server receive&quot;) to events in the TCP/IP stack.</p><p><img loading="lazy" alt="Trace representation of an RPC request in the event model" src="/assets/images/event-model-of-an-rpc-request-56b0ff98dad2a29f8550873e9ef2e76b.png" width="1258" height="660" class="img_ev3q"></p><p><a href="https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf" target="_blank" rel="noopener noreferrer">Image Original Address</a> at page 19.</p><p>Event model is useful for describing what happened, but they don&#x27;t directly lead to actionable data.</p><p><strong>Span model</strong></p><p>Span model is a simplified trace model.</p><p>The traces are represented as trees, where tree nodes are basic units of work referred to as spans. The edges in the tree indicate causal relationships between a span and its parent span.</p><p>Each span is a simple log of timestamped records, including its start and end time, a human-readable operation name, and zero or more intermediary application-specific annotations in the form of (timestamp, description) pairs, which are equivalent to the info events in the previous example.</p><p><img loading="lazy" alt="Trace representation of an RPC request in the event model" src="/assets/images/span-model-examples-e0d1f23611d6293abd0ef5c9a1b1c0b7.png" width="1252" height="474" class="img_ev3q"></p><p><a href="https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf" target="_blank" rel="noopener noreferrer">Image Original Address</a> at page 21.</p><p>Each span is assigned a unique ID (for example, a random 64-bit value), which is propagated via metadata along with the execution ID. When a new span is started, it records the ID of the previous span as its <em>parent ID</em>, thus capturing the causality.</p><p>Effectively, traces in this model look like distributed stack traces, a concept very intuitive to all developers.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="clock-skew-adjustment">Clock skew adjustment<a class="hash-link" href="#clock-skew-adjustment" title="Direct link to heading">​</a></h3><p>Clearly, we cannot trust the timestamps to be actually correct, but this is not what we often look for when we analyze distributed traces.</p><p>It is more important that timestamps in the trace are correctly aligned relative to each other.</p><ul><li><p>When the timestamps are from the same process, such as the start of the <code>server</code> span and the extra info annotations in the following diagram, we can assume that their relative positions are correct.</p></li><li><p>The timestamps from different processes on the same host are generally incomparable because even though they are not subject to the hardware clock skew, the accuracy of the timestamps depends on many other factors, such as what programming language is used for a given process and what time libraries it is using and how.</p></li><li><p>In the end, the clock skew adjustment process is always heuristic, since we typically don&#x27;t have other reliable signals to calculate it precisely.</p></li></ul><p><img loading="lazy" alt="Clock skew adjustment" src="/assets/images/clock-skew-adjustment-50868075e08f70992d57fb9cc5ea2b41.png" width="1256" height="704" class="img_ev3q"></p><blockquote><p>δ<sub>1</sub> or δ<sub>2</sub> are just estimated;</p></blockquote><p><a href="https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf" target="_blank" rel="noopener noreferrer">Image Original Address</a> at page 21.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="styles-of-instrumentation">Styles of instrumentation<a class="hash-link" href="#styles-of-instrumentation" title="Direct link to heading">​</a></h3><p>In a microservices-based application, most instrumentation trace points occur next to process boundaries, where the communications are performed by the means of some frameworks, such as RPC libraries.</p><p>If we instrument the frameworks, we need to do it only once and then reuse that instrumentation across the application. This means is usually reserved for special cases where some unique application logic warrants it to monitor access to some custom shared resource.</p><p>Another style of instrumentation commonly referred to as <em>agent-based</em>, which promises automatic, zero-touch instrumentation of the applications.</p><p>In dynamic languages, like Python and JavaScript, it is often done through a technique known as <em>monkey-patching</em>, which involves dynamic modification of classes or modules at runtime, transparently to the application. The tracing instrumentation agent might replace that function with a wrapper that would create a client-side tracing span, invoke the original function, and then finish the span, annotated with the results of the request, such as the HTTP status code.</p><p>In Java applications, where dynamic code modifications like that are not allowed, a similar effect is achieved though byte code manipulation.</p><blockquote><p>When frameworks are designed with extensibility in mind, adding the tracing code in the form of middleware, interceptors, filters, and so on is generally very straightforward.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="instrumentation-quality-checklist">Instrumentation Quality Checklist<a class="hash-link" href="#instrumentation-quality-checklist" title="Direct link to heading">​</a></h2><p>When instrumenting an existing service or creating guidelines on how to instrument new services, it can be useful to have a checklist of items that are important to ensuring quality instrumentation throughout the entire application.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="span-status-and-creation">Span Status and Creation<a class="hash-link" href="#span-status-and-creation" title="Direct link to heading">​</a></h3><ul><li>All error conditions under a given span appropriately set the span status to an error state.</li><li>RPC framework result codes are mapped to span status (i.e., Internal Error, Not Found, etc.).</li><li>All spans that are started are also finished, even in the case of unrecoverable errors if possible.</li><li>Spans should only represent work that is semantically important to the request life cycle of a service; try not to create spans around endpoints only receiving synthetic traffic, like a /status or /health endpoint.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="span-boundaries">Span Boundaries<a class="hash-link" href="#span-boundaries" title="Direct link to heading">​</a></h3><ul><li>Egress and ingress spans have appropriate labels (SpanKind is set).</li><li>Egress and ingress spans have appropriate relationships (client/server, consumer/producer).</li><li>Internal spans are appropriately labeled and do not imply a remote call.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="attributes">Attributes<a class="hash-link" href="#attributes" title="Direct link to heading">​</a></h3><ul><li>Spans include a version attribute for the service they represent.</li><li>Spans that represent work by a dependency have an attribute for that dependency&#x27;s version.</li><li>Spans should include attributes identifying underlying infrastructure:<ul><li>Hostname / FQDN</li><li>Container name, if appropriate</li><li>Runtime version</li><li>Application server version, if applicable</li><li>Region or availability zone</li></ul></li><li>Attributes are namespaced where appropriate (i.e., to prevent collisions between key names where the semantic meaning of the key differs between services in a request).</li><li>Attributes with numerical values should include the unit of measurement in the key name (i.e, payload_size_kb versus payload_size).</li><li>Attributes should not contain any PII.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="events">Events<a class="hash-link" href="#events" title="Direct link to heading">​</a></h3><ul><li>Useful and descriptive event messages that would be useful for upstream or downstream service users should be added:<ul><li>Request-response payloads (sanitized)</li><li>Stack traces, exceptions, and error messages</li></ul></li><li>Long-running operations (such as waiting for a mutex) should be wrapped in events; one when the operation begins, and one when it ends.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="tracing-in-service-meshes">Tracing in Service meshes<a class="hash-link" href="#tracing-in-service-meshes" title="Direct link to heading">​</a></h2><p>The pattern of consolidating inter-service communication functionality into a reusable component is not new.</p><p>There was a fairly popular style, called Enterprise Service Bus, dating back to early 2000s:</p><ul><li>Route messages between services</li><li>Monitor and control routing of message exchange between services</li><li>Resolve contention between communicating service components</li><li>Control deployment and versioning of services</li><li>Marshal use of redundant services</li><li>Provide commodity services like event handling, data transformation and mapping, message and event queuing and sequencing, security or exception handling, protocol conversion, and enforcing proper quality of communication services</li></ul><p>Often, the real implementation is something like central layer or hub through which all the inter-service communications were proxyed.</p><p>Recently, a new architectural pattern known as a <strong>sidecar</strong> hash merged:</p><ul><li>A sidecar can be implemented in its own language, independent of the main application.</li><li>A sidecar is collocated with the main application, so there is no significant latency between them (but a small latency does exist).</li><li>Each sidecar handles just a single instance of a single service, so a misbehaving sidecar process may affect the health of that instance but will not affect the rest of the application (although a bad global configuration change may theoretically affect all sidecars at once).</li><li>A sidecar acts as an extension mechanism for the main application, even if the application itself provides no extension capabilities. For example, a third-party application may not expose any monitoring signals, but a sidecar can compensate for that.</li><li>A sidecar&#x27;s life cycle and identity are tied to the main application&#x27;s life cycle and identity, which allows the sidecar to take on such duties as authentication and transport-level security.</li></ul><p>The term <em>service mesh</em> often refers to the use of the sidecar pattern to provide the infrastructure for microservices communications.</p><blockquote><p>A <em>service mesh</em> is a configurable infrastructure layer designed to support interprocess communication among services. It performs this through <em>sidercar proxies</em>, processes that live along-side each service instance and handle all interprocess communication for their associated service.</p><p>In addition to service communications, the service mesh and its sidecars can handle monitoring, security, service discovery, load balancing, encryption, and more.</p><p>In essence, service mesh instrumentation is agnostic to the transport layer of each service. As long as the traffic is being passed through the sidecar, it will be traced.</p></blockquote><p>Service mesh platforms typically provide two separate components, the <em>data plane</em> and the <em>control plane</em>.</p><p>The job of data plane is to translate, forward, and observe every network packet that goes in and out of the service instance. Examples of network proxies that can be used as a service mesh data plane include Envoy, Linkerd, NGINX, HAProxy, and Traefik.</p><p>The control plane decides how the data plane should perform its tasks. It provides policy and configuration for all the network proxies (data plane) that run in a service mesh.</p><blockquote><p>The control plane in charge of these decisions, such as:</p><ul><li>how does the proxy know where to find service X on the network?</li><li>Where does it get the configuration parameters for load balancing, timeouts, and circuit breaking?</li><li>Who configures the authentication and authorization settings?</li></ul></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="observability-via-a-service-mesh">Observability via a service mesh<a class="hash-link" href="#observability-via-a-service-mesh" title="Direct link to heading">​</a></h3><p>If we place a service mesh in the path of every network request between the services in an application, it makes it an ideal place to collect consistent, standardized telemetry about the application.</p><p>This standardized observability alone may be enough to compensate for a small performance loss introduced by going through a proxy for every request because it dramatically enhances the operational properties of the system, making it easier to monitor and troubleshoot.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="front-service-telemetry">Front service telemetry<a class="hash-link" href="#front-service-telemetry" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |     WAN      |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">+----------+      |  trace data  |      +---------------------+</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">|          +--------------------------&gt; |   Tracing backend   |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">|  Client  |      |              |      +---------------------+</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">|          +-------------+       |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">+----------+      |      |       |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |   app data   |      +---------------------+</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |      +------------&gt; |   Service backend   |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |      +---------------------+</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |      +---------------------+</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |      |   Tracing backend   |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |      +---+-----------------+</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |          ^</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |          |  synthesized span</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">+----------+      |              |          |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">|          |      |  App data    |      +---+-----------------+</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">|  Client  +--------------------------&gt; |   Service backend   |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">|          |      |  Timing info |      +---------------------+</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">+----------+      |              |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |  +---+</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |  |   |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">+----------+      |  trace data  |  |   |      +---------------------+</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">|          +------------------------+ P +----&gt; |   Tracing backend   |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">|  Client  |      |              |  | r |      +---------------------+</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">|          +-------------+       |  | o |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">+----------+      |      |       |  | x |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |   app data   |  | y |      +---------------------+</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |      +----------+   +----&gt; |   Service backend   |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |  |   |      +---------------------+</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |  |   |</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |  +---+</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                  |              |</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="sampling-trace">Sampling trace<a class="hash-link" href="#sampling-trace" title="Direct link to heading">​</a></h2><p>While the impact on the application is small, the cost of processing and storing trace data can be large.</p><p>The value of traces is often in the details they provide, whether following requests across services or in the tags and events associated with spans.</p><p>A trace can become much larger than the request and response that it describes, so storing every trace would be expensive from an infrastructure point of view.</p><p>However, not all trace data offers the same value. Traces representing slow or failed requests may offer a lot more value.</p><p>Most tracing systems employ various forms of sampling to capture only a certain portion of the observed traces to reduce impact caused by tracing on the application&#x27;s latency and throughput.</p><p>Most of the sampling methods share a common characteristic of trying to make a sampling decision at the level of the whole trace, not its individual spans. This is often referred to as <em>consistent</em> or <em>coherent</em> sampling.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="head-based-consistent-sampling">Head-based consistent sampling<a class="hash-link" href="#head-based-consistent-sampling" title="Direct link to heading">​</a></h3><p>Head-based consistent sampling, also known as upfront sampling, makes the sampling decision once per trace at the beginning of the trace. This sampling scheme is consistent because it ensures that either all spans of a given trace are captured by the tracing system or none of them are.</p><blockquote><p>The decision is usually made by the tracing libraries running inside the application, because consulting the tracing backend at the point of creating the first span would put the tracing infrastructure onto the critical path of the business requests, which is highly undesirable for performance and reliability reasons.</p></blockquote><p><strong>Probabilistic sampling</strong></p><p>In probabilistic sampling, the sampling decision is made based on a coin toss with a certain probability.</p><p>Probabilistic samplers are by far the most popular in the tracing systems using head-based sampling.</p><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary> pseudo code </summary><div><div class="collapsibleContent_i85q"><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">class ProbabilisticSampler(probability: Double) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  def isSampled: Boolean = {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if (Math.random() &lt; probability) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      return false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  val boundary: Double = Long.MaxValue * probability</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  def isSampled(traceId: Long): Boolean = {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if (traceId &lt; boundary) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      return false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div></details><p><strong>Rate limiting sampling</strong></p><p>The rate limiter ensures that only a fixed number of traces are sampled per given time interval, for example, 10 traces per second or one trace per minute.</p><blockquote><p>Rate limiting sampling can be useful in microservices that have very uneven traffic patterns, because probabilistic sampling can only be configured with a single probability value, which could be too small during low-traffic periods and too large during high-traffic periods.</p></blockquote><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary> pseudo code </summary><div><div class="collapsibleContent_i85q"><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">class RateLimiter(creditsPerSecond: Double, maxBalance: Double) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  val creditsPerNanosecond = creditsPerSecond / 1e9</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  val balance: Double = 0</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  var lastTick = System.nanoTime()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  def withdraw(amount: Double): Boolean = {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    val currentTime = System.nanoTime()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    val elapsedTime = currentTime - lastTick</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    lastTick = currentTime</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    balance += elapsedTime * creditsPerNanosecond</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if (balance &gt; maxBalance) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      balance = maxBalance</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if (balance &gt;= amount) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      balance -= amount</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      return true</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return false</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">class RateLimitSampler(tracesPerSecond: Double) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  val limiter = new RateLimiter(</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    creditsPerSecond=tracesPerSecond,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    maxBalance=Math.max(tracesPerSecond, 1.0)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  )</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  def isSampled: Boolean = {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return limiter.withdraw(1.0)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div></details><p><strong>Guaranteed-throughput probabilistic sampling</strong></p><p>This is a combination of a probabilistic sampler for normal operations and an additional rate limiter for low-traffic periods.</p><p>The rate limiter is only consulted when the probabilistic sampler decides not to sample. This ensures that a given trace point is sampled with at least a certain minimal rate, hence the name &quot;guaranteed throughput.&quot;</p><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary> pseudo code </summary><div><div class="collapsibleContent_i85q"><div class="language-scala codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-scala codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">class GuaranteedThroughputSampler(</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  probability: Double,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  minTracesPerSecond: Double</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  val probabilistic = new ProbabilisticSampler(probability)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  val lowerBound = new RateLimitingSampler(minTracesPerSecond)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  def isSampled: Boolean = {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    val prob: Boolean = probabilistic.isSampled()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if (prob) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      return prob</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    val rate: Boolean = lowerBound.isSampled()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return rate</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div></details><p><strong>Adaptive sampling</strong></p><p>Adaptive sampling techniques try to dynamically adjust sampling parameters throughout the architecture, based on the difference between the actual and the desired rate of trace data generation.</p><p>They can be implemented in two flavors, depending on whether the observations and adjustments are done locally in the tracers or globally in the tracing backend.</p><p>The local adaptive sampling is a way to automatically customize sampling probabilities across workloads with different traffic. The tracers are parameterized not by a fixed probability of sampling, but by a desired rate of sampled traces. Then it will automatically adjust their own sampling probability based on the number of traces they end up sampling with the current probability, trying to bring that number close to the target rate.</p><p>The global adaptive sampling is a way to replace a uniform sampling probability across all services with another uniform parameter for an effective sampling rate, while the actual probability is dynamically adjusted. The target effective rate is still a configuration parameter that needs to be provided to each tracer in each microservice.</p><p><strong>Adaptive sampling in Jaeger</strong></p><p>The adaptive sampling infrastructure in the collectors calculates the desired sampling probabilities for all services and provides them back to the tracing libraries that periodically poll for that information (dashed lines).</p><p><img loading="lazy" alt="Adaptive sampling in Jaeger" src="/assets/images/adaptive-sampling-in-jaeger-a2de5d62697c5f35978e8ef0dab87d90.png" width="1412" height="772" class="img_ev3q"></p><p><a href="https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf" target="_blank" rel="noopener noreferrer">Image Original Address</a> at page 36.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tail-based-consistent-sampling">Tail-based consistent sampling<a class="hash-link" href="#tail-based-consistent-sampling" title="Direct link to heading">​</a></h3><p>It would be nice if we could delay the sampling decision until we see something unusual recorded in the trace, such as an abnormal request latency, or an error, or a call graph branch we have not seen before.</p><p><strong>Tail-based sampling</strong> addresses this problem by making the sampling call at the end of the request execution, when we have the complete trace and can make a more intelligent decision about whether it should be captured for storage or not.</p><p>Another interesting feature of tail-based sampling is that it almost entirely eliminates the problem of <em>oversampling</em> and <em>overload of the tracing backend</em>. Making the sampling decision after collecting the whole trace is equivalent to a pull model, where the tracing backend knows exactly how much data it is requesting and can easily tune it up and down.</p><p>In the following diagram, all spans for traces T1 and T2 are collected in the first and the second collectors respectively. In this hypothetical example, only the second trace, T2, is considered interesting and sent to the storage, while trace T1 is simply discarded to free up space for newer traces.</p><p><img loading="lazy" alt="hypothetical architecture for tail-based sampling" src="/assets/images/hypothetical-architecture-for-tail-based-sampling-54263904e26a4c2f3be898836e8b18aa.png" width="1416" height="880" class="img_ev3q"></p><p><a href="https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf" target="_blank" rel="noopener noreferrer">Image Original Address</a> at page 38.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="architecture-and-deployment-modes">Architecture and deployment modes<a class="hash-link" href="#architecture-and-deployment-modes" title="Direct link to heading">​</a></h2><p>Many tracing backends are themselves implemented as microservices-based distributed systems that consist of multiple horizontally-scalable components. Some of those components are optional, which allows different deployment configurations depending on the needs of your architecture.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="basic-architecture-agent--collector--query-service">Basic architecture: agent + collector + query service<a class="hash-link" href="#basic-architecture-agent--collector--query-service" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="Basic architecture of Jaeger backend deployment" src="/assets/images/basic-architecture-of-jaeger-backend-deployment-9d1716c7ddeda6dcf848f8061d918b4e.png" width="1560" height="640" class="img_ev3q"></p><p><a href="https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf" target="_blank" rel="noopener noreferrer">Image Original Address</a> at page 60.</p><p><strong>Client</strong>: is the code that runs inside the business application, and is responsible for exporting the data to the tracing backend. The most common implementation is to stash the tracing data into an internal memory buffer, to move it off the critical path of the request, and then send it in batches to the tracing backend asynchronously, for example, from a separate background thread.</p><p><strong>Agent</strong>: implements the sidercar design pattern by encapsulating the logic of submitting data to the collectors, including service discovery and load balancing.</p><p><strong>Collector</strong>: are stateless, horizontally scalable services that perform a number of actions: receiving span data regarding its encoding and protocols, convert and normalize span data to a single internal data model, send the normalized span data to a pluggable persistent storage, and contain the adaptive sampling logic that observes all inbound span traffic and generates sampling strategies.</p><p><strong>Query service and UI</strong>: a stateless component that implements a query API for searching and retrieving traces from storage.</p><p><strong>Data mining jobs</strong>: perform post-processing and aggregation of the trace data, such as building the service dependency graphs or computing tracing quality scores.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="streaming-architecture">Streaming architecture<a class="hash-link" href="#streaming-architecture" title="Direct link to heading">​</a></h3><p><img loading="lazy" alt="Streaming architecture of the Jaeger backend deployment" src="/assets/images/streaming-architecture-of-the-jaeger-backend-deployment-4722b95fc28b91a9ad6d65e25a18e7c2.png" width="1564" height="572" class="img_ev3q"></p><p><a href="https://static.packt-cdn.com/downloads/9781788628464_ColorImages.pdf" target="_blank" rel="noopener noreferrer">Image Original Address</a> at page 60.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="references">References<a class="hash-link" href="#references" title="Direct link to heading">​</a></h2><ul><li><p><a href="https://tracing.cloudnative101.dev/docs/index.html" target="_blank" rel="noopener noreferrer">Learning Distributed Tracing 101</a>: A quick guide to distributed tracing.</p></li><li><p><a href="https://github.com/yurishkuro/opentracing-tutorial" target="_blank" rel="noopener noreferrer">Opentracing Tutorial By Yuri Shkuro</a>: A collection of tutorials for the <a href="https://opentracing.io" target="_blank" rel="noopener noreferrer">OpenTracing API</a>.</p></li><li><p><a href="https://www.packtpub.com/product/mastering-distributed-tracing/9781788628464" target="_blank" rel="noopener noreferrer">Mastering Distributed Tracing By Yuri Shkuro</a> provides comprehensive coverage of the tracing field. Solve problems through code instrumentation with open standards, and learn how to profile complex systems.</p></li><li><p><a href="https://www.oreilly.com/library/view/distributed-tracing-in/9781492056621/" target="_blank" rel="noopener noreferrer">Distributed Tracing in Practice</a>: With this guide, you’ll learn what distributed tracing is and how to use it to understand the performance and operation of your software.</p></li><li><p><a href="https://pjw.io/articles/2018/05/08/opentracing-explanations/" target="_blank" rel="noopener noreferrer">OpenTracing 详解</a></p></li></ul><p>Many thanks to:</p><ul><li><p>Yuri Shkuro (<a href="https://twitter.com/yurishkuro" target="_blank" rel="noopener noreferrer">@YuriShkuro</a>): Jaeger</p></li><li><p>Ben Sigelman (<a href="https://github.com/bensigelman" target="_blank" rel="noopener noreferrer">@bhs</a>): LightStep.</p></li></ul></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/opentracing">opentracing</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/microservice">microservice</a></li></ul></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/2021/03/27/ts-handbook"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">TypeScript handbook</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/2021/02/03/file-system"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">文件系统札记</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#traditional-monitoring-tools" class="table-of-contents__link toc-highlight">Traditional monitoring tools</a><ul><li><a href="#metrics" class="table-of-contents__link toc-highlight">Metrics</a></li><li><a href="#logs" class="table-of-contents__link toc-highlight">Logs</a></li></ul></li><li><a href="#distributed-tracing" class="table-of-contents__link toc-highlight">Distributed tracing</a></li><li><a href="#important-concepts" class="table-of-contents__link toc-highlight">Important Concepts</a><ul><li><a href="#span" class="table-of-contents__link toc-highlight">Span</a></li><li><a href="#tracer" class="table-of-contents__link toc-highlight">Tracer</a></li></ul></li><li><a href="#fundamentals" class="table-of-contents__link toc-highlight">Fundamentals</a><ul><li><a href="#request-correlation" class="table-of-contents__link toc-highlight">Request correlation</a></li><li><a href="#anatomy-of-distributed-tracing" class="table-of-contents__link toc-highlight">Anatomy of distributed tracing</a></li><li><a href="#trace-models" class="table-of-contents__link toc-highlight">Trace models</a></li><li><a href="#clock-skew-adjustment" class="table-of-contents__link toc-highlight">Clock skew adjustment</a></li><li><a href="#styles-of-instrumentation" class="table-of-contents__link toc-highlight">Styles of instrumentation</a></li></ul></li><li><a href="#instrumentation-quality-checklist" class="table-of-contents__link toc-highlight">Instrumentation Quality Checklist</a><ul><li><a href="#span-status-and-creation" class="table-of-contents__link toc-highlight">Span Status and Creation</a></li><li><a href="#span-boundaries" class="table-of-contents__link toc-highlight">Span Boundaries</a></li><li><a href="#attributes" class="table-of-contents__link toc-highlight">Attributes</a></li><li><a href="#events" class="table-of-contents__link toc-highlight">Events</a></li></ul></li><li><a href="#tracing-in-service-meshes" class="table-of-contents__link toc-highlight">Tracing in Service meshes</a><ul><li><a href="#observability-via-a-service-mesh" class="table-of-contents__link toc-highlight">Observability via a service mesh</a></li><li><a href="#front-service-telemetry" class="table-of-contents__link toc-highlight">Front service telemetry</a></li></ul></li><li><a href="#sampling-trace" class="table-of-contents__link toc-highlight">Sampling trace</a><ul><li><a href="#head-based-consistent-sampling" class="table-of-contents__link toc-highlight">Head-based consistent sampling</a></li><li><a href="#tail-based-consistent-sampling" class="table-of-contents__link toc-highlight">Tail-based consistent sampling</a></li></ul></li><li><a href="#architecture-and-deployment-modes" class="table-of-contents__link toc-highlight">Architecture and deployment modes</a><ul><li><a href="#basic-architecture-agent--collector--query-service" class="table-of-contents__link toc-highlight">Basic architecture: agent + collector + query service</a></li><li><a href="#streaming-architecture" class="table-of-contents__link toc-highlight">Streaming architecture</a></li></ul></li><li><a href="#references" class="table-of-contents__link toc-highlight">References</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Repositories</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/AkatQuas/kiddo-plays" target="_blank" rel="noopener noreferrer" class="footer__link-item">Kiddo plays<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/AkatQuas/nprogresse" target="_blank" rel="noopener noreferrer" class="footer__link-item">NProgressE<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/AkatQuas" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Links</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/AkatQuas" target="_blank" rel="noopener noreferrer" class="footer__link-item">Who would it be?<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 AkatQuas. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.5d758bff.js"></script>
<script src="/assets/js/main.6f4b5c91.js"></script>
</body>
</html>