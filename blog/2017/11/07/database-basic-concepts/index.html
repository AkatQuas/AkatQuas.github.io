<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">从集合的角度理解数据库 | AkatQuas&#x27;s blog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://akatquas.github.io/blog/2017/11/07/database-basic-concepts"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="从集合的角度理解数据库 | AkatQuas&#x27;s blog"><meta data-rh="true" name="description" content="“关系”的概念与关系的集合论定义是紧密相关的。"><meta data-rh="true" property="og:description" content="“关系”的概念与关系的集合论定义是紧密相关的。"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2017-11-07T00:00:00.000Z"><link data-rh="true" rel="icon" href="/images/favicon.ico"><link data-rh="true" rel="canonical" href="https://akatquas.github.io/blog/2017/11/07/database-basic-concepts"><link data-rh="true" rel="alternate" href="https://akatquas.github.io/blog/2017/11/07/database-basic-concepts" hreflang="en"><link data-rh="true" rel="alternate" href="https://akatquas.github.io/blog/2017/11/07/database-basic-concepts" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="AkatQuas&#39;s blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="AkatQuas&#39;s blog Atom Feed"><link rel="stylesheet" href="/assets/css/styles.d30c7ca7.css">
<link rel="preload" href="/assets/js/runtime~main.5d758bff.js" as="script">
<link rel="preload" href="/assets/js/main.6f4b5c91.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/images/logo.svg" alt="AkatQuas" class="themedImage_ToTc themedImage--light_HNdA"><img src="/images/logo.svg" alt="AkatQuas" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">AkatQuas 🔭</b></a><a class="navbar__item navbar__link" href="/docs/about">Topic</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://akatquas.github.io/dateless/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Dateless<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a href="https://github.com/AkatQuas/AkatQuas.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/11/23/excerpt-on-unit-test">单元测试的实践</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/06/11/design-a-cli-tool">设计一个 CLI 工具</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/05/30/architecture-design-imo">架构设计的一些哲学经验</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/05/09/electron-application-architecture">Electron 应用的理想架构设计</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/04/type-vs-interface">Type vs Interface</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">从集合的角度理解数据库</h1><div class="container_mt6G margin-vert--md"><time datetime="2017-11-07T00:00:00.000Z" itemprop="datePublished">November 7, 2017</time> · <!-- -->21 min read</div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>“关系”的概念与关系的集合论定义是紧密相关的。</p><p>关系也是元组的集合，表中各行（也称 <em>元组</em> ）排列的次序不重要。</p><p>每一行的各个组分（也称 <em>属性</em> ）的次序很关键。</p><p>一张关系表包含两个方面：</p><ol><li>列名的集合（属性集合）</li><li>包含信息的行（信息元组）</li></ol><p>第 1 项，属性的集合也被称为关系的模式（scheme）。</p><h1>数据库</h1><p>关系的集合称为数据库。</p><p>数据库中各关系的模式组成的集合就是数据库的模式。要注意数据库模式（它告诉我们与数据库中信息组织方式有关的信息）与各关系中元组的集合（数据库中存储的实际信息）之间的区别。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="查询基本操作">查询基本操作<a class="hash-link" href="#查询基本操作" title="Direct link to heading">​</a></h2><ol><li><code>insert(t,R)</code>。如果元组 t 尚未出现在关系 R 中，就将它添加到 R 中。该操作与词典或二元关系的 <em>插入</em> 操作有着相同的精神。</li><li><code>delete(X,R)</code>。在这里，X 是某些元组的规范。它是由对应 R 各属性的组分组成的，每个组分都会是下面两者之一。<ul><li>一个值。</li><li>符号<!-- -->*<!-- -->，表示可以接受任意值。该操作的效果是删除满足规范 X 的所有元组。</li></ul></li><li><code>lookup(X,R)</code>。该操作的结果是得到 R 中匹配规范 X 的元组形成的集合，X 是个象征性的元组，就跟第(2)项中描述的一样。</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="表示关系的数据结构的设计">表示关系的数据结构的设计<a class="hash-link" href="#表示关系的数据结构的设计" title="Direct link to heading">​</a></h2><blockquote><p>在使用关系数据模型时，如何选择合适的数据库模式很重要</p><ol><li>如果将两个独立类型的信息结合成一个关系模式，就可能被迫多次重复同样的数据事实。</li><li>在属性表示相互联系的信息时，不要把它们分开。</li></ol></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="键">键<a class="hash-link" href="#键" title="Direct link to heading">​</a></h2><p>很多数据库关系可被视作从某些属性的集合到其余属性的函数。因为函数的数据结构比一般关系的数据结构要简单一些，所以如果知道可以作为函数定义域的属性集合是比较好的。这样的属性集合被称作 <em>键</em> 。</p><p>关系的 <em>键</em> 是一项或多项属性的集合，满足”在任何情况下，以键属性为标题的列中不会出现相同的值“。</p><blockquote><p>选择合适的键</p><ol><li>不能只靠观察关系的几个示例就确定键。</li><li>不存在所谓的“正确的键”的选择，选择什么属性作为键，取决于对关系所含数据的类型作出的假设。</li></ol></blockquote><h1>关系的主要存储结构</h1><p>这里有一些可用于表示关系的结构。</p><ol><li>二叉查找树，在定义域值上有“小于”关系以安排元组的位置，可以用来促进指定了定义域值的操作。</li><li>以定义域值作为数组索引，用特征向量的数组。</li><li>散列定义域值以找到散列表元的散列表。</li><li>原则上看，元组组成的链表是一种候选结构，但是它对任何类型的操作都没有促进作用。</li></ol><p>当关系不是二元关系时，同样的结构也是可以使用的。定义域不再只有单个属性，而是可能结合 k 个属性，称为 <em>定义域属性</em> ，或在明确所指的属性集合时，直接称为 <em>定义域</em> 。此时，定义域的值就是 k 元组，各组分对应定义域的各属性。而 <em>值域属性</em> 是指哪些定义域属性以外的属性，可以有多个组分。</p><p>一般而言，必须选出想要作为定义域的那些属性。简单情形，对于具有一个或少量属性作为关系的键的情况，直接拿键属性作为定义域即可，其余属性作为值域。没有键时，可以选择任意属性集合作为定义域。</p><p>一旦选择了定义域，就可以从上述提到的 4 种数据结构中任选其一表示该关系，或者其实也可以选择另一种结构。不过，通常会选择以定义域值作为索引的散列表，而且一般都会这么做。</p><p>所选的结构就称为该关系的 <em>主索引结构</em> 。形容词“主”表示元组的位置是由该结构确定的。 <em>索引</em> 是在给定所需要的 组的一个或多个组分的情况下协助找到元组的数据结构。</p><blockquote><p>主索引的选择</p><ol><li>将关系模式的键作为函数的定义域，将其余属性作为值域通常是很实用的。</li><li>如果最常见的查询所指定的是不构成键的属性的值，就可能要选用该属性集合作为定义域，将其余属性作为值域。</li><li>主索引结构定义域的选择可能对执行“常规”查询速度有着最大的影响。</li></ol></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="主索引为散列表的插入删除查找">主索引为散列表的插入、删除、查找<a class="hash-link" href="#主索引为散列表的插入删除查找" title="Direct link to heading">​</a></h2><p>把注意力放在作为主索引结构的散列表上。如果操作指定了定义域的值，那么就要散列该值以找到散列表元。</p><ol><li>插入元组 t，就要检查相应的散列表元，看看 t 是否已经位列其中，如果没有就在该散列表元对应的链表中新建新单元来容纳 t。</li><li>要删除匹配规范 X 的元组，就要根据据 X 找出定义域值，进行散列以得出相应的散列表元，然后沿着该散列表元对应的链表向下查找，将匹配规范 X 的各元组都删除。</li><li>要根据规范 X 查找元组，还是要从 X 找到定义域值，进行散列以得出相应的散列表元。沿着对应该散列表元的链表向下查找，将链表中匹配规范 X 的各元组分别作为回应生成。</li></ol><p>如果操作没有指定定义域值，就不会这么走运了。插入操作就总是要完整地指定被插入的元组，而删除或查找操作可能不能这样。在那样的情况下，必须对所有的散列表元列表进行查找，找到匹配的元组，并分别删除或列出它们。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="辅助索引">辅助索引<a class="hash-link" href="#辅助索引" title="Direct link to heading">​</a></h2><p>可以在给定某一属性或某些属性的值的情况下找到元组，但不能用来在整个结构中放置元组的数据结构，就是 <em>辅助索引</em> 。</p><p>一般而言，关系 R 属性 A 上的 <em>辅助索引</em> 是满足以下条件的有序对(v, p)的集合。</p><ol><li>v 是属性 A 的值。</li><li>p 是指向关系 R 主索引结构中某个元组的指针，该元组的“A”组分的值为 v。</li></ol><p>对属性 A 的值为 v 的各元组来说，辅助索引都有对应的有序对。</p><p>可以使用表示二元关系的任意数据结构来存储辅助索引。通常会期望使用基于属性 A 的值的散列表。只要散列表元的数量不大于属性 A 不同值的数量，在给定所需的 v 值的情况下，在散列表中查找有序对(v, p)通常都可以预期不错的性能，也就是平均 O(n/B)的时间。这里的 n 是有序对的数量，而 B 是散列表元的数量。</p><blockquote><p>创建辅助索引如果元组的一个或多个组分的值已经给定，辅助索引的存在通常会让查找元组的工作变得更加容易。补过还要考虑：</p><ol><li>所创建的每个辅助索引都会让我们在关系中插入或删除信息时花费额外的时间。<ul><li>插入。如果要插入一个新元组，其对应属性 A 的组分的值为 v，就必须创建有序对(v,p)，其中 p 是指向主结构中新记录的指针。然后，再把有序对(v,p)插入到辅助索引中。</li><li>删除。要删除对应 A 的组分的值为 v 的元组时，首先一定要记得已经删除了指向该元组的指针，比方说是 p。然后，要深入辅助索引结构，并检查所有第一个组分为 v 的有序对，直到从其中找出第二个组分为 p 的有序对为止。然后将该有序对从辅助索引结构中删除。</li></ul></li><li>只为那些可能需要查找数据的属性构建辅助索引。</li></ol></blockquote><h1>关系间的导航</h1><p>关系的导航就是从一个关系跳转到另一个关系的操作。</p><p>索引的建立不仅仅在使得在本关系中的查询操作变得简单，也使得导航的操作变得简单。</p><h1>关系代数</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="操作数">操作数<a class="hash-link" href="#操作数" title="Direct link to heading">​</a></h2><p>在关系代数中，所有的操作数都是关系，可以时常量，也可以是未知量。每个操作数都有特定的模式（即关系中的列命名的属性的集合）。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="集合运算符">集合运算符<a class="hash-link" href="#集合运算符" title="Direct link to heading">​</a></h2><p>3 种常见的集合运算：并、交、差。使用这些运算符的操作数的模式一定要相同，这样结果的模式自然是这两个参数的模式。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="选择运算符">选择运算符<a class="hash-link" href="#选择运算符" title="Direct link to heading">​</a></h2><p>从关系中提取某些条件的元组，可以使用 <em>选择</em> 运算符，记作 σ<sub>C</sub>(R)，C 是条件，R 是关系操作数。</p><p>选择运算的结果是模式与 R 的模式相同的关系。把在将条件 C 中的属性 A 替换为元组 t 对应列 A 的组分时使得条件 C 为真的每个元组 t 都放入该关系中。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="投影运算符">投影运算符<a class="hash-link" href="#投影运算符" title="Direct link to heading">​</a></h2><p>选择运算符会生成某关系删除若干行之后的副本，为了得到关系删除若干列（属性）的副本，可以使用 <em>投影</em> 运算符，记作 π<sub>B<sub>1</sub>,...B<sub>n</sub></sub>(R)，表示关系 R 在属性 B<sub>1</sub>,...B<sub>n</sub>上的投影。</p><p>取 R 中的元组 t，提取其属性 B<sub>1</sub>,...B<sub>n</sub>中的组分，可能存在多个元组得到相同的投影，此时，只会有一个副本会进入到中 π<sub>B<sub>1</sub>,...B<sub>n</sub></sub>(R)。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="关系的联接">关系的联接<a class="hash-link" href="#关系的联接" title="Direct link to heading">​</a></h2><p>用来表示两个关系被关联起来，从而可以从一个关系向另一个关系导航的概念。假设有两个关系 R 和 S，其属性集合（模式，scheme）分别是{A<sub>1</sub>,...A<sub>m</sub>}，{B<sub>1</sub>,...B<sub>n</sub>}。要从两个集合中各选出一些属性，而把这些属性成为以 R 和 S 为参数的 <em>联接</em> 运算的参数。</p><p>就要从 R 中取出各元组 r，从 S 中取出各元组 s 加以比较。如果其中的属性满足联接运算的条件，那么 r 和 s 就形成了一个元组（要剔除相同的组分）。如果属性名相同，但是属性意义不相同，需要重命名其中某个属性。</p><h1>关系代数运算的实现</h1><p>介绍一些常见而又相对简单的关系代数运算的实现策略。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="交并差">交、并、差<a class="hash-link" href="#交并差" title="Direct link to heading">​</a></h2><p>可以先排序，后合并，再进行并、交、差的运算。</p><p>如果参加运算的两个关系 R 与 S 各含 n 个元组，就要花 O(n log n)的时间为其排序并用 O(n)的时间合并，总共需要的时间为 O(n log n)。</p><p>还有别的方式。</p><ol><li><p>首先不去考虑为同时出现在 R 和 S 中的元组消除重复副本的事情，重复的元组可能性比较小而且也许重复不是个问题。或者在后续的阶段中消除重复会更加方便。</p></li><li><p>使用索引。例如 R 具有属性 A 上的索引，而该属性时 S 的键。那么要取二者的并集 R ∪ S，可以首先从 S 的元组开始，并依次检查 R 的每个元组 t。会在组分 A 中找到 t 的值，并使用该索引查找 S 中 A 组分的值相同的元组。如果 S 中的这一元组与 t 相同，就不要再将 t 第二次放入该并集中，相反的，如果 S 中不存在键的值与 t 中组分 A 相同的元组，或者键值相同但是元组不相同，则就要将 t 放入并集中。</p></li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="投影运算的实现">投影运算的实现<a class="hash-link" href="#投影运算的实现" title="Direct link to heading">​</a></h2><p>原则上讲，在执行投影运算时，只能检验完每个元组，并略去那些与未出现在投影列表中的属性对应的组分。索引是一点忙都帮不上的。此外，在计算了各元组的投影后，可能发现会留下很多重复的元组。于是必须要消除重复！消除重复有两种：</p><ul><li>将结果关系进行排序，次序上与前一个元组相同的元组都要被删除</li><li>用集合（比如散列表）去存储结果关系，这样就可以避免插入重复元组。</li></ul><p>如果关系 R 中有 n 个元组，那么要消除重复前为关系 S 排序所需的时间为 O(n log n)。使用散列表则整个投影运算平均要花 O(n)的时间，散列略优于排序。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="选择运算的实现">选择运算的实现<a class="hash-link" href="#选择运算的实现" title="Direct link to heading">​</a></h2><p>当关系 R 没有使用索引时，则必须要检查 R 中所有元组，才能得到结果关系 S。</p><p>当 R 中使用了索引，则可以利用索引来直接找到满足条件 C 的元组，会节省很多时间。</p><p>当条件中同时使用了索引和非索引，可以先利用执行索引条件，得到初筛，然后对初筛进行遍历，以得到满足剩余条件的元组。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="联接的实现">联接的实现<a class="hash-link" href="#联接的实现" title="Direct link to heading">​</a></h2><p>假设想要对模式为{A,B}的关系 R 和模式为{B,C}的关系 S 进行自然联接，并假设该联接时两个关系的 B 属性之间存在相等关系的自然联接。</p><p>直观而又缓慢的方式就是暴力地分别遍历两个关系，称作 <em>嵌套循环联接</em> ，寻找其中 B 属性相同的元组。</p><p>一种高效的联接方式是使用索引。假设 S 有属性 B 上的索引，则可以先遍历 R 的各元组，并在 S 的索引中查找匹配的元组。进一步的，S 和 R 在属性 B 上都有索引，则可以任选其一来用。</p><p>如果两者在属性 B 上不存在索引，利用 <em>排序联接</em> 还是能比 <em>嵌套循环联接</em> 做的更好。先将 R 和 S 的元组合并在一起，重新组合时，B 祖坟成为所有元组的第一个组分，并加上额外的组分来区分合并后的元组时来自于 R 还是 S。合并完成后根据 B 组分进行排序，再沿着排序表向下遍历，寻找具有相同 B 组分的来自 R 和 S 的组分进行联接，生成联接后关系中元组所花时间时与生成元组数成比例的。</p><h1>关系的代数法则</h1><p>对表达式进行等价变形，可以优化表达式，即优化查询过程。</p><p>因为一般而言当运算应用到较小的关系上时所花的时间较少，所以尽可能早地应用选择运算是极为有利的。从代数的角度来看，如果想早点应用选择运算，可以使用代数法则让选择运算符沿着表达式树向下传递，进行下压操作。</p><p>至于涉及投影操作，投影不能像选择操作一样可以被压倒并、差、交之下，投影只能压到并集之下。</p><blockquote><p>摘抄自《计算机科学基础》，对数据库的描述并不详尽，比如 SQL 语句就没有介绍，因此更多内容可参见《数据库系统基础教程》Jeffrey D. Ullman, Jennifer Widom 的版本。</p></blockquote></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/2017/12/04/angular"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">The ONLY Framework Angular</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/2017/03/07/hello-world"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Hello World</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#查询基本操作" class="table-of-contents__link toc-highlight">查询基本操作</a></li><li><a href="#表示关系的数据结构的设计" class="table-of-contents__link toc-highlight">表示关系的数据结构的设计</a></li><li><a href="#键" class="table-of-contents__link toc-highlight">键</a></li><li><a href="#主索引为散列表的插入删除查找" class="table-of-contents__link toc-highlight">主索引为散列表的插入、删除、查找</a></li><li><a href="#辅助索引" class="table-of-contents__link toc-highlight">辅助索引</a></li><li><a href="#操作数" class="table-of-contents__link toc-highlight">操作数</a></li><li><a href="#集合运算符" class="table-of-contents__link toc-highlight">集合运算符</a></li><li><a href="#选择运算符" class="table-of-contents__link toc-highlight">选择运算符</a></li><li><a href="#投影运算符" class="table-of-contents__link toc-highlight">投影运算符</a></li><li><a href="#关系的联接" class="table-of-contents__link toc-highlight">关系的联接</a></li><li><a href="#交并差" class="table-of-contents__link toc-highlight">交、并、差</a></li><li><a href="#投影运算的实现" class="table-of-contents__link toc-highlight">投影运算的实现</a></li><li><a href="#选择运算的实现" class="table-of-contents__link toc-highlight">选择运算的实现</a></li><li><a href="#联接的实现" class="table-of-contents__link toc-highlight">联接的实现</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Repositories</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/AkatQuas/kiddo-plays" target="_blank" rel="noopener noreferrer" class="footer__link-item">Kiddo plays<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/AkatQuas/nprogresse" target="_blank" rel="noopener noreferrer" class="footer__link-item">NProgressE<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/AkatQuas" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Links</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/AkatQuas" target="_blank" rel="noopener noreferrer" class="footer__link-item">Who would it be?<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 AkatQuas. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.5d758bff.js"></script>
<script src="/assets/js/main.6f4b5c91.js"></script>
</body>
</html>