<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-sicp/computing-with-register-machines">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">Computing with Register Machines | AkatQuas&#x27;s blog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://akatquas.github.io/docs/sicp/computing-with-register-machines"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Computing with Register Machines | AkatQuas&#x27;s blog"><meta data-rh="true" name="description" content="In this chapter we will describe processes in terms of the step-by-step operation of a traditional computer. Such a computer, or register machine, sequentially executes instructions that manipulate the contents of a fixed set of storage elements called registers."><meta data-rh="true" property="og:description" content="In this chapter we will describe processes in terms of the step-by-step operation of a traditional computer. Such a computer, or register machine, sequentially executes instructions that manipulate the contents of a fixed set of storage elements called registers."><link data-rh="true" rel="icon" href="/images/favicon.ico"><link data-rh="true" rel="canonical" href="https://akatquas.github.io/docs/sicp/computing-with-register-machines"><link data-rh="true" rel="alternate" href="https://akatquas.github.io/docs/sicp/computing-with-register-machines" hreflang="en"><link data-rh="true" rel="alternate" href="https://akatquas.github.io/docs/sicp/computing-with-register-machines" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="AkatQuas&#39;s blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="AkatQuas&#39;s blog Atom Feed"><link rel="stylesheet" href="/assets/css/styles.d30c7ca7.css">
<link rel="preload" href="/assets/js/runtime~main.5d758bff.js" as="script">
<link rel="preload" href="/assets/js/main.6f4b5c91.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/images/logo.svg" alt="AkatQuas" class="themedImage_ToTc themedImage--light_HNdA"><img src="/images/logo.svg" alt="AkatQuas" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">AkatQuas ðŸ”­</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/about">Topic</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://akatquas.github.io/dateless/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Dateless<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a href="https://github.com/AkatQuas/AkatQuas.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/about">Akat</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/network-top-down-approach/">Computer Network</a><button aria-label="Toggle the collapsible sidebar category &#x27;Computer Network&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/data-structure/">Data Structure</a><button aria-label="Toggle the collapsible sidebar category &#x27;Data Structure&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/compiler/">Compiler</a><button aria-label="Toggle the collapsible sidebar category &#x27;Compiler&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/interpreter-in-js/">Writing a interpreter in JavaScript</a><button aria-label="Toggle the collapsible sidebar category &#x27;Writing a interpreter in JavaScript&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/lisp-interpreter-in-c/index">Build Your Own Lisp Interpreter in C</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/lisp-interpreter-in-py/chapter-00">Build A Lisp Interpreter in Python</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/sicp/index">SICP</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sicp/index">Structure and Interpretation of Computer Programs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sicp/building-abstractions-with-procedures">Building Abstractions with Procedures</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sicp/building-abstractions-with-data">Building Abstractions with Data</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sicp/modularity-objects-state">Modularity, Objects, and State</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/sicp/metalinguistic-abstraction">Metalinguistic Abstraction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/sicp/computing-with-register-machines">Computing with Register Machines</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/concurrency-in-go/">Concurrency in Go</a><button aria-label="Toggle the collapsible sidebar category &#x27;Concurrency in Go&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/docker/">Docker</a><button aria-label="Toggle the collapsible sidebar category &#x27;Docker&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/kubernetes/">Kubernetes</a><button aria-label="Toggle the collapsible sidebar category &#x27;Kubernetes&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">SICP</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Computing with Register Machines</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Computing with Register Machines</h1></header><p>In this chapter we will describe processes in terms of the step-by-step operation of a traditional computer. Such a computer, or <em>register machine</em>, sequentially executes <em>instructions</em> that manipulate the contents of a fixed set of storage elements called <em>registers</em>.</p><p>A typical register machine instruction applies a primitive operation to the contents of some registers and assigns the result to another register. The descriptions of processes executed by register machines will look very much like <em>machine-language</em> programs for traditional computers.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="designing-register-machines">Designing Register Machines<a class="hash-link" href="#designing-register-machines" title="Direct link to heading">â€‹</a></h2><p>To design a register machine, we must design its <em>data paths</em> (registers and operations) and the <em>controller</em> that sequences these operations.</p><p>An operation that computes a value from constants and the contents of registers is represented in a data-path diagram by a trapezoid containing a name for the operation.</p><p>Overall, the data-path diagram shows the registers and operations that are required for the machine and how they must be connected.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="a-language-for-describing-register-machines">A Language for Describing Register Machines<a class="hash-link" href="#a-language-for-describing-register-machines" title="Direct link to heading">â€‹</a></h3><p>To make it possible to deal with complex machines, we will create a language that presents, in textual form, all the information given by the data-path and controller diagrams.</p><p>We define the data paths of a machine by describing the registers and the operations:</p><ul><li><p>To describe a register, we give it a name and specify the buttons that control assignment to it. We give each of the buttons a name and specify the source of the data that enters the register under the button&#x27;s control. (The source is a register, a constant, or an operation.)</p></li><li><p>To describe an operation, we give it a name and specify its inputs (registers or constants).</p></li></ul><p>We define the controller of a machine as a sequence of <em>instructions</em> together with <em>labels</em> that identify <em>entry points</em> in the sequence. An instruction is one of the following:</p><ul><li><p>The name of a data-path button to push to assign a value to a register.</p></li><li><p>A <em>test</em> instruction to perform a specified test, or assertion.</p></li><li><p>A conditional branch to location indicated by a controller label, based on the result of the previous test. If the test is false, the controller should continue with the next instruction in the sequence. Otherwise, the controller should continue with the instruction after the label.</p></li></ul><p>The machine starts at the beginning of the controller instruction sequence and stops when execution reaches the end of the sequence. Except when a branch changes the flow of control, instructions are executed in the order in which they are listed.</p><p>Unfortunately, it is difficult to read such a description. In order to understand the controller instructions we must constantly refer back to the definitions of the button names and the operation names, and to understand what the buttons do we may have to refer to the definitions of the operation names. We will thus transform our notation to combine the information from the data-path and controller descriptions so that we see it all together.</p><p>We will omit the data-path description, leaving only the controller sequence.</p><p>This form of description is easier to read, but it also has disadvantages:</p><ul><li><p>It is more verbose for large machines, because complete descriptions of the data-path elements are repeated whenever the elements are mentioned in the controller instruction sequence. Moreover, repeating the data-path descriptions obscures the actual data-path structure of the machine; it is not obvious for a large machine how many registers, operations, and buttons there are how they are interconnected.</p></li><li><p>Because the controller instructions in a machine definition look like Lisp expressions, it is easy to forget that they are not arbitrary Lisp expressions. They can notate only legal machine operations. For example, operations can operate directly only on constants and the contents of registers, not on the results of other operations.</p></li></ul><p>In spite of these disadvantages, we will use this register-machine language throughout this chapter, because we will be more concerned with understanding controllers than with understanding the elements and connections in data paths.</p><blockquote><p>However, that data-path design is crucial in designing real machines.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="abstraction-in-machine-design">Abstraction in Machine Design<a class="hash-link" href="#abstraction-in-machine-design" title="Direct link to heading">â€‹</a></h3><p>We will often define a machine to include <em>primitive</em> operations that are actually very complex. The fact that we have swept a lot of complexity under the rug, however, does not mean that a machine design is unrealistic. We can always replace the complex <em>primitives</em> by simpler primitive operations.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="subroutines">Subroutines<a class="hash-link" href="#subroutines" title="Direct link to heading">â€‹</a></h3><p>When designing a machine to perform a computation, we would often prefer to arrange for components to be shared by different parts of the computation rather than duplicate the components.</p><blockquote><p>Something looks like interrupts, sub-procedure invocation, etc.</p></blockquote><blockquote><p>This might be useful in compiler optimization.</p></blockquote><p>A more powerful method for implementing subroutines is to have the continue register hold the label of the entry point in the controller sequence at which execution should continue when the subroutine is finished. Implementing this strategy requires a new kind of connection between the data paths and the controller of a register machine: there must be a way to assign to a register a label in the controller sequence in such a way that this value can be fetched from the register and used to continue execution at the designated entry point. However, it might lead to some problem if we assign different value to the same continue register in every subroutine, just think about nested subroutine calls, which is recursion.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="using-a-stack-to-implement-recursion">Using a Stack to Implement Recursion<a class="hash-link" href="#using-a-stack-to-implement-recursion" title="Direct link to heading">â€‹</a></h3><p>With the ideas illustrated so far, we can implement any iterative process by specifying a register machine that has a register corresponding to each state variable of the process. The machine repeatedly executes a controller loop, changing the contents of the registers, until some termination condition is satisfied. At each point in the controller sequence, the state of the machine (representing the state of the iterative process) is completely determined by the contents of the registers (the values of the state variables).</p><p>Implementing recursive processes, however, requires an additional mechanism.</p><p>Nevertheless, we can implement the recursive process as a register machine if we can arrange to use the same components for each nested instance of the machine. This is plausible because, <em>although the recursive process dictates that an unbounded number of copies of the same machine are needed to perform a computation, only one of these copies needs to be active at any given time</em>. So when the machine encounters a recursive subproblem, it can suspend work on the main problem, reuse the same physical parts to work on the subproblem, then continue the suspended computation.</p><p>In the subproblem, the contents of the registers will be different from they were in the main problem. (In this case the n register is decremented.) In order to be able to continue the suspended computation, the machine must save the contents of any registers that will be needed after the subproblem is solved so that these can be restored to continue the suspended computation.</p><p>Since there is no a <em>priori</em> limit on the depth of nested recursive calls, we may need to save an arbitrary number of register values. These values must be restored in the reverse of the order in which they were saved, since in a nest of recursions the last subproblem to be entered is the first to be finished.</p><p>This dictates the use of a stack, or <em>last in, first out</em> data structure, to save register values. We can extend the register-machine language to include a stack by adding two kinds of instructions: Values are placed on the stack using a <code>save</code> instruction and restored from the stack using a <code>restore</code> instruction. After a sequence of values has been <code>saved</code> on the stack, a sequence of <code>restores</code> will retrieve these values in reverse order.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="a-register-machine-simulator">A Register-Machine Simulator<a class="hash-link" href="#a-register-machine-simulator" title="Direct link to heading">â€‹</a></h2><p>The simulator is a Scheme program with four interface procedures. The first uses a description of a register machine to construct a model of the machine (a data structure whose parts correspond to the parts of the machine to be simulated), and the other three allow us to simulate the machine by manipulating the model:</p><ul><li><p><code>(make-machine âŸ¨register-namesâŸ© âŸ¨operationsâŸ© âŸ¨controllerâŸ©)</code> constructs and returns a model of the machine with the given registers, operations, and controller.</p></li><li><p><code>(set-register-contents! âŸ¨machine-modelâŸ© âŸ¨register-nameâŸ© âŸ¨valueâŸ©)</code> stores a value in a simulated register in the given machine.</p></li><li><p><code>(get-register-contents âŸ¨machine-modelâŸ© âŸ¨register-nameâŸ©)</code> returns the contents of a simulated register in the given machine.</p></li><li><p><code>(start âŸ¨machine-modelâŸ©)</code> simulates the execution of the given machine, starting from the beginning of the controller sequence and stopping when it reaches the end of the sequence.</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-machine-model">The Machine Model<a class="hash-link" href="#the-machine-model" title="Direct link to heading">â€‹</a></h3><p>To build this model, <code>make-machine</code> begins by calling the procedure <code>make-new-machine</code> to construct the parts of the machine model that are common to all register machines. This basic machine model constructed by <code>make-new-machine</code> is essentially a container for <em>some registers</em> and <em>a stack</em>, together with <em>an execution mechanism</em> that processes the controller instructions one by one.</p><p><code>make-machine</code> then extends this basic model (by sending it messages) to include the registers, operations, and controller of the particular machine being defined. First it allocates a register in the new machine for each of the supplied register names and installs the designated operations in the machine. Then it uses an <em>assembler</em> to transform the controller list into instructions for the new machine and installs these as the machineâ€™s instruction sequence. <code>make-machine</code> returns as its value the modified machine model.</p><p><strong>Registers</strong></p><p>Register would be a procedure with local state, which is used to hold a value that can be accessed or changed.</p><p><strong>The stack</strong></p><p>Stack would be a procedure with local state, whose local state consists of a list of the items on the stack.</p><p>A stack accepts requests to <code>push</code> and item onto the stack, to <code>pop</code> the top item off the stack and return it, and to <code>initialize</code> the stack to empty.</p><p><strong>The basic machine</strong></p><p>The <code>make-new-machine</code> procedure constructs an object whose local state consists of a stack, an initially empty instruction sequence, a list of operations that initially contains an operation to initialize the stack, and a register table that initially contains two registers, named <code>flag</code> and <code>pc</code> (for <em>program counter</em>).</p><p>The internal procedure <code>allocate-register</code> adds new entries to the register table, and the internal procedure <code>lookup-register</code> looks up registers in the table.</p><p>The <code>flag</code> register is used to control branching in the simulated machine.</p><p>The <code>pc</code> register determines the sequencing of instructions as the machine runs. In the simulation model, each machine instruction is a data structure that includes a procedure of no arguments, called the <code>instruction execution procedure</code>, such that calling this procedure simulates executing the instruction. As the simulation runs, <code>pc</code> points to the place in the instruction sequence beginning with the next instruction to be executed. <code>execute</code> gets that instruction, executes it by calling the instruction execution procedure, and repeats this cycle until there are no more instructions to execute.</p><p>Notice that starting the machine is accomplished by setting <code>pc</code> to the beginning of the instruction sequence and calling <code>execute</code>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-assembler">The Assembler<a class="hash-link" href="#the-assembler" title="Direct link to heading">â€‹</a></h3><p>The assembler transforms the sequence of controller expressions for a machine into a corresponding list of machine instructions, each with its execution procedure.</p><p>To speed up the execution procedure, we could separate the analysis from runtime execution, aka AOT compilation.</p><p>Before it can generate the instruction execution procedures, the assembler must know what all the labels refer to, so it begins by scanning the controller text to separate the labels from the instructions. As it scans the text, it constructs both a list of instructions and a table that associates each label with a pointer into that list. Then the assembler augments the instruction list by inserting the execution procedure for each instruction.</p><p>The machine instruction data structure simply pairs the instruction text with the corresponding execution procedure.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="generating-execution-procedures-for-instructions">Generating Execution Procedures for Instructions<a class="hash-link" href="#generating-execution-procedures-for-instructions" title="Direct link to heading">â€‹</a></h3><p>The assembler calls <code>make-execution-procedure</code> to generate the execution procedure for an instruction. This dispatches on the type of instruction to generate the appropriate execution procedure.</p><p>For each type of instruction in the register-machine language, there is a generator that builds an appropriate execution procedure. The details of these procedures determine both the syntax and meaning of the individual instructions in the register-machine language.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="monitoring-machine-performance">Monitoring Machine Performance<a class="hash-link" href="#monitoring-machine-performance" title="Direct link to heading">â€‹</a></h3><p>Simulation is useful not only for verifying the correctness of a proposed machine design but also for measuring the machine&#x27;s performance.</p><p>To do this, we modify our simulated stack to keep track of the number of times registers are saved on the stack and the maximum depth reached by the stack, and add a message to the stack&#x27;s interface that prints the statistics.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="storage-allocation-and-garbage-collection">Storage Allocation and Garbage Collection<a class="hash-link" href="#storage-allocation-and-garbage-collection" title="Direct link to heading">â€‹</a></h2><p>We will assume that our register machines can be equipped with a <em>list-structured memory</em>, in which the basic operations for manipulating list-structured data are primitive.</p><p>There are two considerations in implementation list structure.</p><ul><li><p>how to represent the <em>box-and-pointer</em> structure of Lisp pairs, using only the storage and addressing capabilities of typical computer memories</p></li><li><p>the management of memory as the computation proceeds, such as storage allocation and recycling.</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="memory-as-vectors">Memory as Vectors<a class="hash-link" href="#memory-as-vectors" title="Direct link to heading">â€‹</a></h3><p>A conventional computer memory can be thought of as an array of cubbyholes, each of which can contain a piece of information. Each cubbyhole has a unique name, called its <em>address</em> or <em>location</em>.</p><p>Typical memory systems provide two primitive operations: one that fetches the data stored in a specified location and one that assigns new data to a specified location. Memory addresses can be incremented to support sequential access to some set of the cubbyholes. More generally, many important data operations require that memory addresses be treated as data, which can be stored in memory locations and manipulated in machine registers. The representation of list structure is one application of such <em>address arithmetic</em>.</p><p>To model computer memory, we use a new kind of data structure called <em>vector</em>.</p><p>Abstractly, a vector is a compound data object whose individual elements can be accessed by means of an integer index in an amount of time that is independent of the index.</p><p>For computer memory, this access can be implemented through the use of address arithmetic to combine a <em>base address</em> that specifies the beginning location of a vector in memory with an <em>index</em> that specifies the offset of a particular element of the vector.</p><p>We also need a representation for objects and a way to distinguish one kind of data from another. There are many methods of accomplishing this, but they all reduce to using <em>typed pointers</em>, that is, to extending the notion of pointer to include information on data type. Two data objects are considered to be the same if their pointers are identical.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="maintaining-the-illusion-of-infinite-memory">Maintaining the Illusion of Infinite Memory<a class="hash-link" href="#maintaining-the-illusion-of-infinite-memory" title="Direct link to heading">â€‹</a></h3><p>With a real computer we will eventually run out of free space in which to construct new dat objects. However, most of the data objects generated in a typical computation are used only to hold intermediate results. After these results are accessed, the data objects are no longer needed -- they are <em>garbage</em>.</p><p>If we can arrange to collect all the garbage periodically, and if this turns out to recycle memory at about the same rate at which we construct new data objects, we will have preserved the illusion that there is an infinite amount of memory.</p><p>Garbage collection is based on the observation that, at any moment in procedure execution, the only objects that can affect the future of the computation are those that can be reached by some operations starting from the pointers that are currently in the machine registers. Any memory cell that this not so accessible may be recycled.</p><p>The method used here to perform garbage collection is called <em>stop-and-copy</em>. When working memory is full, we perform garbage collection by locating all the useful pairs in working memory and copying these into consecutive locations in free memory. Since we do not copy the garbage, there will presumably be additional free memory that we can use to allocate new pairs. In addition, nothing in the working memory is needed, since all the useful pairs in it have been copied. Thus, if we interchange the roles of working memory and free memory, we can continue processing; new pairs will be allocated in the new working memory (which was the old free memory). When this is full, we can copy the useful pairs into the new free memory (which was the old working memory).</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-explicit-control-evaluator">The Explicit-Control Evaluator<a class="hash-link" href="#the-explicit-control-evaluator" title="Direct link to heading">â€‹</a></h2><blockquote><p>It&#x27;s much like an interpreter for interpretive language, except the runtime is register-machine, rather than a VM such as V8/JVM.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-core-of-the-explicit-control-evaluator">The Core of the Explicit-Control Evaluator<a class="hash-link" href="#the-core-of-the-explicit-control-evaluator" title="Direct link to heading">â€‹</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="sequence-evaluation-and-tail-recursion">Sequence Evaluation and Tail Recursion<a class="hash-link" href="#sequence-evaluation-and-tail-recursion" title="Direct link to heading">â€‹</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="conditionals-assignments-and-definitions">Conditionals, Assignments, and Definitions<a class="hash-link" href="#conditionals-assignments-and-definitions" title="Direct link to heading">â€‹</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="running-the-evaluator">Running the Evaluator<a class="hash-link" href="#running-the-evaluator" title="Direct link to heading">â€‹</a></h3><h2 class="anchor anchorWithStickyNavbar_LWe7" id="compilation">Compilation<a class="hash-link" href="#compilation" title="Direct link to heading">â€‹</a></h2><p>The explicit-control evaluator machine is universalâ€”it can carry out any computational process that can be described in Scheme.</p><p>Thus, the evaluatorâ€™s data paths are universal: they are sufficient to perform any computation we desire, given an appropriate controller.</p><p>Commercial general-purpose computers are register machines organized around a collection of registers and operations that constitute an efficient and convenient set of data paths. The controller for a general-purpose machine is an interpreter for a register-machine language like the one we have been using. This language is called the <em>native language</em> of the machine, or simply <em>machine language</em>. Programs written in machine language are sequences of instructions that use the machine&#x27;s data paths.</p><p>There are two common strategies for bridging the gap between higher-level languages and register-machine languages. The explicit-control evaluator illustrates the strategy of interpretation. An interpreter written in the native language of a machine configures the machine to execute programs written in a language (called the <em>source language</em>) that may differ from the native language of the machine performing the evaluation. The primitive procedures of the source language are implemented as a library of subroutines written in the native language of the given machine. A program to be interpreted (called the <em>source program</em>) is represented as a data structure. The interpreter traverses this data structure, analyzing the source program. As it does so, it simulates the intended behavior of the source program by calling appropriate primitive subroutines from the library.</p><p>The alternative strategy is <em>compilation</em>. A compiler for a given source language and machine translates a source program into an equivalent program (called the <em>object program</em>) written in the machineâ€™s native language.</p><p>Compared with interpretation, compilation can provide a great increase in the efficiency of program execution.</p><blockquote><p>On the other hand, an interpreter provides a more powerful environment for interactive program development and debugging, because the source program being executed is available at run time to be examined and modified. In addition, because the entire library of primitives is present, new programs can be constructed and added to the system during debugging.</p></blockquote><p><strong>An overview of the compiler</strong></p><blockquote><p>In general, the compiler translates a source program into an object program that performs essentially the same register operations as would the interpreter in evaluating the same source program.</p></blockquote><p>This description suggests a strategy for implementing a rudimentary compiler: We traverse the expression in the same way the interpreter does. When we encounter a register instruction that the interpreter would perform in evaluating the expression, we do not execute the instruction but instead accumulate it into a sequence. The resulting sequence of instructions will be the object code.</p><blockquote><p>With a compiler, the expression is analyzed only once, when the instruction sequence is generated at compile time.</p></blockquote><p>But there are further opportunities to gain efficiency in compiled code. As the interpreter runs, it follows a process that must be applicable to any expression in the language. In contrast, a given segment of compiled code is meant to execute some particular expression:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">This can make a big difference, for example in the use of the stack to save registers. When the interpreter evaluates an expression, it must be prepared for any contingency. Before evaluating a subexpression, the interpreter saves all registers that will be needed later, because the subexpression might require an arbitrary evaluation. A compiler, on the other hand, can exploit the structure of the particular expression it is processing to generate code that avoids unnecessary stack operations.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>A compiler can also optimize access to the environment. Having analyzed the code, the compiler can in many cases know in which frame a particular variable will be located and access that frame directly, rather than performing the <code>lookup-variable-value</code> search.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="structure-of-the-compiler">Structure of the Compiler<a class="hash-link" href="#structure-of-the-compiler" title="Direct link to heading">â€‹</a></h3><p>In the compiler, we will do essentially the necessary analysis. Instead of producing execution procedures, however, we will generate <em>sequences of instructions</em> to be run by our register machine.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="compiling-expressions">Compiling Expressions<a class="hash-link" href="#compiling-expressions" title="Direct link to heading">â€‹</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="compiling-combinations">Compiling Combinations<a class="hash-link" href="#compiling-combinations" title="Direct link to heading">â€‹</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="combining-instruction-sequences">Combining Instruction Sequences<a class="hash-link" href="#combining-instruction-sequences" title="Direct link to heading">â€‹</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="an-example-of-compiled-code">An Example of Compiled Code<a class="hash-link" href="#an-example-of-compiled-code" title="Direct link to heading">â€‹</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="lexical-addressing">Lexical Addressing<a class="hash-link" href="#lexical-addressing" title="Direct link to heading">â€‹</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="interfacing-compiled-code-to-the-evaluator">Interfacing Compiled Code to the Evaluator<a class="hash-link" href="#interfacing-compiled-code-to-the-evaluator" title="Direct link to heading">â€‹</a></h3></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/docs/tags/sicp">sicp</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/sicp/metalinguistic-abstraction"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Metalinguistic Abstraction</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/concurrency-in-go/"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Go Concurrency Again</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#designing-register-machines" class="table-of-contents__link toc-highlight">Designing Register Machines</a><ul><li><a href="#a-language-for-describing-register-machines" class="table-of-contents__link toc-highlight">A Language for Describing Register Machines</a></li><li><a href="#abstraction-in-machine-design" class="table-of-contents__link toc-highlight">Abstraction in Machine Design</a></li><li><a href="#subroutines" class="table-of-contents__link toc-highlight">Subroutines</a></li><li><a href="#using-a-stack-to-implement-recursion" class="table-of-contents__link toc-highlight">Using a Stack to Implement Recursion</a></li></ul></li><li><a href="#a-register-machine-simulator" class="table-of-contents__link toc-highlight">A Register-Machine Simulator</a><ul><li><a href="#the-machine-model" class="table-of-contents__link toc-highlight">The Machine Model</a></li><li><a href="#the-assembler" class="table-of-contents__link toc-highlight">The Assembler</a></li><li><a href="#generating-execution-procedures-for-instructions" class="table-of-contents__link toc-highlight">Generating Execution Procedures for Instructions</a></li><li><a href="#monitoring-machine-performance" class="table-of-contents__link toc-highlight">Monitoring Machine Performance</a></li></ul></li><li><a href="#storage-allocation-and-garbage-collection" class="table-of-contents__link toc-highlight">Storage Allocation and Garbage Collection</a><ul><li><a href="#memory-as-vectors" class="table-of-contents__link toc-highlight">Memory as Vectors</a></li><li><a href="#maintaining-the-illusion-of-infinite-memory" class="table-of-contents__link toc-highlight">Maintaining the Illusion of Infinite Memory</a></li></ul></li><li><a href="#the-explicit-control-evaluator" class="table-of-contents__link toc-highlight">The Explicit-Control Evaluator</a><ul><li><a href="#the-core-of-the-explicit-control-evaluator" class="table-of-contents__link toc-highlight">The Core of the Explicit-Control Evaluator</a></li><li><a href="#sequence-evaluation-and-tail-recursion" class="table-of-contents__link toc-highlight">Sequence Evaluation and Tail Recursion</a></li><li><a href="#conditionals-assignments-and-definitions" class="table-of-contents__link toc-highlight">Conditionals, Assignments, and Definitions</a></li><li><a href="#running-the-evaluator" class="table-of-contents__link toc-highlight">Running the Evaluator</a></li></ul></li><li><a href="#compilation" class="table-of-contents__link toc-highlight">Compilation</a><ul><li><a href="#structure-of-the-compiler" class="table-of-contents__link toc-highlight">Structure of the Compiler</a></li><li><a href="#compiling-expressions" class="table-of-contents__link toc-highlight">Compiling Expressions</a></li><li><a href="#compiling-combinations" class="table-of-contents__link toc-highlight">Compiling Combinations</a></li><li><a href="#combining-instruction-sequences" class="table-of-contents__link toc-highlight">Combining Instruction Sequences</a></li><li><a href="#an-example-of-compiled-code" class="table-of-contents__link toc-highlight">An Example of Compiled Code</a></li><li><a href="#lexical-addressing" class="table-of-contents__link toc-highlight">Lexical Addressing</a></li><li><a href="#interfacing-compiled-code-to-the-evaluator" class="table-of-contents__link toc-highlight">Interfacing Compiled Code to the Evaluator</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Repositories</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/AkatQuas/kiddo-plays" target="_blank" rel="noopener noreferrer" class="footer__link-item">Kiddo plays<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/AkatQuas/nprogresse" target="_blank" rel="noopener noreferrer" class="footer__link-item">NProgressE<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/AkatQuas" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Links</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/AkatQuas" target="_blank" rel="noopener noreferrer" class="footer__link-item">Who would it be?<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2022 AkatQuas. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.5d758bff.js"></script>
<script src="/assets/js/main.6f4b5c91.js"></script>
</body>
</html>