<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-network-top-down-approach/ch03-transport-layer">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">运输层 | AkatQuas&#x27;s blog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://akatquas.github.io/docs/network-top-down-approach/ch03-transport-layer"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="运输层 | AkatQuas&#x27;s blog"><meta data-rh="true" name="description" content="首先将讨论运输层和网络层的关系。先研究运输层的第一个关键功能，即 将网络层的在两个端系统之间的交付服务，扩展到运行在两个不同端系统上的应用层进程之间的交付服务。"><meta data-rh="true" property="og:description" content="首先将讨论运输层和网络层的关系。先研究运输层的第一个关键功能，即 将网络层的在两个端系统之间的交付服务，扩展到运行在两个不同端系统上的应用层进程之间的交付服务。"><link data-rh="true" rel="icon" href="/images/favicon.ico"><link data-rh="true" rel="canonical" href="https://akatquas.github.io/docs/network-top-down-approach/ch03-transport-layer"><link data-rh="true" rel="alternate" href="https://akatquas.github.io/docs/network-top-down-approach/ch03-transport-layer" hreflang="en"><link data-rh="true" rel="alternate" href="https://akatquas.github.io/docs/network-top-down-approach/ch03-transport-layer" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="AkatQuas&#39;s blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="AkatQuas&#39;s blog Atom Feed"><link rel="stylesheet" href="/assets/css/styles.d30c7ca7.css">
<link rel="preload" href="/assets/js/runtime~main.5d758bff.js" as="script">
<link rel="preload" href="/assets/js/main.6f4b5c91.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/images/logo.svg" alt="AkatQuas" class="themedImage_ToTc themedImage--light_HNdA"><img src="/images/logo.svg" alt="AkatQuas" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">AkatQuas 🔭</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/about">Topic</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://akatquas.github.io/dateless/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Dateless<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a href="https://github.com/AkatQuas/AkatQuas.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/about">Akat</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/network-top-down-approach/">Computer Network</a><button aria-label="Toggle the collapsible sidebar category &#x27;Computer Network&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/network-top-down-approach/ch01-network-and-internet">计算机网络和因特网</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/network-top-down-approach/ch02-application-layer">应用层</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/network-top-down-approach/ch03-transport-layer">运输层</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/network-top-down-approach/ch04-network-layer">网络层</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/data-structure/">Data Structure</a><button aria-label="Toggle the collapsible sidebar category &#x27;Data Structure&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/compiler/">Compiler</a><button aria-label="Toggle the collapsible sidebar category &#x27;Compiler&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/interpreter-in-js/">Writing a interpreter in JavaScript</a><button aria-label="Toggle the collapsible sidebar category &#x27;Writing a interpreter in JavaScript&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/lisp-interpreter-in-c/index">Build Your Own Lisp Interpreter in C</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/lisp-interpreter-in-py/chapter-00">Build A Lisp Interpreter in Python</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/sicp/index">SICP</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/concurrency-in-go/">Concurrency in Go</a><button aria-label="Toggle the collapsible sidebar category &#x27;Concurrency in Go&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/docker/">Docker</a><button aria-label="Toggle the collapsible sidebar category &#x27;Docker&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/kubernetes/">Kubernetes</a><button aria-label="Toggle the collapsible sidebar category &#x27;Kubernetes&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/network-top-down-approach/"><span itemprop="name">Computer Network</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">运输层</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>运输层</h1></header><p>首先将讨论运输层和网络层的关系。先研究运输层的第一个关键功能，即 将网络层的在两个端系统之间的交付服务，扩展到运行在两个不同端系统上的应用层进程之间的交付服务。</p><p>其次，讨论两个实体怎么样才能在一种会丢失或损坏数据的介质上可靠的通信。</p><p>最后讨论网络中的第二个重要问题，控制运输层实体的传输速率以避免网络中的拥塞，或从拥塞中恢复过来。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="概述和运输层服务">概述和运输层服务<a class="hash-link" href="#概述和运输层服务" title="Direct link to heading">​</a></h2><p>运输层协议为运行在不同主机上的应用进程之间提供了 <strong>逻辑通信 logic communication</strong> 功能。应用进程使用运输层提供的逻辑通信功能彼此发送报文进行通信，而无需考虑承载这些报文的物理基础设施的细节。</p><p><img loading="lazy" src="/assets/images/ch03f01-3357a8b295b2e6ff7e28c135da5f3ca7.png" width="800" height="943" class="img_ev3q"></p><p>如上图，运输层协议是在端系统中而不是在网络路由器中实现的。在发送方，运输层将接收到来自发送应用进程的报文转换称运输层分组，术语为 <strong>报文段 segment</strong> 。可能的方法是将应用报文划分为较小的块，并为每块加上一个运输层首部来创建运输层报文段。然后，在发送方端系统中，运输层将这些报文段传递给网络层，网络层将其封装称网络层分组（数据报 datagram）并向目的地发送。要注意，网络路由器仅作用于该数据报的网络层字段，它们不检查封装该数据报的运输层报文段的字段。在接收方，网络层从数据报中提取运输层报文段，并将该报文段上交给运输层。运输层处理接收到的报文段，使得接收方应用进程可使用该报文段中的数据。</p><blockquote><p>运输层和网络层的关系</p></blockquote><p>运输层刚好位于网络层之上，运输层为运行在不同主机上的进程之间提供了逻辑通信，而网络层则提供了主机之间的逻辑通信。</p><p>运输层协议只工作在端系统中，运输层协议将来自应用进程的报文移动到网络边缘。</p><p>运输层协议所能提供的服务受到了底层网络服务模型的限制。如果网络层协议不能为两主机之间发送的运输层报文段提供时延和带宽保证，那么运输层协议也不能为两进程之间的报文提供时延和带宽保证。</p><blockquote><p>运输层概述</p></blockquote><p>UDP（用户数据报协议）为调用它的应用程序提供了一种不可靠的、无连接的服务。</p><p>TCP（传输控制协议）为调用它的应用程序提供了一种可靠的、面向连接的服务。</p><p>应用程序的开发人员在创建套接字时必须指定选择 UDP 还是 TCP 。</p><p>本章中，运输层的分组称为 <strong>报文段 segment</strong>， 而 <strong>数据报 datagram</strong> 留给了网络层分组。</p><p>在介绍 UDP 和 TCP 之前先了解一下网络层。因特网网络层协议名字为 IP ，全程是网际协议。 IP 为主机之间提供了逻辑通信。 IP 的服务模型是 <strong>尽力而为的交付服务 best-effort delivery service</strong> 。这意味着，IP 不能确保报文段的交付，不保证报文段的按序交付，更不保证报文段中数据的完整性。因此 IP 被称为 <strong>不可靠服务 unreliable service</strong> ，每台主机都有一个 IP 地址。</p><p>总结一下 UDP 和 TCP 所提供的服务模型。 UDP 和 TCP 最基本的任务是，将两个端系统间 IP 的交付服务扩展为运行在两个端系统上的进程之间的交付服务。将主机间的交付扩展到进程间的交付，称为运输层的 <strong>多路复用 multiplexing</strong> 与 <strong>多路分解 demultiplexing</strong> 。UDP 和 TCP 还可以通过在其报文段的首部添加差错检测字段而提供完整性检查。进程间数据交付和差错检测是两种最低限度的运输层服务，也是 UDP 所能提供的仅有的两种服务。特别的 UDP 不能保证一个进程所发送的数据能够完整无损地到达目的进程。</p><p>TCP 还为应用程序提供了几种附加服务。首先，它提供 <strong>可靠数据传输 reliable data transfer</strong> 。通过流量控制、序号、确认和定时器等技术，TCP 确保正确地、按序地将数据从发送进程交付给接收进程。TCP 还提供 <strong>拥塞控制 congestion control</strong> ，不太严格的说， TCP 拥塞控制防止任何一条 TCP 连接使用过多流量。从原理上讲，TCP 允许 TCP 连接通过一条拥塞的网络链路，平等地共享网络链路带宽。这可以通过调节发送方 TCP 发送到网络的流量速率来实现。相对的，使用 UDP 传输的应用程序可以根据需要以任何速率发送数据，其流量无法调节。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="多路复用与多路分解">多路复用与多路分解<a class="hash-link" href="#多路复用与多路分解" title="Direct link to heading">​</a></h2><p>多路复用和多路分解服务是所有计算机网络都需要的。</p><p>在目的主机，运输层从下层网络层接收报文段。运输层负责将这些报文段中国年的数据交付给在主机上运行的合适的应用进程。</p><p>进程有一个或多个套接字，它相当于网络与进程之间通信、传递数据的媒介。如下图所示，接受主机中的运输层实际上并没有直接将数据交付给进程，而是通过一个套接字来传递的。主机上可能同时有多个套接字，每个套接字都有唯一的标识符。</p><p><img loading="lazy" src="/assets/images/ch03f02-0f491f1aa26b2f754d036f3cb1a4ad04.png" width="750" height="383" class="img_ev3q"></p><p>下面考虑接受主机怎样将一个接收到的运输层报文段定向到合适的套接字。为达到这一目的，每个运输层报文段中设置了几个字段。在接收端，运输层检查这些字段并识别出接收套接字，然后将该报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工作称为 <strong>多路分解 demultiplexing</strong> 。从源主机的不同套接字中收集数据块，并为每个数据块封装上首部信息，从而生成报文段，然后将报文段传递到网络层的工作称为 <strong>多路复用 multiplexing</strong> 。</p><p>为了满足运输层多路复用的要求： <code>1.套接字有唯一的标识符</code>，<code>2.每个报文段有特殊字段来指示该报文段所要交付的套接字</code>。这些特殊字符字段是 <strong>源端口号字段 source port number field</strong> 和 <strong>目的端口号字段 destination port number field</strong> 。端口号是一个 16 比特数字，取值 0 ～ 65535 ， 0 ～ 1023 是保留给应用层协议的。</p><p>现在应该清楚运输层是怎样实现多路分解服务的了：主机上的每一个套接字被分配一个端口号，当报文段到达该主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入其所连接的进程。</p><blockquote><p>无连接的多路复用与多路分解</p></blockquote><p>应用程序的客户机端让运输层自动地并且透明地分配端口号，而服务器端分配一个特定的端口号。</p><p>下面的代码分别建立了一个自动分配端口号的套接字（客户机端）和指定端口号的套接字（服务器端）：</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">DatagramSocket clientSocket = new DatagramSocket();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">DatagramSocket serverSocket = new DatagramSocket(19517);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>一个 UDP 套接字是由一个包含目的 IP 地址和目的端口号的二元组 <strong>（目标 IP 地址，目标 port）</strong> 来全面标识的。源端口号的用途用于当服务器想要向客户机发送一个报文时，需要在这个报文中标识好相应的 IP 地址（即源主机的 IP 地址）和端口号（即源端口号）。</p><blockquote><p>面向连接的多路复用和多路分解</p></blockquote><p>为了理解 TCP 的多路分解，需要直到 TCP 套接字和 UDP 套接字之间的细微差别，即 TCP 套接字是由一个四元组 <strong>（源 IP 地址，源 port，目标 IP 地址，目标 port）</strong> 来标识的。</p><p>特别的，与 UDP 不同的是，两个具有不同源 IP 地址或者源端口号的到达 TCP 报文将被定向到两个不同的套接字。除非 TCP 携带了初始创建连接的请求。具体可看下图。A 与 C 之间，C 不同进程之间都向服务器 B 发送了 TCP 连接。服务器根据不同的四元组创建了不同的 TCP 连接。</p><p><img loading="lazy" src="/assets/images/ch03f03-c11964e8d875a2317e2c4ea691efb376.png" width="750" height="530" class="img_ev3q"></p><p>上图中，服务器为每个连接都创建了一个新进程，事实上，高新能 Web 服务器通常只使用一个进程，但是为每个连接创建一个具有新连接套接字的新线程。这样，在任意给定的时间，都可能有许多套接字连接到相同的进程。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="无连接运输-udp">无连接运输 UDP<a class="hash-link" href="#无连接运输-udp" title="Direct link to heading">​</a></h2><p>RFC 768 定义的 UDP 只是做了运输协议能够做的最少工作。除了多路复用/多路分解以及一些轻微的差错检测之外，它几乎没有对 IP 协议增加别的东西。</p><p>UDP 从应用进程得到数据，附加上多路复用／多路分解服务所需对源端口号和目的端口号字段，以及两个其他小极端，然后将形成对报文段交给网络层。网络层将该运输报文封装到一个 IP 数据报 中，然后尽力地将此报文交付接收主机。如果该报文段到达接收主机后，UDP 使用目的端口号来将报文段中的数据交付给正确的应用进程。注意到使用 UDP 时，在发送报文段前，发送方和接收方对运输层实体之间没有进行握手，故称 UDP 为无连接的。</p><p>DNS 时使用 UDP 的极好的例子。当一台主机中的 DNS 应用程序想要进行一次查询时，它构造了一个 DNS 查询报文并将其交给 UDP 套接字。无须执行任何与目的端系统的握手过程，客户机的 UDP 套接字给查询报文添加首部字段，然后将形成的报文段交给网络层。网络层将 UDP 报文段封装进一个 IP 数据报中，发送给一个本地 DNS 服务器。查询主机的 DNS 应用程序便等待着查询的响应。如果没有收到响应，它可能会试图向另一个本地 DNS 服务器发送查询，也可能通知调用应用程序未获得响应。</p><p>这么看来，开发应用时，选择 UDP 还是 TCP 似乎是毫无悬念的，那么事实上呢？事实上，有许多应用更适合用 UDP，主要有以下原因：</p><ul><li>应用程序能更好地控制要发送的数据和发送时间。</li><li>无需连接建立。UDP 不会像 TCP 一样存在所谓的连接建立时延。</li><li>无连接状态。TCP 需要在端系统中维护连接状态（接收／发送缓存、拥塞控制参数、序号参数、确认号参数）。</li><li>分组首部开销小。每个 TCP 报文段都有 20 字节的首部开销，而 UDP 仅 8 字节的开销。</li></ul><table><thead><tr><th align="center">应用</th><th align="center">应用层协议</th><th align="center">使用的运输层协议</th></tr></thead><tbody><tr><td align="center">电子邮件</td><td align="center">SMTP</td><td align="center">TCP</td></tr><tr><td align="center">远程终端访问</td><td align="center">Telnet</td><td align="center">TCP</td></tr><tr><td align="center">Web</td><td align="center">HTTP</td><td align="center">TCP</td></tr><tr><td align="center">文件传输</td><td align="center">FTP</td><td align="center">TCP</td></tr><tr><td align="center">远程文件服务器</td><td align="center">NFS</td><td align="center">通常 UDP</td></tr><tr><td align="center">流式多媒体</td><td align="center">专用协议</td><td align="center">UDP 或 TCP</td></tr><tr><td align="center">因特网电话</td><td align="center">专用协议</td><td align="center">UDP 或 TCP</td></tr><tr><td align="center">网络管理</td><td align="center">SNMP</td><td align="center">通常 UDP</td></tr><tr><td align="center">选路协议</td><td align="center">RIP</td><td align="center">通常 UDP</td></tr><tr><td align="center">DNS 转换</td><td align="center">DNS</td><td align="center">通常 UDP</td></tr></tbody></table><p>需要提一下，使用 UDP 的应用是可以通过自身中建立可靠性机制（确认与重传机制）来实现可靠数据传输的。换句话说，应用进程可以进行可靠通信，而无需受制于 TCP 拥塞控制机制而引起的传输速率约束。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="udp-报文段结构">UDP 报文段结构<a class="hash-link" href="#udp-报文段结构" title="Direct link to heading">​</a></h3><p><img loading="lazy" src="data:image/png;base64,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" width="485" height="170" class="img_ev3q"></p><p>应用层数据占用了 UDP 报文段的数据字段。UDP 首部只有 4 个字段，每个字段两个字节。通过端口号可以使目的主机将应用交给运行在目的端系统中的相应进程。接收主机使用检验和来检查报文段中是否存在差错。计算检验和时，除了 UDP 报文段以外还使用了 IP 首部的一些字段，此书不详解。长度指明了包括首部在内的 UDP 报文段长度（单位 字节）。</p><p>UDP 只有提供了差错检测，却不能进行差错恢复。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="可靠数据传输的原理">可靠数据传输的原理<a class="hash-link" href="#可靠数据传输的原理" title="Direct link to heading">​</a></h2><p><img loading="lazy" src="/assets/images/ch03f05-03dd1f4d4e53f4c8ccb5001899e99c97.png" width="720" height="532" class="img_ev3q"></p><p>上图显示了接下来讨论可靠数据传输的框架。提供给上层实体的服务抽象是， <strong>数据可以通过一条可靠的信道进行传输</strong> 。you 了可靠信道，就不会有数据传输时比特受损或丢失，且数据都是按照发送顺序进行传送的。</p><p>实现这种服务抽象的是 <strong>可靠数据传输协议 reliable data transfer protocol</strong> 的责任。事实上，可靠数据传输协议的下层 协议也许是不可靠的。为了便于学习，将底层视为不可靠的点对点信道。</p><p>图中 b 部分说明了数据传输协议的接口。可以通过 rdt_send() 函数，来调用数据传输协议的发送方。它把待发送的数据交付给接收方的上层。在接收方，当分组从信道的接收端抵达时，将调用 rdt_rcv() 函数。当 rdt 协议 想要向较高层交付数据时，需要调用 deliver_data() 来完成。在讨论可靠传输时，将使用 “分组” 而不是 运输层的“报文段” 。此段仅考虑单向传输情况，双向传输在原理上是一致的。而且需要知道，除了含有待发数据的分组之外，rdt 的发送方和接收方还需要来回交换控制分组。rdt 的发送方和接收方都需要通过 udt_send() 发送分组给对方 (udt 表示不可靠数据传输)。</p><p>（可靠数据传输原理过于黑盒，不适应摘抄，可自行研究）</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="面向连接的运输tcp">面向连接的运输：TCP<a class="hash-link" href="#面向连接的运输tcp" title="Direct link to heading">​</a></h2><p>TCP 协议 是因特网传输层、面向连接的可靠运输协议。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tcp-概述">TCP 概述<a class="hash-link" href="#tcp-概述" title="Direct link to heading">​</a></h3><p>TCP 是 <strong>面向连接 connection-oriented</strong> 的，这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互 “握手” ，即它们必须相互发送某些预备报文段，以建立确保数据传输所需的参数。</p><p>这种 TCP 连接 不是一条端粒连接也不是一条虚电路，它段连接状态完全保留在两个端系统中，所以中间元素 <strong>路由器和链路层交换机</strong> 不会维持 TCP 的连接状态。事实上，中间元素对于 TCP 连接完全不知情，它们看到的只是数据报。</p><p>TCP 连接提供的是 <strong>全双工服务 full-duplex service</strong> ：如果一台主机上的进程 A 与另一台主机上的进程 B 存在一条 TCP 连接，那么应用层数据可以从进程 B 流向进程 A，也可以从进程 A 流向进程 B。</p><p>TCP 连接也总是 <strong>点对点 point-to-point</strong> 的，即单个发送方与单个接收方之间的连接。因此 broadcast 在 TCP 来说是不可能的。</p><p>下面看看 TCP 连接是如何建立的。</p><p>客户机应用进程首先通知客户机运输层，它想要与服务器上的一个进程建立一条连接。例如下面的 Java 代码：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">Socket clientSocket = new Socket(&quot;hostname&quot;, portNumber);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其中 hostname 是服务器名字，portNumber 是服务器上进程的标识。这样客户机上的运输层便开始与服务器上的运输层建立一条 TCP 连接（下文详述）。客户机线发送一个特殊的 TCP 报文段，服务器用另一个特殊的报文段响应，最后客户机再用第三个特殊报文段作为响应。前两个报文段不承载 “有效载荷” ，即不包含应用层数据，而第三个报文可以承载有效载荷。这中连接过程通常被称为 <strong>三次握手 three-way handshake</strong> 。</p><p><img loading="lazy" src="/assets/images/ch03f06-581412732664bfd398989abb7c37b035.png" width="690" height="336" class="img_ev3q"></p><p>一旦建立了 TCP 连接，两个应用进程之间就可以相互发送数据了。客户机进程通过套接字传递数据流。数据通过套接字，控制权就交到客户机中运行的 TCP 了。TCP 将这些数据引导到该链接的 <strong>发送缓存 send buffer</strong> 里，发送缓存是在三次握手初期设置的缓存之一。接下来 TCP 就会不时地（只要知道是在恰当的时机就好了）从发送缓存里取出一块数据，给它加一个 TCP 首部，从而形成多个 <strong>TCP 报文段 TCP segment</strong> 。这些报文段被下传给网络层，网络层将其封装在网络层 IP 数据报中，再被发送到网络中。TCP 在另一端收到一个报文段后，该报文段的数据就被放入该 TCP 的接收缓存，应用程序从此缓存中读取数据流。TCP 连接的每一段都有各自的发送缓存和接受缓存。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tcp-报文段结构">TCP 报文段结构<a class="hash-link" href="#tcp-报文段结构" title="Direct link to heading">​</a></h3><p>TCP 报文段由首部字段和数据字段组成。数据字段含有一块应用数据。</p><p><img loading="lazy" src="/assets/images/ch03f07-b64616438738d4dc3f51c85bdd348927.png" width="641" height="438" class="img_ev3q"></p><p>如上图，首部包括 <strong>源端口号 source port number</strong> 和 <strong>目的端口号 destination port number</strong> ，它用于多路复用／多路分解来自或送至上层应用数据，还包括 <strong>检验和字段 checksum field</strong> 。还有：</p><ul><li>32 比特的 <strong>序号字段 sequence number field</strong> 和 32 比特的 <strong>确认号字段 acknowledgement number field</strong> 。这些字段被 TCP 发送方和接收方用来实现可靠数据传输服务。</li><li>16 比特的 <strong>接收窗口 receive window</strong> 字段。该字段用于流量控制，用于指示接收方愿意接受的字节数量。</li><li>4 比特的 <strong>首部长度字段 header length field</strong> ，该字段指示了以 32 比特的字为单位的 TCP 首部长度。由于 TCP 选项字段的原因，TCP 首部的长度是可变的。</li><li>可选与变长的 <strong>选项字段 options field</strong> 。该字段用于当发送方与接收方协商最大报文段长度，或在高速网络环境下用作窗口调节因子时使用。首部字段中还定义一个时间戳选项。</li><li>6 比特的 <strong>标志字段 flag field</strong> 。ACK 比特 用于指示确认字段中的值是有效的。RST、 SYN 和 FIN 比特用于连接建立和拆除。当 PSH 比特被设置时，就指示接收方应立即将数据交给上层。最后 URG 比特用来指示报文段里存在着被发送方的上层实体置为 “紧急” 的数据。紧急数据的最后一个字节由 16 比特的 <strong>紧急数据指针字段 urgent data pointer field</strong> 指出。当紧急数据存在并给出指向紧急数据尾的指针时，TCP 必须通知接收方的上层实体。（实际中 PSH 、URG 和紧急数据指针并没有使用，为了完整性才提及 ╮(￣ ▽ ￣&quot;&quot;)╭ ...）</li></ul><blockquote><p>序号和确认号</p></blockquote><p>最重要的两个字段。</p><p>TCP 把数据堪称一个无结构的但是有序的字节流。序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。一个 <strong>报文段的序号 sequence number for a segment</strong> 是该报文段首字节的字节流编号。例如某次数据流由一个包含 500,000 个字节的文件组成，MSS 为 1000 字节，数据流的首字节号为 0。TCP 将为该数据流构建 500 个报文段。第一个报文段序号被赋为 0，第二个报文段序号被赋为 1000，第三个 2000，以此类推。每一个序号被填入到相应 TCP 报文段首部的序号字段中。</p><p>事实上，一条 TCP 连接的双方均可随机地选择初始序号。这样可以减少那些仍在网络中的来自两台主机之间先前已终止的连接的报文段被误认为是后来这两台主机之间新建连接所产生的有效报文段的可能性。</p><p>确认号要比较难理解一些。</p><p>主机 A 在向主机 B 发送数据的同时，也接收来自主机 B 的数据。从主机 B 到达的每个报文段中都有一个序号用于从 B 流向 A 的数据。 <strong>主机 A 填充进报文段的确认号是主机 A 期望从主机 B 中收到的下一字节的序号</strong> 。看三个例子：</p><ol><li><p>假设主机 A 已经收到了来自主机 B 编号为 0 ～ 535 的所有字节，同时假设 A 要发一个报文段给 B。A 等待 B 的数据流中字节 536 及后续所有字节。所以 A 会在它发往 B 的报文段的确认号字段中填上 536。</p></li><li><p>假设主机 A 已经收到一个来自主机 B 的包含字节 0 ～ 535 的报文段，以及另一个包含 900 ～ 1000 的报文段。由于某些原因，A 还没有收到字节 536 ～ 899 的报文段。A 为了重组 B 的数据流，仍在等待字节 536 和 536 后面的字节。因此 A 到 B 的下一个报文段将在确认号字段中包含 536。 因为 TCP 只确认数据流中至第一个丢失字节为止的字节，所以 TCP 被称为是提供 <strong>累计确认 cumulative acknowledgement</strong> 。</p></li><li><p>主机 A 在收到第二个报文段（字节 536 ～ 899）之前收到了第三个报文段（字节 900 ～ 1000）。因此发生了失序到达。TCP 文档里面没有明确规定此时该怎么做，程序员有两种方式：<code>1.接收方立即丢弃失序报文段（可以简化接收方的设计）</code>,<code>2.接收方保留失序的字节，并等待缺少的字节以填补该间隔</code>。事实上，第二种方式对网络带宽更有效，也是实践中采用的方法。</p></li></ol><p>为了加深理解，可以从双向通信的过程来看看确认号在实际应用中的使用，<a href="http://blog.csdn.net/tianyue168/article/details/5822042" target="_blank" rel="noopener noreferrer">文章</a>。</p><blockquote><p>Telnet：序号和确认号的一个学习案例</p></blockquote><p>Telnet 是一个用于远程登录的应用层协议，运行在 TCP 之上，被设计成可以在任意一对主机之间工作。现在更多的用户愿意使用 ssh 协议而不是 Telnet ，因为 Telnet 连接中发送到数据都是未加密的。</p><p>客户机 A 发起一个与服务器 B 的 Telnet 会话。假设客户机和服务器起始序列号分别为 42 和 79。因此客户机发送的第一个报文段的序号为 42，隐式地，客户机等待的字节号为 79，服务器发送的第一个报文段序号为 79，隐式地，服务器等待的字节号为 42。</p><p><img loading="lazy" src="/assets/images/ch03f08-0dd2e4f071cee5d3838c2e8683450063.png" width="700" height="700" class="img_ev3q"></p><p>如上图，一共 3 个报文段，第一个由客户机发往服务器，其数据字段包含一个字节的字符“C”的 ASCII 码，序号字段内容是 42，隐式地，确认号字段是 79。</p><p>第二个是服务器发往客户机的。它有两个目的，第一个目的是服务器收到数据的确认。服务器通过在确认号字段中填入 43，告诉客户机它已经成功地收到字节 42 以及以前的所有字节，现在等待着字节 43 的出现。第二个目的是回显字符“C”，因此会在第二个报文段的数据字段里面填入字符“C”的 ASCII 码。第二个报文段的序号 79，它是该 TCP 连接上从服务器到客户机的数据流的起始序号，也是服务器要发送的第一个字节的数据。注意到对客户机到服务器的数据的确认被装载在一个承载服务器到客户机的数据的报文段中，这种确认被称为 <strong>捎带 piggybacked</strong> 在服务器到客户机的数据报文段中的。</p><p>第三个报文段是从客户机发往服务器的。它的唯一目的是确认已从服务器收到的数据。该报文段的数据字段为空，确认号字段填入的是 80，（客户机已经收到了字节流中序号为 79 及以前的字节，它现在正在等待字节 80 的出现）。似乎有点奇怪的是，该报文段里没有数据但有序号，这是因为 TCP 存在序号字段，报文段需要填入某些序号。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="往返时延的估计与超时">往返时延的估计与超时<a class="hash-link" href="#往返时延的估计与超时" title="Direct link to heading">​</a></h3><p>TCP 采用超时／重传机制来处理报文段的丢失问题。实际使用中还有一些很微妙的问题，最明显的一个就是超时间隔长度的设置。接下来看看 TCP 定时器的管理问题。</p><blockquote><p>估计往返时延</p></blockquote><p>考虑一下 TCP 是如何估计发送方与接收方之间的往返时延。报文段的 <strong>样本 RTT Sample RTT</strong> 就是从 <strong>某报文段被发出（即交给 IP）到对该报文段的确认被收到</strong> 之间的时间量。大多数 TCP 的实现仅在某个时刻做一次 SampleRTT 测量，而不是每个发送的报文段都进行测量，亦即，在任意时刻，仅为一个已发送的但目前尚未被确认的报文段估计 SampleRTT，从而产生一个接近每个 RTT 的新 SampleRTT 值。另外，TCP 绝不会为已重传的报文段计算 SampleRTT ，而仅为传输一次的报文段测量。</p><p>显然由于路由器拥塞和端系统负载的变化，这些报文段的 SampleRTT 会波动，于是要对它进行一些统计行为。一旦获得一个新的 SampleRTT，TCP 会根据下面的公式来计算</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">EstimatedRTT = (1-α) * EstimatedRTT + α * SampleRTT</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述语句是一句编程语句，RFC 2988 文档中 α = 0.125。</p><p><img loading="lazy" src="/assets/images/ch03f09-035d0045a3a0f04977ea8aa843b81404.png" width="750" height="468" class="img_ev3q"></p><p>注意到 EstimatedRTT 是一个加权值。除了 EstimatedRTT 以外，测量 RTT 的变化也是有意义的， RTT 偏差 DevRTT 用于估算 SampleRTT 一般会偏离 EstimatedRTT 的程度：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">DevRTT = (1-β) * DevRTT + β * [SampleRTT - EstimatedRTT]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>设置和管理 重传超时间隔</p></blockquote><p>超时间隔应该大于等于 EstimatedRTT ，否则将造成不必要的重传。但是不能太大，否则报文丢失时，TCP 不能很快的重传该报文。DevRTT 这个时候就有用了。考虑这些情况之后，重传超时间隔的计算为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">TimeoutInterval = EstimatedRTT + 4 * DevRTT</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="可靠数据传输">可靠数据传输<a class="hash-link" href="#可靠数据传输" title="Direct link to heading">​</a></h3><p>TCP 在 IP 的尽力而为但是不可靠的（不保证完整性和按序到达）服务基础上建立了一种可靠数据传输服务。TCP 的可靠数据传输服务确保一个进程从其接收缓存中读出非损坏的、无间隔的、非冗余的和按序的数据流。TCP 协议遵循了 RFC 2988 中建议的单一的重传定时器，即使有多个已发送但还未被确认的报文段。</p><p>下文将分两个步骤来讨论 TCP 饰如何提供可靠数据传输的。</p><p>先给出一个 TCP 发送方的高度简化的描述，该发送方只用超时来恢复报文段的丢失。然后描述高级版本，即不仅使用超时机制，还使用冗余确认技术。</p><p>假定一个很大的文件数据要从主机 A 发往主机 B。</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">/*伪代码，</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">假设发送方不受TCP流量和拥塞控制的限制，</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">来自上层的数据长度小于MSS，</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">且数据传输只在一个方向进行。</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">NextSeqNum = InitialSeqNumber</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">SendBase = InitialSeqNumber</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">loop (forever) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    switch (event) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        event: data received from application above</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            create TCP segment with sequence number NextSeqNum</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            if (timer currently not running)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                start timer</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            pass segment to IP</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            NextSeqNum = NextSeqNum + length(data)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        event: timer timeout</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            retransmit not-yet-acknowledged segment with smallest sequence number</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            start timer</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        event: ACK received, with ACK field value of y</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            if (y &gt; SendBase) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                SendBase = y</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                if (there are currently any not-yet-acknowledged segment)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                    start timer</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">} /* end of loop forever */</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上面的代码各处了一个 TCP 发送方的高度简化的描述，看到 TCP 发送方有 3 个与发送和重传有关的主要事件:</p><ol><li><p>从上层应用程序接受数据；将数据封装在一个报文段中，并将该报文段传给 IP。顺便开启定时器，该定时器的过期间隔为 <code>TimeoutInterval = EstimatedRTT + 4 * DevRTT</code> 。 <strong>值得注意的是，下一个报文段的序列号是根据当前序列号跟数据字节长度求和出来的。</strong></p></li><li><p>定时器超时：TCP 重传引起超时的报文段（未响应确认收到的报文段中序号最小那个）来响应超时时间，之后重启定时器。</p></li><li><p>收到确认报文段（ACK 报文）。TCP 将 ACK 的值 y 与变量 SendBase 进行比较。 TCP 状态变量 SendBase 是最早未被确认的字节的序号。（因此 SendBase-1 就是指接收方已正确按序接收到的数据的最后一个字节的序号。 ）TCP 采用累计确认，所以 y 确认了字节编号在 y 之前的所有字节都被收到。如果 y &gt; SendBase ，则 ACK 是在确认一个或多个先前未被确认的报文段。因此发送方更新其 SendBase 变量；另外当前如果有未被确认的报文段，TCP 还用重启定时器。</p></li></ol><p>下面举个例子说明 <strong>累计确认</strong> 的好处：主机 A 有两个报文，第一个报文段序号为 92 号报文段，8 字节数据，确认号为 100。第二个报文段序号为 100 号，20 字节数据，确认号为 120。这两个报文依次发送给主机 B。第一个报文段的确认报文在网络中丢失了，但是在超时事件发生前，主机 A 收到了一个确认号为 120 的确认报文。因此主机 A 知道主机 B 已经收到了序号为 119 及以前的 <strong>所有字节</strong> ，所以主机 A 不会重新传送这两个报文中的任意一个。</p><p><img loading="lazy" src="/assets/images/ch03f10-100d1c4237ae97701c1423ce560ab744.png" width="500" height="585" class="img_ev3q"></p><blockquote><p>加倍超时间隔</p></blockquote><p>下面讨论一下大多数 TCP 实现中所做的一些改动。</p><p>每当超时事件发生时，TCP 重传具有最小序号的还未被确认的报文段。但是每次 TCP 重传都会将下一次的超时间隔设为当前值的两倍，而不是之前计算公式的值。然而当定时器在另外两个事件（上层应用的数据和收到 ACK）时，超市间隔由最近的 EstimatedRTT 值和 DevRTT 计算公式推出。</p><p>这种改动提供了一个有限形式的拥塞控制。定时器过期可能是由网络拥塞引起的。如果拥塞时，源主机继续持续重传分组，会使拥塞更加严重。相反，TCP 使用了更优雅的方式，每个发送方的重传都是经过越来越长的时间间隔后进行的。</p><blockquote><p>快速重传</p></blockquote><p>超时出发重传存在的另一个问题时超时周期较长。当一个报文段丢失时，这种较长的超时周期迫使发送方等待很长时间才重传丢失的分组，因而增加了端到端时延。幸运的事，发送方通常可在超时事件发生之前通过注意所谓的冗余 ACK 来较好的检测丢包情况。 <strong>冗余 ACK duplicate ACK</strong> 就是再次确认某个报文段的 ACK，而发送方已经收到了对该报文段的确认。在继续讨论之前需要学一下为什么会发送冗余 ACK。</p><table><thead><tr><th align="center">事件</th><th align="center">TCP 接收方动作</th></tr></thead><tbody><tr><td align="center">所期望序号的报文段按序到达，所有在期望序号及其以前的数据都已经被确认</td><td align="center">延迟的 ACK。对另一个按序到达的报文段最多等待 500ms，如果下一个报文段在这个时间内没有到达，则发送一个 ACK</td></tr><tr><td align="center">有期望序号的报文段按序到达，另一个按序报文段等待 ACK 传输</td><td align="center">立即发送单个累计 ACK，以确认两个按序报文段</td></tr><tr><td align="center">比期望序号大的失序报文段到达，检测出数据流中的间隔</td><td align="center">立即发送冗余 ACK，指明下一饿期待字节的序号（也就是该间隔的低端字节序号）</td></tr><tr><td align="center">能部分或完全填充接受数据间隔的报文段到达</td><td align="center">倘若该报文段起始于间隔的低端，立即发送 ACK</td></tr></tbody></table><p>上表总结了 TCP 接收方的 ACK 生成策略。当 TCP 接收方收到一个 大于下一个所期望的、按序的序号 的报文段时，它检测到了数据流中断间隔，即有报文丢失。这个间隔可能是由于在网络中丢失或重新排序造成的。因为 TCP 不使用否定确认，所以接收方不能向发送方发回一个显示的否定确认，而是只需对按序接收到的最后一个字节数据进行重复确认，即产生了一个冗余 ACK。当失序后的报文段到达时，也会发送它的 ACK。这是上表中第四种情况的含义。</p><p>因为发送方经常持续发送大量的报文段，所以如果一个报文段丢失，就很可能引起许多一个接一个的冗余 ACK。如果 TCP 发送方接收到对相同数据的 3 个冗余 ACK，它就认为跟在这个已被确认过 3 次的报文段之后的报文段丢失。于是执行 <strong>快速重传 fast transmit</strong> ，即该报文段的定时器国旗之前重传该报文，对于有快速重传的 TCP，可用下列代码代替前面代码中的收到 ACK 事件代码。</p><p><a href="https://www.zhihu.com/question/21789252/answer/110640581" target="_blank" rel="noopener noreferrer">思考·为什么是 3 个 ACK</a></p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">/*</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">伪代码</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    event: ACK received, with ACK field value of y</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if (y &gt; SendBase) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            SendBase = y</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            if (there are currently any not-yet-acknowledged segments)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                start timer</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        } else { /* duplicate ACK for already ACKed */</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            increment number of duplicate ACKs received for y</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            if (number of duplicate ACKs received for y == 3)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                /* TCP fast transmit */</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                resend segment with sequence number y</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        break;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" src="/assets/images/ch03f11-8f3703a90aaad8cd5bea64baabd5b2e5.png" width="600" height="664" class="img_ev3q"></p><blockquote><p>流量控制</p></blockquote><p>前述，一条 TCP 连接的双方主机都为该连接设置了接收缓存。当 TCP 收到正确、按序的字节后，它就将数据放入接收缓存中。相关联的应用进程会从该缓存中读取数据，但没有必要数据刚到就立即读取。当应用程序读取太慢或者发送方发送数据太多太快，很容易使该连接的接收缓存溢出。</p><p>TCP 为应用程序提供了 <strong>流量控制服务 flow-control service</strong> 以消除发送方使接收方缓存溢出的可能性。因此可以说，流量控制是一个速度匹配服务，即发送方的发送速率与接收方的读取速率相匹配。IP 网络的拥塞而遏制的形式被称为 <strong>拥塞控制 congestion control</strong> 。</p><p>下面的讨论中会假设 TCP 接收方丢弃失序报文段。</p><p>TCP 让发送方维护一个称为 <strong>接收窗口 receive window</strong> 的变量来提供流量控制。非正式地讲，接收窗口用于告诉发送方，该接收方还有多少可用的缓存空间，而且连接两端的发送方都各自维护一个接收窗口。现在来研究在传输一个文件的情况下接收窗口的情况。</p><p><img loading="lazy" src="data:image/png;base64,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" width="371" height="207" class="img_ev3q"></p><p>假设主机 A 通过一条 TCP 连接向主机 B 发送一个大文件。主机 B 为该连接分配了一个接收缓存，并用 RcvBuffer 来表示大小。主机 B 上的应用不时地从该缓存中读取数据。并定义：1. LastByteRead 是主机 B 上的应用进程从缓存读出的数据流最后一个字节的编号。 2. LastByteRcvd 是从网络中到达的并且已放入主机 B 接受缓存中的数据流最后一个字节的编号。</p><p>由于 TCP 不允许已分配的缓存溢出，所以 <code>LastByteRcvd - LastByteRead &lt;= RcvBuffer</code> 必要成立，接收窗口用 RcvWindow 表示，根据缓存可用空间地数量来设置：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">RcvWindow = RcvBuffer - [LastByteRcvd - LastByteRead]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>显然， RcvWindow 是动态的。主机 B 通过把当前的 RcvWindow 值放入它发给主机 A 的报文段接收窗口字段中。连接起始 RcvWindow = RcvBuffer。</p><p>主机 A 轮流跟踪两个变量 LastByteSend 和 LastByteAcked ，这两个变量的差 <code>LastByteSent - LastByteAcked</code> 就是主机 A 发送到连接中但未被确认的数据量。通过将未确认的数据量控制在 RcvWindow 以下，就可以保证主机 A 不会被主机 B 的接收缓存溢出。因此主机 A 在整个连接的生命中必须保证 <code>LastByteSent - LastByteAcked &lt;= RcvWindow</code> 。</p><p>对于这个方案中还有一个神奇的地方。假设主机 B 的接收缓存已满， <code>RcvWindow = 0</code>。在将这个信息告诉主机 A 之后，B 就不再有任何数据（信息）发送给 A。那么随着主机 B 上的缓存逐渐清空，但是 A 再也没有发送新的数据，因为它不知道 B 的缓存被清空了。为了解决这样的问题，TCP 规约中要求：当主机 B 的接收窗口为 0 时，主机 A 继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存将开始清空，并且确认报文里将包含一个非 0 的 RcvWindow 的值。</p><blockquote><p>简要提一下 UDP 实现。UDP 将会把这些报文段添加到相应套接字“前面”的一个有限大小到缓存中。进程每次从缓存中读取一个完整到报文段。如果进程从缓存中读取报文段的速度不够快，那么缓存将会溢出且报文段将被丢弃。</p></blockquote><blockquote><p>TCP 连接管理</p></blockquote><p>这里会较为深入到讨论如何建立和拆除一条 TCP 连接。假如客户机上的进程要跟服务器上的进程建立一条 TCP 连接。客户机上到进程首先通知客户机 TCP，它想建立一条连接。步骤如下：</p><p><img loading="lazy" src="/assets/images/ch03f13-2f8f3b98fb68263a54310ee674458daf.png" width="700" height="653" class="img_ev3q"></p><ol><li><p>第一步。客户机的 TCP 首先向服务器的 TCP 发送一个特殊的 TCP 报文段。该报文段不包含应用层数据，但是报文段到首部中到 SYN 标志位置为 1。另外客户机会随机出一个起始序号（client_isn），并将其放在起始的 TCP SYN 报文段中的序号字段中。该报文段会被封装在一个 IP 数据报中，发送给服务器。</p></li><li><p>一旦包含 TCP SYN 报文段的 IP 数据报到达服务器主机，服务器会从该数据报中提取出 TCP SYN 报文段，为该 TCP 连接分配 TCP 缓存和变量，并向客户机 TCP 发送允许连接到报文段。这个允许连接的报文段也不包含应用层数据，但是报文段的首部却包含 3 个重要信息。首先，SYN 被置为 1。其次，该 TCP 报文段首部到确认号字段被置为 client_isn+1。最后，服务器选择自己的初始序号（server_isn)，并将其放置到 TCP 报文段首部到序号字段中。这个允许连接到报文段实际上表明了：“我收到了你要求建立连接的、带有初始序号 client_isn 的 SYN 分组。同意建立连接。本次连接中，我的初始序号为 server_isn”。</p></li><li><p>在收到允许连接报文段之后，客户机也要给该连接分配缓存和变量。客户机主机还会向服务器发送另外一个个报文段，这个报文段对服务器允许连接的报文段进行了确认（客户机通过将值 server_isn+1 放置到 TCP 报文段首部的确认字段中来完成此项工作）。因为连接已经建立了，SYN 比特被置为 0。</p></li></ol><p>一旦完成了上述 3 步过程，客户机和服务器就可以相互发送含有数据的报文段了。在之后的每个报文段中，SYN 比特都为 0。</p><blockquote><p>第三次握手时，允许携带应用层数据，此时会消耗序号（即序号会增长掉）。当然第三次握手也可以不带应用层数据，此时不消耗序号。<a href="https://yq.aliyun.com/articles/15118" target="_blank" rel="noopener noreferrer">拓展文章</a></p></blockquote><p>参与 TCP 连接建立的两个进程中的任何一个都能终止该连接。当连接结束后，主机中使用的“缓存和变量”等资源将被释放。</p><p><img loading="lazy" src="/assets/images/ch03f14-53833493f5fe85f87bd35cff3d4839a2.png" width="650" height="757" class="img_ev3q"></p><p>例如，客户机想要关闭连接。于是客户机应用进程发出一个关闭连接命令。此时客户机 TCP 会向服务器发送一个特殊的 TCP 报文段，这个报文段首部中的 FIN 比特位会被置为 1。当服务器接收到该报文段后，向客户机发送一个确认报文段。然后服务器发送其终止报文段，其中 FIN 比特位被置为 1。最后客户机对这个服务器的终止报文段进行确认。此时两台主机上用于该连接的所有资源都被释放了。</p><p>TCP 连接的生命周期内，运行在主机中的 TCP 协议在各种 <strong>TCP 状态 TCP state</strong> 之间变迁。</p><p><img loading="lazy" src="/assets/images/ch03f15-a0f0f308e44e9fe05abdaaf7ad4f7ca0.png" width="800" height="515" class="img_ev3q"></p><p>上图表示了 <em>客户机 TCP</em> 会经历的一系列典型 TCP 状态。客户机的应用程序发起一个新的 TCP 连接，这会引起客户机的 TCP 向服务器中的 TCP 发送一个 SYN 报文段 。客户机在发送过 SYN 报文段 之后，进入 SYN_SENT 同步发送 的状态，等待来自服务器 TCP 对客户机所发报文段进行确认的且 SYN 比特置为 1 的报文段。当接收到允许连接的报文段之后，客户机 TCP 进入 ESTABLISHED 状态，在这个状态下，TCP 客户机就能发送和接收包含有效载荷数据（应用层数据）的 TCP 报文段。</p><blockquote><p>[思考·如果服务器在第二次握手时，返回的确认报文段中，SYN 为 0，此时服务器该做什么？客户机又该做什么？]<!-- --> - <a href="http://www.cnblogs.com/menghuanbiao/p/5212131.html" target="_blank" rel="noopener noreferrer">虽然没找到答案，但是看看连接队列的问题</a></p></blockquote><p>假设客户机应用程序决定要关闭该连接（当然服务器也有这个主动权），这会引起客户机 TCP 发送一个 FIN 比特被置为 1 的 TCP 报文段，并进入 FIN_WAIT_1 状态，此时客户机等待着一个来自服务器的带有确认信息的 TCP 报文段。当它接收到允许关闭确认报文段时，客户机 TCP 进入 FIN_WAIT_2 状态，此时等待的是服务器中 FIN 比特被置为 1 的另一个报文段。当接收到服务器的关闭报文段后，可回家对服务器的报文段进行确认（发挥一个确认报文段），自身进入 TIME_WAIT 状态。 TIME_WAIT 使得 TCP 客户机重传最终确认报文，以防该 ACK 丢失。在 TIME_WAIT 中消耗的时间与具体实现有关，一般为 30s, 60s, 120s。经过等待后，连接就正式关闭了，客户机端所有与连接有关段资源（包括端口号）将被释放。</p><p><img loading="lazy" src="/assets/images/ch03f16-ddc9663dbfcc9e737d276933f82605f2.png" width="800" height="520" class="img_ev3q"></p><p>上图说明了服务器端 TCP 通常要经历的一系列 TCP 状态。其中假设是客户机申请段连接拆除。</p><p>上面假设了客户机和服务器都准备痛惜，即服务器正在即监听客户机发送它的 SYN 报文段段端口。考虑下面的情形：服务器接收到一条 TCP 报文段，其中的端口号或源 IP 地址与该主机上进行重的套接字都不匹配的情况。比如，服务器接收了具有目的端口 80 的一个 TCP SYN 分组，但服务器在 80 端口️不接收连接，于是乎服务器向源发送一个特殊的重置报文段。该重置报文段中 RST 标志位为 1，这个报文段告诉源：“服务器没有那个请求报文段中的套接字，请不要再发送相关的报文段了。”</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="网络拥塞控制方法">网络拥塞控制方法<a class="hash-link" href="#网络拥塞控制方法" title="Direct link to heading">​</a></h2><p>网路拥塞的原理简单概括就是重传、缓存限制等行为导致发送速率不能很高，就好像被堵住了一样。具体原因有很多，可自行网络搜索。</p><p>在最宽泛的层次上，可根据网络层是否为运输层拥塞控制提供了显示的帮助来区分拥塞控制方法。</p><p><strong>端到端拥塞控制</strong> 。在端到端拥塞控制方法中，网络层没有为运输层拥塞控制提供显式支持。即使在网络中存在拥塞，端系统也必须通过对网络行为的观察（分组丢失或时延）来推断。TCP 必须通过端到端的方法处理拥塞控制，因为 IP 层不会向端系统提供有关网络拥塞的反馈信息。TCP 报文段的丢失被认为是网络拥塞的一个迹象，TCP 会相应减小其窗口长度，另外 TCP 也可以通过往返时延值作为判断网络拥塞程度的指标。</p><p><strong>网络辅助的拥塞控制</strong> 。在网络辅助的拥塞控制中，网络层组件（路由器）向发送方提供关于网络中用色状态的显式反馈信息。这中方法可以通过一个比特来指示链路中的拥塞情况。还有一种 ATM ABR 拥塞控制，允许路由器显式地通知发送方，它（路由器）能在输出链路上支持的传输速率。</p><p><img loading="lazy" src="/assets/images/ch03f17-1a901ffb2754307e9db7bb245a18ae12.png" width="700" height="447" class="img_ev3q"></p><p>上图显示了对于网络辅助的拥塞控制，拥塞信息从网络反馈到发送方通常有两种方式。直接反馈信息可以由网络路由器发给发送方。这种方式的通知通常采用一种 <strong>阻塞分组 choke packet</strong> 的形式。另一种方式的通知是路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生。一旦接收方收到这个有拥塞标记的分组，机会通知发送方网络发生了拥塞，注意，这种形式的通知至少要经过一个完整的往返时间。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="tcp-拥塞控制">TCP 拥塞控制<a class="hash-link" href="#tcp-拥塞控制" title="Direct link to heading">​</a></h2><p>因为 IP 层不向端系统提供显式的网络拥塞反馈，TCP 必须使用端到端拥塞控制而不是网络辅助的拥塞控制。</p><p>TCP 采用的方法是让每一个发送方根据所感知到的网络拥塞的程度，来限制其能向连接发送流量的速率。如果发送方感知到没有什么拥塞，它就会增加发送速率。但是发送方感知到了有拥塞，就会降低其发送速率。这种方法提出了三个问题：1.发送方如何限制它向连接发送流量的速率，2.发送方如何感知它从目的地之间的路径上存在拥塞，3.当发送方感知到端到端的拥塞时，采用什么算法来改变其发送速率。</p><p>先看一下 TCP 发送方时如何限制向其连接发送流量的。TCP 连接的每一端都有一个接收缓存、一个发送缓存和几个变量（LastByteRead, RcvWindow 等）。TCP 拥塞控制机制让连接的每一端都记录一个额外的变量，即 <strong>拥塞窗口 congestion window</strong> 。拥塞窗口表示为 CongWin，它对每一个 TCP 发送方能向网络中发送流量的速率进行限制。特别是在一个发送方中未被确认的数据量不会超过 CongWin 与 RcvWindow 中的最小值，即</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">LastByteSent - LastByteAcked &lt;= min{CongWin, RcvWindow}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>为了关注拥塞控制（与流量控制形成对比），假设 TCP 接收缓存足够大，因此发送方中未被确认的数据量仅受限于 CongWin。上面的约束限制了发送方中未被确认的数据量，因此间接地限制了发送方的发送速率。</p><p>接下来考虑 TCP 发送方是如何感知它与目的地之间的路径上出现了拥塞。当出现过度拥塞时，连接路径上的路由器发生缓存溢出，导致数据报丢失。丢失的数据报会引起发送方的丢失事件（超时或者收到 3 个冗余 ACK），发送方就认为连接路径上出现了拥塞的指示。</p><p>考虑了拥塞检测问题之后，接下来考虑网络没有拥塞的更为乐观的情况，即没有出现丢包事件。此时 TCP 的发送方将收到对于以前未确认报文段的确认。TCP 将这些确认的到达作为一切正常的标志，并使用确认来增加拥塞窗口的长度（及其传输速率）。如果确认以相当慢的速率到达，则拥塞窗口将以相当慢的速率增加。反过来，确认以高速率到达，则该拥塞窗口就会更迅速地增大。因为 TCP 使用确认来触发它的拥塞窗口长度的增大，所以 TCP 被称为 <strong>自计时 self-clocking</strong> 。</p><p>接下来考虑 TCP 发送方的调节算法细节。这个算法就是广受好评的 <strong>TCP 拥塞控制算法 TCP congestion control algorithm</strong> 。包括 3 个主要部分：1.加性增 additive-increase、乘性减 multiplicative-decrease，2.慢启动 slow start，3.对超时事件作出反应。</p><blockquote><p>加性增、乘性减</p></blockquote><p>TCP 拥塞控制的基本思想时，当出现丢包事件时，让发送方通过减小拥塞窗口 CongWin 的大小来降低其发送速率。因为通过该相同拥塞路由器的其他 TCP 连接也很可能出现丢包事件，所以它们也可能会降低其发送速率。因此该整体租用时让所有通过这一拥塞路由器路径的源来降低它们向网络发送数据的速率，从而减轻拥塞程度。</p><p>当出现丢包事件时，TCP 就将当前的 CongWin 值减半。CongWin 值也许会多次减半，但是不能降低到 1 个 MSS 之下。</p><p>增大发送速率的基本原则是，TCP 察觉到没有拥塞时，说明可能有可用的带宽被该 TCP 使用，TCP 会缓慢的增加其拥塞窗口的长度。TCP 的具体表现是，每次它接收到一个确认后就把 CongWin 增大一点，其目标是在每个往返时延内 CongWin 增加一个 MSS。</p><blockquote><p>例如，MSS=1460 字节，CongWin 是 14600 字节，则在一个 RTT 内发送 10 个报文段。每到达一个 ACK，拥塞窗口长度增加 1/10 MSS，因此在收到所有 10 个报文段的确认以后，拥塞窗口的值会增加 MSS，与期望值一样。</p></blockquote><p><img loading="lazy" src="data:image/png;base64,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" width="434" height="211" class="img_ev3q"></p><blockquote><p>慢启动</p></blockquote><p>当一个 TCP 连接开始时，CongWin 的值初始置为 1 个 MSS。这就使得初始发送速率大约为 MSS／RTT 。因此 TCP 发送方在初始阶段不是线性地增加其他发送速率，而是以指数的速度增加，即每过一个 RTT 将 CongWin 翻倍。直到发生一个丢包事件后，CongWin 将被将为一半，此后就变成了线性增加。因此这个被称为 <strong>慢启动 slow start</strong> 的初始化阶段期间，TCP 发送方以慢速率发送，但是以指数的速度快速增加。每当一个传输报文段被确认后，CongWin 的值就增加 1 个 MSS，从而使得发送方的发送速率得到指数级增长。</p><p><img loading="lazy" src="/assets/images/ch03f19-18a8dece5f9093d9bd013f5d3f801718.png" width="600" height="594" class="img_ev3q"></p><p>如上图，TCP 向网络发送第一个报文段并等待一个确认。如果该报文段在丢包之前被确认，则 TCP 发送方将拥塞窗口增加一个 MSS，并发出两个最大长度的报文段，如果这两个报文段在超时之前都被确认，则发送方每收到一个确认报文段就将拥塞窗口增加 1 个 MSS。使得拥塞窗口变成 4 个 MSS，并发射出 4 个最大长度的报文段。只要确认报文段在丢包事件之前到达，这个过程就会继续下去。</p><p>[图中题外话]<!-- -->图中的客户机先发起了关闭请求，服务直到处理完其他数据请求之后才响应了关闭请求。</p><blockquote><p>应对超时事件</p></blockquote><p>TCP 对 因超时的丢包事件 和 因收到 3 个冗余 ACK 的丢包事件 的处理策略是不同的。</p><p>在收到 3 个冗余 ACK 的丢包事件，TCP 会减半拥塞窗口，然后线性增加。但是发生超时事件时，TCP 发送方进入一个慢启动阶段，即它将拥塞窗口设置为 1 个 MSS，然后窗口长度以指数形式增长，直到增长到发送超时事件之前窗口值的一半。此后，拥塞窗口按线性增长，就跟冗余 ACK 事件一样。</p><p>TCP 通过位置一个称为 <strong>阈值 Threshold</strong> 的变量来管理这些较为复杂的动态过程。Threshold 的初始值设置的很大，（比如 65KB ），以便它没有初始效应。每当发送一个超时丢包事件时，Threshold 值就设为当前 CongWin 值的一半，所以超时事件发生后的慢启动过程能有个结束判断。</p><p>事实上，这个阈值的讨论也很多，以及收到 3 个冗余 ACK 是否也要进行慢启动的讨论，涉及很多策略及实现，详细的内容可以去别的地方搜索。</p><blockquote><p>书中还讨论了一些丢包率、公平性等问题，可作为拓展性知识去阅读。</p></blockquote></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/docs/tags/network">network</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/network-top-down-approach/ch02-application-layer"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">应用层</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/network-top-down-approach/ch04-network-layer"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">网络层</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#概述和运输层服务" class="table-of-contents__link toc-highlight">概述和运输层服务</a></li><li><a href="#多路复用与多路分解" class="table-of-contents__link toc-highlight">多路复用与多路分解</a></li><li><a href="#无连接运输-udp" class="table-of-contents__link toc-highlight">无连接运输 UDP</a><ul><li><a href="#udp-报文段结构" class="table-of-contents__link toc-highlight">UDP 报文段结构</a></li></ul></li><li><a href="#可靠数据传输的原理" class="table-of-contents__link toc-highlight">可靠数据传输的原理</a></li><li><a href="#面向连接的运输tcp" class="table-of-contents__link toc-highlight">面向连接的运输：TCP</a><ul><li><a href="#tcp-概述" class="table-of-contents__link toc-highlight">TCP 概述</a></li><li><a href="#tcp-报文段结构" class="table-of-contents__link toc-highlight">TCP 报文段结构</a></li><li><a href="#往返时延的估计与超时" class="table-of-contents__link toc-highlight">往返时延的估计与超时</a></li><li><a href="#可靠数据传输" class="table-of-contents__link toc-highlight">可靠数据传输</a></li></ul></li><li><a href="#网络拥塞控制方法" class="table-of-contents__link toc-highlight">网络拥塞控制方法</a></li><li><a href="#tcp-拥塞控制" class="table-of-contents__link toc-highlight">TCP 拥塞控制</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Repositories</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/AkatQuas/kiddo-plays" target="_blank" rel="noopener noreferrer" class="footer__link-item">Kiddo plays<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/AkatQuas/nprogresse" target="_blank" rel="noopener noreferrer" class="footer__link-item">NProgressE<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/AkatQuas" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Links</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/AkatQuas" target="_blank" rel="noopener noreferrer" class="footer__link-item">Who would it be?<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 AkatQuas. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.5d758bff.js"></script>
<script src="/assets/js/main.6f4b5c91.js"></script>
</body>
</html>